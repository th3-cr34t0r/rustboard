/* automatically generated by rust-bindgen 0.72.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe { *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize) };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val { byte | mask } else { byte & !mask }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe { (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize) };
        unsafe { *byte = Self::change_bit(*byte, index, val) };
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const SDC_DEFAULT_RESOURCE_CFG_TAG: u32 = 0;
pub const SDC_DEFAULT_ADV_COUNT: u32 = 1;
pub const SDC_DEFAULT_PERIODIC_ADV_COUNT: u32 = 0;
pub const SDC_DEFAULT_PERIODIC_SYNC_COUNT: u32 = 0;
pub const SDC_DEFAULT_PERIODIC_ADV_RSP_COUNT: u32 = 0;
pub const SDC_DEFAULT_PERIODIC_ADV_RSP_TX_BUFFER_COUNT: u32 = 1;
pub const SDC_DEFAULT_PERIODIC_ADV_RSP_MAX_TX_DATA: u32 = 73;
pub const SDC_DEFAULT_PERIODIC_ADV_RSP_RX_BUFFER_COUNT: u32 = 0;
pub const SDC_DEFAULT_PERIODIC_SYNC_RSP_TX_BUFFER_COUNT: u32 = 1;
pub const SDC_DEFAULT_PERIPHERAL_COUNT: u32 = 1;
pub const SDC_DEFAULT_CENTRAL_COUNT: u32 = 1;
pub const SDC_DEFAULT_TX_PACKET_SIZE: u32 = 27;
pub const SDC_DEFAULT_RX_PACKET_SIZE: u32 = 27;
pub const SDC_DEFAULT_TX_PACKET_COUNT: u32 = 3;
pub const SDC_DEFAULT_RX_PACKET_COUNT: u32 = 2;
pub const SDC_DEFAULT_FAL_SIZE: u32 = 8;
pub const SDC_DEFAULT_SCAN_BUFFER_COUNT: u32 = 3;
pub const SDC_DEFAULT_PERIODIC_SYNC_BUFFER_COUNT: u32 = 2;
pub const SDC_DEFAULT_ADV_BUF_SIZE: u32 = 31;
pub const SDC_DEFAULT_PERIODIC_ADV_LIST_SIZE: u32 = 0;
pub const SDC_DEFAULT_CIG_COUNT: u32 = 0;
pub const SDC_DEFAULT_CIS_COUNT: u32 = 0;
pub const SDC_DEFAULT_BIG_COUNT: u32 = 0;
pub const SDC_DEFAULT_BIS_SINK_COUNT: u32 = 0;
pub const SDC_DEFAULT_BIS_SOURCE_COUNT: u32 = 0;
pub const SDC_DEFAULT_ISO_RX_PDU_BUFFER_PER_STREAM_COUNT: u32 = 0;
pub const SDC_DEFAULT_ISO_RX_SDU_BUFFER_COUNT: u32 = 0;
pub const SDC_DEFAULT_ISO_RX_SDU_BUFFER_SIZE: u32 = 251;
pub const SDC_DEFAULT_ISO_TX_SDU_BUFFER_COUNT: u32 = 0;
pub const SDC_DEFAULT_ISO_TX_SDU_BUFFER_SIZE: u32 = 247;
pub const SDC_DEFAULT_ISO_TX_PDU_BUFFER_PER_STREAM_COUNT: u32 = 0;
pub const SDC_DEFAULT_CS_COUNT: u32 = 0;
pub const SDC_DEFAULT_CS_MAX_ANTENNA_PATHS_SUPPORTED: u32 = 1;
pub const SDC_DEFAULT_CS_NUM_ANTENNAS_SUPPORTED: u32 = 1;
pub const SDC_BUILD_REVISION_SIZE: u32 = 20;
pub const __MEM_MINIMAL_CENTRAL_LINK_SIZE: u32 = 763;
pub const __MEM_MINIMAL_PERIPHERAL_LINK_SIZE: u32 = 875;
pub const __MEM_TX_BUFFER_OVERHEAD_SIZE: u32 = 15;
pub const __MEM_RX_BUFFER_OVERHEAD_SIZE: u32 = 15;
pub const SDC_MEM_CENTRAL_LINKS_SHARED: u32 = 21;
pub const SDC_MEM_PERIPHERAL_LINKS_SHARED: u32 = 17;
pub const SDC_MEM_QOS_CHANNEL_SURVEY: u32 = 40;
pub const SDC_MEM_INITIATOR: u32 = 296;
pub const __MEM_PER_PERIODIC_ADV_RSP_RX_BUFFER: u32 = 282;
pub const __MEM_MINIMAL_PERIODIC_ADV_RSP_SET_SIZE_WITH_RX: u32 = 470;
pub const __MEM_MINIMAL_PERIODIC_ADV_RSP_SET_SIZE_WITHOUT_RX: u32 = 166;
pub const __MEM_FOR_PERIODIC_ADV_RSP_FAILURE_REPORTING: u32 = 224;
pub const HCI_CMD_HEADER_SIZE: u32 = 3;
pub const HCI_DATA_HEADER_SIZE: u32 = 4;
pub const HCI_ISO_DATA_HEADER_SIZE: u32 = 12;
pub const HCI_EVENT_HEADER_SIZE: u32 = 2;
pub const HCI_CMD_MAX_SIZE: u32 = 255;
pub const HCI_DATA_MAX_SIZE: u32 = 251;
pub const HCI_ISO_DATA_MAX_SIZE: u32 = 4095;
pub const HCI_EVENT_MAX_SIZE: u32 = 255;
pub const HCI_CMD_PACKET_MAX_SIZE: u32 = 258;
pub const HCI_DATA_PACKET_MAX_SIZE: u32 = 255;
pub const HCI_ISO_DATA_PACKET_MAX_SIZE: u32 = 4107;
pub const HCI_EVENT_PACKET_MAX_SIZE: u32 = 257;
pub const HCI_MSG_BUFFER_MAX_SIZE: u32 = 258;
pub const HCI_MSG_BUFFER_ISO_MAX_SIZE: u32 = 4107;
pub const HCI_ISO_TX_SDU_ARRIVAL_MARGIN_US: u32 = 1000;
pub const SDC_PPI_CHANNELS_USED_MASK: u32 = 4294836224;
#[doc = "Function prototype for the fault handler.\n\n > **Note:** The SoftDevice Controller will disable all interrupts prior to calling the\n fault handler. The SoftDevice Controller will reset the chip if the\n application returns from this function.\n\n # Arguments\n\n* `[in]` -file The filename where the assertion occurred.\n * `[in]` -line The line number where the assertion occurred."]
pub type sdc_fault_handler_t =
    ::core::option::Option<unsafe extern "C" fn(file: *const ::core::ffi::c_char, line: u32)>;
#[doc = "Function prototype for the SoftDevice Controller callback.\n\n See also sdc_enable()."]
pub type sdc_callback_t = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = "Function prototype for antenna switching callback in Channel Sounding.\n\n See also sdc_support_channel_sounding\n\n # Arguments\n\n* `[in]` -antenna_index The index of the antenna being switched to.\n Valid range sdc_cfg_cs_cfg_t::num_antennas_supported - 1]"]
pub type sdc_cs_antenna_switch_callback_t = ::core::option::Option<unsafe extern "C" fn(antenna_index: u8)>;
#[doc = "No configuration update."]
pub const SDC_CFG_TYPE_NONE: sdc_cfg_type = 0;
#[doc = "See sdc_cfg_t::central_count."]
pub const SDC_CFG_TYPE_CENTRAL_COUNT: sdc_cfg_type = 1;
#[doc = "See sdc_cfg_t::peripheral_count."]
pub const SDC_CFG_TYPE_PERIPHERAL_COUNT: sdc_cfg_type = 2;
#[doc = "See sdc_cfg_t::buffer_cfg."]
pub const SDC_CFG_TYPE_BUFFER_CFG: sdc_cfg_type = 3;
#[doc = "See sdc_cfg_t::adv_count."]
pub const SDC_CFG_TYPE_ADV_COUNT: sdc_cfg_type = 4;
#[doc = "See sdc_cfg_t::scan_buffer_cfg."]
pub const SDC_CFG_TYPE_SCAN_BUFFER_CFG: sdc_cfg_type = 5;
#[doc = "See sdc_cfg_t::adv_buffer_cfg."]
pub const SDC_CFG_TYPE_ADV_BUFFER_CFG: sdc_cfg_type = 6;
#[doc = "See sdc_cfg_t::fal_size"]
pub const SDC_CFG_TYPE_FAL_SIZE: sdc_cfg_type = 7;
#[doc = "See sdc_cfg_t::periodic_adv_count."]
pub const SDC_CFG_TYPE_PERIODIC_ADV_COUNT: sdc_cfg_type = 8;
#[doc = "See sdc_cfg_t::periodic_sync_count."]
pub const SDC_CFG_TYPE_PERIODIC_SYNC_COUNT: sdc_cfg_type = 9;
#[doc = "See sdc_cfg_t::periodic_sync_buffer_cfg."]
pub const SDC_CFG_TYPE_PERIODIC_SYNC_BUFFER_CFG: sdc_cfg_type = 10;
#[doc = "See sdc_cfg_t::periodic_adv_list_size."]
pub const SDC_CFG_TYPE_PERIODIC_ADV_LIST_SIZE: sdc_cfg_type = 11;
#[doc = "See sdc_cfg_t::periodic_adv_rsp_count."]
pub const SDC_CFG_TYPE_PERIODIC_ADV_RSP_COUNT: sdc_cfg_type = 12;
#[doc = "See sdc_cfg_t::periodic_adv_rsp_buffer_cfg."]
pub const SDC_CFG_TYPE_PERIODIC_ADV_RSP_BUFFER_CFG: sdc_cfg_type = 13;
#[doc = "See sdc_cfg_t::periodic_adv_rsp_failure_reporting_cfg."]
pub const SDC_CFG_TYPE_PERIODIC_ADV_RSP_FAILURE_REPORTING_CFG: sdc_cfg_type = 14;
#[doc = "See sdc_cfg_t::periodic_sync_rsp_tx_buffer_cfg."]
pub const SDC_CFG_TYPE_PERIODIC_SYNC_RSP_TX_BUFFER_CFG: sdc_cfg_type = 15;
#[doc = "See sdc_cfg_t::cig_count."]
pub const SDC_CFG_TYPE_CIG_COUNT: sdc_cfg_type = 16;
#[doc = "See sdc_cfg_t::cis_count."]
pub const SDC_CFG_TYPE_CIS_COUNT: sdc_cfg_type = 17;
#[doc = "See sdc_cfg_t::big_count."]
pub const SDC_CFG_TYPE_BIG_COUNT: sdc_cfg_type = 18;
#[doc = "See sdc_cfg_t::bis_sink_count."]
pub const SDC_CFG_TYPE_BIS_SINK_COUNT: sdc_cfg_type = 19;
#[doc = "See sdc_cfg_t::bis_source_count."]
pub const SDC_CFG_TYPE_BIS_SOURCE_COUNT: sdc_cfg_type = 20;
#[doc = "See sdc_cfg_t::iso_buffer_cfg."]
pub const SDC_CFG_TYPE_ISO_BUFFER_CFG: sdc_cfg_type = 21;
#[doc = "See sdc_cfg_t::cs_count."]
pub const SDC_CFG_TYPE_CS_COUNT: sdc_cfg_type = 22;
#[doc = "See sdc_cfg_t::cs_cfg."]
pub const SDC_CFG_TYPE_CS_CFG: sdc_cfg_type = 23;
pub type sdc_cfg_type = ::core::ffi::c_uint;
#[doc = "Role count."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_cfg_role_count_t {
    #[doc = "< Max number of concurrent roles."]
    pub count: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_cfg_role_count_t"][::core::mem::size_of::<sdc_cfg_role_count_t>() - 1usize];
    ["Alignment of sdc_cfg_role_count_t"][::core::mem::align_of::<sdc_cfg_role_count_t>() - 1usize];
    ["Offset of field: sdc_cfg_role_count_t::count"][::core::mem::offset_of!(sdc_cfg_role_count_t, count) - 0usize];
};
#[doc = "Buffer configuration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_cfg_buffer_cfg_t {
    #[doc = "< Link Layer TX packet size. Valid range: 27-251.\nDefault: SDC_DEFAULT_TX_PACKET_SIZE."]
    pub tx_packet_size: u16,
    #[doc = "< Link Layer RX packet size. Valid range: 27-251.\nDefault: SDC_DEFAULT_RX_PACKET_SIZE."]
    pub rx_packet_size: u16,
    #[doc = "< Link Layer TX packet count per link. Minimum of 1.\nDefault: SDC_DEFAULT_TX_PACKET_COUNT."]
    pub tx_packet_count: u8,
    #[doc = "< Link Layer RX packet count per link. Minimum of 1.\nDefault: SDC_DEFAULT_RX_PACKET_COUNT."]
    pub rx_packet_count: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_cfg_buffer_cfg_t"][::core::mem::size_of::<sdc_cfg_buffer_cfg_t>() - 6usize];
    ["Alignment of sdc_cfg_buffer_cfg_t"][::core::mem::align_of::<sdc_cfg_buffer_cfg_t>() - 2usize];
    ["Offset of field: sdc_cfg_buffer_cfg_t::tx_packet_size"]
        [::core::mem::offset_of!(sdc_cfg_buffer_cfg_t, tx_packet_size) - 0usize];
    ["Offset of field: sdc_cfg_buffer_cfg_t::rx_packet_size"]
        [::core::mem::offset_of!(sdc_cfg_buffer_cfg_t, rx_packet_size) - 2usize];
    ["Offset of field: sdc_cfg_buffer_cfg_t::tx_packet_count"]
        [::core::mem::offset_of!(sdc_cfg_buffer_cfg_t, tx_packet_count) - 4usize];
    ["Offset of field: sdc_cfg_buffer_cfg_t::rx_packet_count"]
        [::core::mem::offset_of!(sdc_cfg_buffer_cfg_t, rx_packet_count) - 5usize];
};
#[doc = "Buffer count configuration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_cfg_buffer_count_t {
    #[doc = "< Number of buffers."]
    pub count: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_cfg_buffer_count_t"][::core::mem::size_of::<sdc_cfg_buffer_count_t>() - 1usize];
    ["Alignment of sdc_cfg_buffer_count_t"][::core::mem::align_of::<sdc_cfg_buffer_count_t>() - 1usize];
    ["Offset of field: sdc_cfg_buffer_count_t::count"][::core::mem::offset_of!(sdc_cfg_buffer_count_t, count) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_cfg_adv_buffer_cfg_t {
    #[doc = "The maximum advertising data length that can be used by an advertiser\n\n If set to 31, the controller will support 31 bytes of advertising data and scan response data.\n Setting a value larger than 31 bytes is only useful when supporting extended advertising.\n\n Default: SDC_DEFAULT_ADV_BUF_SIZE."]
    pub max_adv_data: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_cfg_adv_buffer_cfg_t"][::core::mem::size_of::<sdc_cfg_adv_buffer_cfg_t>() - 2usize];
    ["Alignment of sdc_cfg_adv_buffer_cfg_t"][::core::mem::align_of::<sdc_cfg_adv_buffer_cfg_t>() - 2usize];
    ["Offset of field: sdc_cfg_adv_buffer_cfg_t::max_adv_data"]
        [::core::mem::offset_of!(sdc_cfg_adv_buffer_cfg_t, max_adv_data) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_cfg_periodic_adv_rsp_buffer_cfg_t {
    #[doc = "Configures the size of the buffer pool allocated to each periodic\n advertising set with responses for subevent data.\n\n Default: SDC_DEFAULT_PERIODIC_ADV_RSP_TX_BUFFER_COUNT."]
    pub tx_buffer_count: u8,
    #[doc = "Configures the maximum amount of data which can be sent in a PAwR subevent.\n\n Default: SDC_DEFAULT_PERIODIC_ADV_RSP_MAX_TX_DATA."]
    pub max_tx_data_size: u8,
    #[doc = "Configures the size of the buffer pool allocated to each periodic\n advertising set with responses for response reports.\n\n The value can be set to 0 to disable listening for responses.\n\n Default: SDC_DEFAULT_PERIODIC_ADV_RSP_RX_BUFFER_COUNT."]
    pub rx_buffer_count: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_cfg_periodic_adv_rsp_buffer_cfg_t"]
        [::core::mem::size_of::<sdc_cfg_periodic_adv_rsp_buffer_cfg_t>() - 3usize];
    ["Alignment of sdc_cfg_periodic_adv_rsp_buffer_cfg_t"]
        [::core::mem::align_of::<sdc_cfg_periodic_adv_rsp_buffer_cfg_t>() - 1usize];
    ["Offset of field: sdc_cfg_periodic_adv_rsp_buffer_cfg_t::tx_buffer_count"]
        [::core::mem::offset_of!(sdc_cfg_periodic_adv_rsp_buffer_cfg_t, tx_buffer_count) - 0usize];
    ["Offset of field: sdc_cfg_periodic_adv_rsp_buffer_cfg_t::max_tx_data_size"]
        [::core::mem::offset_of!(sdc_cfg_periodic_adv_rsp_buffer_cfg_t, max_tx_data_size) - 1usize];
    ["Offset of field: sdc_cfg_periodic_adv_rsp_buffer_cfg_t::rx_buffer_count"]
        [::core::mem::offset_of!(sdc_cfg_periodic_adv_rsp_buffer_cfg_t, rx_buffer_count) - 2usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_cfg_iso_buffer_cfg_t {
    #[doc = "Configures the number of shared SDU TX buffers allocated for ISO.\n\n Default: SDC_DEFAULT_ISO_TX_SDU_BUFFER_COUNT."]
    pub tx_sdu_buffer_count: u8,
    #[doc = "Configures the size of shared SDU TX buffers allocated for ISO.\n\n Default: SDC_DEFAULT_ISO_TX_SDU_BUFFER_SIZE."]
    pub tx_sdu_buffer_size: u16,
    #[doc = "Configures the number of TX PDU buffers allocated per ISO stream.\n\n This is the number of maximum size (251 bytes) PDU buffers. When PDU size is smaller\n than the maximum size, the pool will be repartitioned into a larger number of adjusted PDUs.\n\n For BIS, this value is used to determine the furthest PDU that can be stored in the buffers.\n Therefore, limiting the number of pretransmission subevents and maximum pretransmission offset (PTO)\n that the controller can use.\n\n Default: SDC_DEFAULT_ISO_TX_PDU_BUFFER_PER_STREAM_COUNT."]
    pub tx_pdu_buffer_per_stream_count: u8,
    #[doc = "Configures the number of RX PDU buffers allocated per ISO stream.\n\n This is the number of maximum size (251 bytes) PDU buffers. When PDU size is smaller\n than the maximum size, the pool will be repartitioned into a larger number of adjusted PDUs.\n\n For BIS, this value determines how many pretransmissions can be stored and utilized.\n\n Default: SDC_DEFAULT_ISO_RX_PDU_BUFFER_PER_STREAM_COUNT."]
    pub rx_pdu_buffer_per_stream_count: u8,
    #[doc = "Configures the number of RX SDU buffers allocated for ISO.\n\n Default: SDC_DEFAULT_ISO_RX_SDU_BUFFER_COUNT."]
    pub rx_sdu_buffer_count: u8,
    #[doc = "Configures the size of RX SDU buffers allocated for ISO.\n\n Default: SDC_DEFAULT_ISO_RX_SDU_BUFFER_SIZE."]
    pub rx_sdu_buffer_size: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_cfg_iso_buffer_cfg_t"][::core::mem::size_of::<sdc_cfg_iso_buffer_cfg_t>() - 10usize];
    ["Alignment of sdc_cfg_iso_buffer_cfg_t"][::core::mem::align_of::<sdc_cfg_iso_buffer_cfg_t>() - 2usize];
    ["Offset of field: sdc_cfg_iso_buffer_cfg_t::tx_sdu_buffer_count"]
        [::core::mem::offset_of!(sdc_cfg_iso_buffer_cfg_t, tx_sdu_buffer_count) - 0usize];
    ["Offset of field: sdc_cfg_iso_buffer_cfg_t::tx_sdu_buffer_size"]
        [::core::mem::offset_of!(sdc_cfg_iso_buffer_cfg_t, tx_sdu_buffer_size) - 2usize];
    ["Offset of field: sdc_cfg_iso_buffer_cfg_t::tx_pdu_buffer_per_stream_count"]
        [::core::mem::offset_of!(sdc_cfg_iso_buffer_cfg_t, tx_pdu_buffer_per_stream_count) - 4usize];
    ["Offset of field: sdc_cfg_iso_buffer_cfg_t::rx_pdu_buffer_per_stream_count"]
        [::core::mem::offset_of!(sdc_cfg_iso_buffer_cfg_t, rx_pdu_buffer_per_stream_count) - 5usize];
    ["Offset of field: sdc_cfg_iso_buffer_cfg_t::rx_sdu_buffer_count"]
        [::core::mem::offset_of!(sdc_cfg_iso_buffer_cfg_t, rx_sdu_buffer_count) - 6usize];
    ["Offset of field: sdc_cfg_iso_buffer_cfg_t::rx_sdu_buffer_size"]
        [::core::mem::offset_of!(sdc_cfg_iso_buffer_cfg_t, rx_sdu_buffer_size) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_cfg_cs_cfg_t {
    #[doc = "Configures the maximum number of antenna paths supported in Channel Sounding.\n Valid range 4].\n\n Default: SDC_DEFAULT_CS_MAX_ANTENNA_PATHS_SUPPORTED."]
    pub max_antenna_paths_supported: u8,
    #[doc = "Configures the number of antennas supported by the local device in Channel Sounding.\n Valid range max_antenna_paths_supported].\n\n Default: SDC_DEFAULT_CS_NUM_ANTENNAS_SUPPORTED."]
    pub num_antennas_supported: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_cfg_cs_cfg_t"][::core::mem::size_of::<sdc_cfg_cs_cfg_t>() - 2usize];
    ["Alignment of sdc_cfg_cs_cfg_t"][::core::mem::align_of::<sdc_cfg_cs_cfg_t>() - 1usize];
    ["Offset of field: sdc_cfg_cs_cfg_t::max_antenna_paths_supported"]
        [::core::mem::offset_of!(sdc_cfg_cs_cfg_t, max_antenna_paths_supported) - 0usize];
    ["Offset of field: sdc_cfg_cs_cfg_t::num_antennas_supported"]
        [::core::mem::offset_of!(sdc_cfg_cs_cfg_t, num_antennas_supported) - 1usize];
};
#[doc = "SoftDevice Controller configuration."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union sdc_cfg_t {
    #[doc = "Max number of concurrent central connections.\n Default: SDC_DEFAULT_CENTRAL_COUNT."]
    pub central_count: sdc_cfg_role_count_t,
    #[doc = "Max number of concurrent peripheral connections.\n Default: SDC_DEFAULT_PERIPHERAL_COUNT."]
    pub peripheral_count: sdc_cfg_role_count_t,
    #[doc = "Configures the number and size of the data buffers available per link.\n Default: See sdc_cfg_buffer_cfg_t."]
    pub buffer_cfg: sdc_cfg_buffer_cfg_t,
    #[doc = "Max number of concurrent advertisers.\n Must be more than or equal to sdc_cfg_t::periodic_adv_count.\n Default: SDC_DEFAULT_ADV_COUNT."]
    pub adv_count: sdc_cfg_role_count_t,
    #[doc = "Configures the maximum number of advertising reports available in the scanner.\n\n The minimum allowed number of buffers is 2.\n\n It is recommended to support at least three buffers,\n otherwise the scan response report will likely not be generated.\n\n Default: SDC_DEFAULT_SCAN_BUFFER_COUNT."]
    pub scan_buffer_cfg: sdc_cfg_buffer_count_t,
    #[doc = "Configures the maximum advertising data per advertising set.\n Default: See sdc_cfg_adv_buffer_cfg_t."]
    pub adv_buffer_cfg: sdc_cfg_adv_buffer_cfg_t,
    #[doc = "Configures the maximum size of the Filter Accept List.\n\n Default: SDC_DEFAULT_FAL_SIZE."]
    pub fal_size: u16,
    #[doc = "Configures the maximum number of concurrent periodic advertisers.\n Must be less than or equal to sdc_cfg_t::adv_count.\n Default: SDC_DEFAULT_PERIODIC_ADV_COUNT."]
    pub periodic_adv_count: sdc_cfg_role_count_t,
    #[doc = "Configures the maximum number of concurrent synchronizations\n to periodic advertisers.\n Default: SDC_DEFAULT_PERIODIC_SYNC_COUNT."]
    pub periodic_sync_count: sdc_cfg_role_count_t,
    #[doc = "Configures the maximum number of periodic advertising reports available\n for each synchronization to a periodic advertiser.\n\n Each synchronization to a periodic advertiser allocates its own buffer\n pool.\n\n When periodic sync with responses is not supported,\n the minimum allowed number of buffers is 2.\n\n When periodic sync with responses is supported,\n the minimum allowed number of buffers is 1.\n\n No reports for a new advertising event containing chained PDUs will be\n enqueued until the host has emptied the previous event's buffers.\n\n Default: SDC_DEFAULT_PERIODIC_SYNC_BUFFER_COUNT."]
    pub periodic_sync_buffer_cfg: sdc_cfg_buffer_count_t,
    #[doc = "Configures the size of the periodic advertiser list.\n\n The maximum number of supported devices is 8.\n\n Default: SDC_DEFAULT_PERIODIC_ADV_LIST_SIZE."]
    pub periodic_adv_list_size: u8,
    #[doc = "Configures the maximum number of concurrent periodic advertising sets with responses.\n\n Default: SDC_DEFAULT_PERIODIC_ADV_RSP_COUNT."]
    pub periodic_adv_rsp_count: sdc_cfg_role_count_t,
    #[doc = "Configures the number and size of the data buffers available per periodic advertising set with responses.\n Default: See sdc_cfg_periodic_adv_rsp_buffer_cfg_t."]
    pub periodic_adv_rsp_buffer_cfg: sdc_cfg_periodic_adv_rsp_buffer_cfg_t,
    #[doc = "Enables/disables failure response reports for Periodic Advertising with Responses - Advertiser.\n\n Set to 1 to enable RX failure reporting, 0 to disable.\n\n Default: disabled."]
    pub periodic_adv_rsp_failure_reporting_cfg: u8,
    #[doc = "Configures the maximum number of responses that can be stored in the controller\n when synchronized to a periodic advertiser with responses.\n\n The minimum number of buffers is 1.\n\n Default: SDC_DEFAULT_PERIODIC_SYNC_RSP_TX_BUFFER_COUNT."]
    pub periodic_sync_rsp_tx_buffer_cfg: sdc_cfg_buffer_count_t,
    #[doc = "Configures the maximum number of concurrent CIGs.\n\n Default: SDC_DEFAULT_CIG_COUNT."]
    pub cig_count: sdc_cfg_role_count_t,
    #[doc = "Configures the maximum number of concurrent CISs.\n\n Default: SDC_DEFAULT_CIS_COUNT."]
    pub cis_count: sdc_cfg_role_count_t,
    #[doc = "Configures the maximum number of concurrent BIGs.\n\n Default: SDC_DEFAULT_BIG_COUNT."]
    pub big_count: sdc_cfg_role_count_t,
    #[doc = "Configures the maximum number of concurrent sink BISs.\n\n Default: SDC_DEFAULT_BIS_SINK_COUNT."]
    pub bis_sink_count: sdc_cfg_role_count_t,
    #[doc = "Configures the maximum number of concurrent source BISs.\n\n Default: SDC_DEFAULT_BIS_SOURCE_COUNT."]
    pub bis_source_count: sdc_cfg_role_count_t,
    #[doc = "Configures the number and size of buffers allocated for ISO.\n\n Default: See sdc_cfg_iso_buffer_cfg_t."]
    pub iso_buffer_cfg: sdc_cfg_iso_buffer_cfg_t,
    #[doc = "Configures the maximum number of concurrent connections supporting CS procedure.\n\n Default: SDC_DEFAULT_CS_COUNT."]
    pub cs_count: sdc_cfg_role_count_t,
    #[doc = "Configures the capabilities enabled in the Channel Sounding feature.\n\n Default: See sdc_cfg_cs_cfg_t."]
    pub cs_cfg: sdc_cfg_cs_cfg_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_cfg_t"][::core::mem::size_of::<sdc_cfg_t>() - 10usize];
    ["Alignment of sdc_cfg_t"][::core::mem::align_of::<sdc_cfg_t>() - 2usize];
    ["Offset of field: sdc_cfg_t::central_count"][::core::mem::offset_of!(sdc_cfg_t, central_count) - 0usize];
    ["Offset of field: sdc_cfg_t::peripheral_count"][::core::mem::offset_of!(sdc_cfg_t, peripheral_count) - 0usize];
    ["Offset of field: sdc_cfg_t::buffer_cfg"][::core::mem::offset_of!(sdc_cfg_t, buffer_cfg) - 0usize];
    ["Offset of field: sdc_cfg_t::adv_count"][::core::mem::offset_of!(sdc_cfg_t, adv_count) - 0usize];
    ["Offset of field: sdc_cfg_t::scan_buffer_cfg"][::core::mem::offset_of!(sdc_cfg_t, scan_buffer_cfg) - 0usize];
    ["Offset of field: sdc_cfg_t::adv_buffer_cfg"][::core::mem::offset_of!(sdc_cfg_t, adv_buffer_cfg) - 0usize];
    ["Offset of field: sdc_cfg_t::fal_size"][::core::mem::offset_of!(sdc_cfg_t, fal_size) - 0usize];
    ["Offset of field: sdc_cfg_t::periodic_adv_count"][::core::mem::offset_of!(sdc_cfg_t, periodic_adv_count) - 0usize];
    ["Offset of field: sdc_cfg_t::periodic_sync_count"]
        [::core::mem::offset_of!(sdc_cfg_t, periodic_sync_count) - 0usize];
    ["Offset of field: sdc_cfg_t::periodic_sync_buffer_cfg"]
        [::core::mem::offset_of!(sdc_cfg_t, periodic_sync_buffer_cfg) - 0usize];
    ["Offset of field: sdc_cfg_t::periodic_adv_list_size"]
        [::core::mem::offset_of!(sdc_cfg_t, periodic_adv_list_size) - 0usize];
    ["Offset of field: sdc_cfg_t::periodic_adv_rsp_count"]
        [::core::mem::offset_of!(sdc_cfg_t, periodic_adv_rsp_count) - 0usize];
    ["Offset of field: sdc_cfg_t::periodic_adv_rsp_buffer_cfg"]
        [::core::mem::offset_of!(sdc_cfg_t, periodic_adv_rsp_buffer_cfg) - 0usize];
    ["Offset of field: sdc_cfg_t::periodic_adv_rsp_failure_reporting_cfg"]
        [::core::mem::offset_of!(sdc_cfg_t, periodic_adv_rsp_failure_reporting_cfg) - 0usize];
    ["Offset of field: sdc_cfg_t::periodic_sync_rsp_tx_buffer_cfg"]
        [::core::mem::offset_of!(sdc_cfg_t, periodic_sync_rsp_tx_buffer_cfg) - 0usize];
    ["Offset of field: sdc_cfg_t::cig_count"][::core::mem::offset_of!(sdc_cfg_t, cig_count) - 0usize];
    ["Offset of field: sdc_cfg_t::cis_count"][::core::mem::offset_of!(sdc_cfg_t, cis_count) - 0usize];
    ["Offset of field: sdc_cfg_t::big_count"][::core::mem::offset_of!(sdc_cfg_t, big_count) - 0usize];
    ["Offset of field: sdc_cfg_t::bis_sink_count"][::core::mem::offset_of!(sdc_cfg_t, bis_sink_count) - 0usize];
    ["Offset of field: sdc_cfg_t::bis_source_count"][::core::mem::offset_of!(sdc_cfg_t, bis_source_count) - 0usize];
    ["Offset of field: sdc_cfg_t::iso_buffer_cfg"][::core::mem::offset_of!(sdc_cfg_t, iso_buffer_cfg) - 0usize];
    ["Offset of field: sdc_cfg_t::cs_count"][::core::mem::offset_of!(sdc_cfg_t, cs_count) - 0usize];
    ["Offset of field: sdc_cfg_t::cs_cfg"][::core::mem::offset_of!(sdc_cfg_t, cs_cfg) - 0usize];
};
unsafe extern "C" {
    #[doc = "Initialize the SoftDevice Controller\n\n After this function is called, the application may use SoC APIs.\n\n # Arguments\n\n* `[in]` -fault_handler The fault handler will be executed when there is an\n internal error in the SoftDevice Controller.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EINVAL` - Invalid argument provided\n * `-NRF_EPERM` - Unable to initialize because\n - MPSL is not initialized\n - MPSL needs to be configured with a LFCLK accuracy\n of 500 ppm or better."]
    pub fn sdc_init(fault_handler: sdc_fault_handler_t) -> i32;
}
unsafe extern "C" {
    #[doc = "Change or add a SoftDevice Controller configuration\n\n To change the default configuration, update SDC_DEFAULT_RESOURCE_CFG_TAG. To create or update a new\n configuration, provide another resource_cfg_tag.\n\n > **Note:** The application can set config_type to SDC_CFG_TYPE_NONE to obtain the required memory size for the\n current configuration in bytes.\n\n > **Note:** Resource configuration can only be performed prior to calling sdc_enable(). However, the current configuration may be\n changed after enabling the SoftDevice Controller.\n\n # Arguments\n\n* `[in]` -config_tag Configuration tag.\n * `[in]` -config_type Configuration type. See also sdc_cfg_type.\n * `[in]` -p_resource_cfg Configuration to be changed.\n\n # Returns\n\nRequired memory size for the current configuration in bytes.\n * `-NRF_EOPNOTSUPP` - Unsupported configuration.\n * `-NRF_ENOMEM` - Configuration required over 64 kB of RAM that is\nnot supported currently.\n * `-NRF_EINVAL` - Invalid argument provided.\n * `-NRF_EPERM` - This API was called after sdc_enable()."]
    pub fn sdc_cfg_set(config_tag: u8, config_type: u8, p_resource_cfg: *const sdc_cfg_t) -> i32;
}
unsafe extern "C" {
    #[doc = "Enable the SoftDevice Controller\n\n After this function is called, the application may utilize HCI APIs.\n\n # Arguments\n\n* `[in]` -callback The callback will be executed when HCI data or and HCI\n event is available. The callback will be executed in\n the same context as mpsl_low_priority_process.\n See also sdc_hci_get().\n * `[in]` -p_mem Provide memory for the current resource configuration.\n To obtain the required memory size, use the value\n returned from sdc_cfg_set().\n The pointer must be 8 bytes aligned.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EINVAL` - Invalid argument provided\n * `-NRF_EPERM` - The entropy source is not configured. Call sdc_rand_source_register() first."]
    pub fn sdc_enable(callback: sdc_callback_t, p_mem: *mut u8) -> i32;
}
unsafe extern "C" {
    #[doc = "Disable the SoftDevice Controller\n\n This call is synchronous. After the SoftDevice Controller is disabled, Bluetooth LE\n functionality is no longer available.\n\n # Returns\n\n* `0` - Success"]
    pub fn sdc_disable() -> i32;
}
unsafe extern "C" {
    #[doc = "Obtain build revision string\n\n The application must provide a buffer that is at least SDC_BUILD_REVISION_SIZE\n bytes long. The SoftDevice Controller will copy the build revision string to the provided buffer.\n\n # Arguments\n\n* `[in,out]` -p_build_revision Build revision.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EINVAL` - Invalid argument provided"]
    pub fn sdc_build_revision_get(p_build_revision: *mut u8) -> i32;
}
unsafe extern "C" {
    #[doc = "Support Advertising State\n\n After this API is called, the controller will support the HCI commands\n and events related to the Advertising State.\n Only non-connectable advertising is supported. To support connectable\n advertising, call sdc_support_peripheral().\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - Advertising state is not supported."]
    pub fn sdc_support_adv() -> i32;
}
unsafe extern "C" {
    #[doc = "Support extended advertising\n\n After this API is called, the controller will support the HCI commands\n and events related to both legacy and extended advertising.\n\n To reduce the size of the final linked image, the application should\n call either sdc_support_adv() or sdc_support_ext_adv().\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - Extended advertising state is not supported."]
    pub fn sdc_support_ext_adv() -> i32;
}
unsafe extern "C" {
    #[doc = "Support Peripheral role\n\n After this API is called, the controller will support the HCI commands\n and events related to the peripheral role.\n\n The application shall call either sdc_support_adv() or\n sdc_support_ext_adv() to be able to support connection\n establishment.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - Peripheral role is not supported."]
    pub fn sdc_support_peripheral() -> i32;
}
unsafe extern "C" {
    #[doc = "Support Scanning state\n\n After this API is called, the controller will support the HCI commands\n and events related to the scanning state.\n\n To reduce the size of the final linked image, the application should\n not call both sdc_support_scan() and sdc_support_ext_scan().\n\n This API shall not be called together with\n sdc_support_central() or sdc_support_ext_central().\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - Scanning state is not supported."]
    pub fn sdc_support_scan() -> i32;
}
unsafe extern "C" {
    #[doc = "Support scanning for extended advertising PDUs\n\n After this API is called, the controller will support the HCI commands\n and events related to both legacy and extended scanning.\n\n To reduce the size of the final linked image, the application should\n not call both sdc_support_scan() and sdc_support_ext_scan().\n\n This API shall not be called together with\n sdc_support_central() or sdc_support_ext_central().\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - Extended scanning state is not supported."]
    pub fn sdc_support_ext_scan() -> i32;
}
unsafe extern "C" {
    #[doc = "Support Scanner, Initiator, and Central role\n\n After this API is called, the controller will support the HCI commands\n and events related to the scanner, initiator, and central role.\n\n To reduce the size of the final linked image, the application should\n not call both sdc_support_central() and sdc_support_ext_central().\n\n This API shall not be called together with\n sdc_support_scan() or sdc_support_ext_scan().\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - These features are not supported."]
    pub fn sdc_support_central() -> i32;
}
unsafe extern "C" {
    #[doc = "Support Extended Scanner, Extended Initiator, and Central role\n\n After this API is called, the controller will support the HCI commands\n and events related to the extended scanner, initiator, and central role.\n\n To reduce the size of the final linked image, the application should\n not call both sdc_support_central() and sdc_support_ext_central().\n\n This API shall not be called together with\n sdc_support_scan() or sdc_support_ext_scan().\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - These features are not supported."]
    pub fn sdc_support_ext_central() -> i32;
}
unsafe extern "C" {
    #[doc = "Support for scanning and initiating at the same time.\n\n After this API is called, the controller will support:\n - Creating a connection while passive or active scanning is enabled\n - Enabling passive or active scanning while a connection attempt is ongoing\n\n This API should be called only when centrals are supported (the application should\n call either sdc_support_central() or sdc_support_ext_central()).\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - Scanning and initiating in parallel is not supported."]
    pub fn sdc_support_parallel_scanning_and_initiating() -> i32;
}
unsafe extern "C" {
    #[doc = "Support LE Power Class 1\n\n After this API is called, the controller will include LE Power Class 1 in the supported features.\n\n > **Note:** The controller only adds this feature bit, the user will have to know whether this is required.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable()."]
    pub fn sdc_support_le_power_class_1() -> i32;
}
unsafe extern "C" {
    #[doc = "Support Data Length Extensions for a central device\n\n After this API is called, the controller will support data length extension in the central role.\n That is:\n - DLE is marked supported in the LL Feature Exchange procedure.\n - All DLE HCI APIs are supported. The controller replies with LL_LENGTH_RSP\n when a LL_LENGTH_REQ is received.\n\n > **Note:** The application is required to call both sdc_support_dle_central() and sdc_support_dle_peripheral()\n if both central and peripheral roles are supported.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - Data Length Extension or Central Role is not supported."]
    pub fn sdc_support_dle_central() -> i32;
}
unsafe extern "C" {
    #[doc = "Support Data Length Extensions for a peripheral device\n\n After this API is called, the controller will support data length extension in the peripheral role.\n That is:\n - DLE is marked supported in the LL Feature Exchange procedure.\n - All DLE HCI APIs are supported. The controller replies with LL_LENGTH_RSP\n when a LL_LENGTH_REQ is received.\n\n > **Note:** The application is required to call both sdc_support_dle_central() and sdc_support_dle_peripheral()\n if both central and peripheral roles are supported.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - Data Length Extension or Peripheral Role is not supported."]
    pub fn sdc_support_dle_peripheral() -> i32;
}
unsafe extern "C" {
    #[doc = "Support LE 2M PHY\n\n After this API is called, the controller will support LE 2M PHY. That is:\n - The controller can use 2M PHY in both the connected and non-connected state.\n - LE 2M PHY is marked supported in the LL Feature Exchange procedure.\n\n > **Note:** The application is required to call sdc_support_phy_update_central() and/or sdc_support_phy_update_peripheral()\n to enable the PHY update procedure.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable()."]
    pub fn sdc_support_le_2m_phy() -> i32;
}
unsafe extern "C" {
    #[doc = "Support LE Coded PHY\n\n After this API is called, the controller will support LE Coded PHY. That is:\n - The controller can use LE Coded PHY in both the connected and non-connected state.\n - LE Coded PHY is marked supported in the LL Feature Exchange procedure.\n\n > **Note:** The application is required to call sdc_support_phy_update_central() and/or sdc_support_phy_update_peripheral()\n to enable the PHY update procedure.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - LE Coded PHY is not supported."]
    pub fn sdc_support_le_coded_phy() -> i32;
}
unsafe extern "C" {
    #[doc = "Support PHY Update Procedure for central role\n\n After this API is called, the controller will support PHY update procedure in central role. That is:\n - All HCI APIs for obtaining or changing PHYs are supported for central role.\n\n > **Note:** The application is required to call both sdc_support_phy_update_central() and sdc_support_phy_update_peripheral()\n if both central and peripheral roles are supported.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - LE Coded PHY is not supported."]
    pub fn sdc_support_phy_update_central() -> i32;
}
unsafe extern "C" {
    #[doc = "Support LE Coded PHY for peripheral role\n\n After this API is called, the controller will support PHY update procedure in peripheral role. That is:\n - All HCI APIs for obtaining or changing PHYs are supported for peripheral role.\n\n > **Note:** The application is required to call both sdc_support_phy_update_central() and sdc_support_phy_update_peripheral()\n if both central and peripheral roles are supported.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - LE Coded PHY is not supported."]
    pub fn sdc_support_phy_update_peripheral() -> i32;
}
unsafe extern "C" {
    #[doc = "Support LE Periodic Advertising in the Advertising state\n\n After this API is called, the controller will support the HCI commands\n related to the Periodic Advertising State.\n\n The application shall also call sdc_support_ext_adv() to enable\n support for extended advertising before enabling support for periodic advertising.\n\n > **Note:** This API also enables support for ADI in periodic advertising packets.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - LE Periodic advertising is not supported."]
    pub fn sdc_support_le_periodic_adv() -> i32;
}
unsafe extern "C" {
    #[doc = "Support LE Periodic Advertising in the Synchronization state\n\n After this API is called, the controller will support the HCI commands\n related to the Synchronization State.\n\n The application shall also call sdc_support_ext_scan() to enable\n support for scanning for periodic advertisers before enabling support for\n this feature.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - LE Periodic advertising is not supported."]
    pub fn sdc_support_le_periodic_sync() -> i32;
}
unsafe extern "C" {
    #[doc = "Support LE Periodic Advertising with Responses in the Advertising state\n\n After this API is called, the controller will support the HCI commands\n related to Periodic Advertising with Responses.\n\n The application shall also call sdc_support_ext_adv(), sdc_support_le_periodic_adv(),\n and at least one of sdc_support_periodic_adv_sync_transfer_sender_central()\n and sdc_support_periodic_adv_sync_transfer_sender_peripheral()\n to enable support for the extended advertising, periodic advertising,\n and sync transfer sender features before enabling support for\n Periodic Advertising with Responses.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - LE Periodic Advertising with Responses is not supported."]
    pub fn sdc_support_le_periodic_adv_with_rsp() -> i32;
}
unsafe extern "C" {
    #[doc = "Support LE Periodic Advertising with Responses in the Synchronization state\n\n After this API is called, the controller will support the HCI commands\n related to Periodic Sync with Responses.\n\n The application shall also call sdc_support_ext_adv(), sdc_support_le_periodic_sync(),\n and at least one of sdc_support_periodic_adv_sync_transfer_receiver_central and\n sdc_support_periodic_adv_sync_transfer_receiver_peripheral to enable support for extended\n advertising, periodic advertising, and the sync transfer receiver features before enabling\n support for Periodic Sync with Responses.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - LE Periodic Sync with Responses is not supported."]
    pub fn sdc_support_le_periodic_sync_with_rsp() -> i32;
}
unsafe extern "C" {
    #[doc = "Support LE Power Control for central role\n\n After this API is called, the controller will support the HCI commands\n related to LE Power Control.\n\n > **Note:** The application is required to call both sdc_support_le_power_control_central() and sdc_support_le_power_control_peripheral()\n if both central and peripheral roles are supported.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - LE Power Control is not supported."]
    pub fn sdc_support_le_power_control_central() -> i32;
}
unsafe extern "C" {
    #[doc = "Support LE Power Control for peripheral role\n\n After this API is called, the controller will support the HCI commands\n related to LE Power Control.\n\n > **Note:** The application is required to call both sdc_support_le_power_control_central() and sdc_support_le_power_control_peripheral()\n if both central and peripheral roles are supported.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - LE Power Control is not supported."]
    pub fn sdc_support_le_power_control_peripheral() -> i32;
}
unsafe extern "C" {
    #[doc = "Support LE Path Loss Monitoring\n\n After this API is called, the controller will support the HCI commands\n related to LE Path Loss Monitoring.\n\n > **Note:** The application is required to call at least one of sdc_support_le_power_control_central()\n and sdc_support_le_power_control_peripheral() before enabling support for LE Path Loss Monitoring.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - LE Path Loss Monitoring is not supported."]
    pub fn sdc_support_le_path_loss_monitoring() -> i32;
}
unsafe extern "C" {
    #[doc = "Support Sleep Clock Accuracy (SCA) Update procedure for central role\n\n > **Note:** The application is required to call both sdc_support_sca_central() and sdc_support_sca_peripheral()\n if both central and peripheral roles are supported.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - SCA Update procedure is not supported."]
    pub fn sdc_support_sca_central() -> i32;
}
unsafe extern "C" {
    #[doc = "Support Sleep Clock Accuracy (SCA) Update procedure for peripheral role\n\n > **Note:** The application is required to call both sdc_support_sca_central() and sdc_support_sca_peripheral()\n if both central and peripheral roles are supported.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - SCA Update procedure is not supported."]
    pub fn sdc_support_sca_peripheral() -> i32;
}
unsafe extern "C" {
    #[doc = "Support LE Connection CTE response for central role\n\n After this API is called, the controller will support the HCI commands\n related to the LE Connection CTE Response.\n\n > **Note:** The application is required to call both sdc_support_le_conn_cte_rsp_central() and sdc_support_le_conn_cte_rsp_peripheral()\n if both central and peripheral roles are supported.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - LE Connection CTE Response is not supported."]
    pub fn sdc_support_le_conn_cte_rsp_central() -> i32;
}
unsafe extern "C" {
    #[doc = "Support LE Connection CTE response for peripheral role\n\n After this API is called, the controller will support the HCI commands\n related to the LE Connection CTE Response.\n\n > **Note:** The application is required to call both sdc_support_le_conn_cte_rsp_central() and sdc_support_le_conn_cte_rsp_peripheral()\n if both central and peripheral roles are supported.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - LE Connection CTE Response is not supported."]
    pub fn sdc_support_le_conn_cte_rsp_peripheral() -> i32;
}
unsafe extern "C" {
    #[doc = "Support for sending periodic advertising sync transfers as central role\n\n > **Note:** The application is required to call both sdc_support_periodic_adv_sync_transfer_sender_central()\n and sdc_support_periodic_adv_sync_transfer_sender_peripheral() if both central and peripheral roles are supported.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - Sending periodic advertising sync transfers is not supported."]
    pub fn sdc_support_periodic_adv_sync_transfer_sender_central() -> i32;
}
unsafe extern "C" {
    #[doc = "Support for sending periodic advertising sync transfers as peripheral role\n\n > **Note:** The application is required to call both sdc_support_periodic_adv_sync_transfer_sender_central()\n and sdc_support_periodic_adv_sync_transfer_sender_peripheral() if both central and peripheral roles are supported.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - Sending periodic advertising sync transfers is not supported."]
    pub fn sdc_support_periodic_adv_sync_transfer_sender_peripheral() -> i32;
}
unsafe extern "C" {
    #[doc = "Support for receiving periodic advertising sync transfers as central role\n\n > **Note:** The application is required to call both sdc_support_periodic_adv_sync_transfer_receiver_central()\n and sdc_support_periodic_adv_sync_transfer_receiver_peripheral() if both central and peripheral roles are supported.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - Receiving periodic advertising sync transfers is not supported."]
    pub fn sdc_support_periodic_adv_sync_transfer_receiver_central() -> i32;
}
unsafe extern "C" {
    #[doc = "Support for receiving periodic advertising sync transfers as peripheral role\n\n > **Note:** The application is required to call both sdc_support_periodic_adv_sync_transfer_receiver_central()\n and sdc_support_periodic_adv_sync_transfer_receiver_peripheral() if both central and peripheral roles are supported.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - Receiving periodic advertising sync transfers is not supported."]
    pub fn sdc_support_periodic_adv_sync_transfer_receiver_peripheral() -> i32;
}
unsafe extern "C" {
    #[doc = "Support Connected Isochronous streams in the peripheral role\n\n After this API is called, the controller will support the HCI commands\n related to Connected Isochronous channels in the peripheral role\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - Connected Isochronous streams in the peripheral role is not supported."]
    pub fn sdc_support_cis_peripheral() -> i32;
}
unsafe extern "C" {
    #[doc = "Support Connected Isochronous streams in the central role\n\n After this API is called, the controller will support the HCI commands\n related to Connected Isochronous channels in the central role\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - Connected Isochronous streams in the central role is not supported."]
    pub fn sdc_support_cis_central() -> i32;
}
unsafe extern "C" {
    #[doc = "Support Broadcast Isochronous streams as a source\n\n After this API is called, the controller will support the HCI commands\n related to Broadcast Isochronous channels as a source\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - Broadcast Isochronous streams as a source is not supported."]
    pub fn sdc_support_bis_source() -> i32;
}
unsafe extern "C" {
    #[doc = "Support Broadcast Isochronous streams as a sink\n\n After this API is called, the controller will support the HCI commands\n related to Broadcast Isochronous channels as a sink\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - Broadcast Isochronous streams as a sink is not supported."]
    pub fn sdc_support_bis_sink() -> i32;
}
unsafe extern "C" {
    #[doc = "Configure the controller to ignore HCI ISO data timestamps from the host\n\n The controller requires that timestamps coming from the host/application are based on the controller's clock.\n This option can instruct the controller to ignore the timestamps, if the host sends timestamps that are not based on the controller's clock.\n\n # Arguments\n\n* `ignore` - indicates if timestamps in HCI ISO data packets from the host should be ignored.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EOPNOTSUPP` - Broadcast Isochronous streams as source and Connected Isochronous Channels are not supported."]
    pub fn sdc_iso_host_timestamps_ignore(ignore: bool) -> i32;
}
unsafe extern "C" {
    #[doc = "Support for Quality of Service (QoS) channel survey module\n\n After this API is called, the controller will support the sdc_hci_cmd_vs_qos_channel_survey_enable HCI command\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - QoS channel survey is not supported."]
    pub fn sdc_support_qos_channel_survey() -> i32;
}
unsafe extern "C" {
    #[doc = "Support for setting the default radio TX power level\n\n This API sets the default power level for radio TX activity in the controller.\n\n The power level set will be equal to or less than the one requested, based on the values\n supported by the hardware used. Values outside the suported range will be set to the nearest\n supported value.\n\n `requested_power_level` represents the actual power level fed to the antenna.\n When a Front-End Module is used, gain values for the SoC and FEM are calculated\n automatically to guarantee the closest possible match to the value requested by the user\n at the RF output.\n\n # Arguments\n\n* `[in]` -requested_power_level The power level in dBm to use.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_enable()."]
    pub fn sdc_default_tx_power_set(requested_power_level: i8) -> i32;
}
unsafe extern "C" {
    #[doc = "Support Connection Subrating for central role\n\n After this API is called, the controller will support the HCI commands\n related to Connection Subrating.\n\n > **Note:** The application is required to call both sdc_support_connection_subrating_central() and sdc_support_connection_subrating_peripheral()\n if both central and peripheral roles are supported.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - Connection Subrating is not supported."]
    pub fn sdc_support_connection_subrating_central() -> i32;
}
unsafe extern "C" {
    #[doc = "Support Connection Subrating for peripheral role\n\n After this API is called, the controller will support the HCI commands\n related to Connection Subrating.\n\n > **Note:** The application is required to call both sdc_support_connection_subrating_central() and sdc_support_connection_subrating_peripheral()\n if both central and peripheral roles are supported.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - Connection Subrating is not supported."]
    pub fn sdc_support_connection_subrating_peripheral() -> i32;
}
unsafe extern "C" {
    #[doc = "Support Channel Sounding test command\n\n After this API is called, the controller will support the HCI command\n HCI LE Channel Sounding Test\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - Channel Sounding Test is not supported"]
    pub fn sdc_support_channel_sounding_test() -> i32;
}
unsafe extern "C" {
    #[doc = "Support Channel Sounding Step Mode 3\n\n After this API is called, the controller will support Channel Sounding Step Mode 3\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - Channel Sounding is not supported"]
    pub fn sdc_support_channel_sounding_mode3() -> i32;
}
unsafe extern "C" {
    #[doc = "Support Channel Sounding Initiator role\n\n After this API is called, the controller will support Channel Sounding Initiator role\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - Channel Sounding is not supported"]
    pub fn sdc_support_channel_sounding_initiator_role() -> i32;
}
unsafe extern "C" {
    #[doc = "Support Channel Sounding Reflector role\n\n After this API is called, the controller will support Channel Sounding Reflector role\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - Channel Sounding is not supported"]
    pub fn sdc_support_channel_sounding_reflector_role() -> i32;
}
unsafe extern "C" {
    #[doc = "Support LE Channel Sounding\n\n After this API is called, the controller will support the HCI commands\n related to Channel Sounding.\n\n The application shall call sdc_support_channel_sounding_test() to enable\n support for Channel Sounding test command.\n\n # Arguments\n\n* `[in]` -antenna_switch_cb Antenna Switching callback used to control an antennna switch\n in the case of a multiantenna application. May be NULL if no\n antenna switching is needed. See\n sdc_cfg_cs_cfg_t::num_antennas_supported.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EPERM` - This API must be called before sdc_cfg_set() or sdc_enable().\n * `-NRF_EOPNOTSUPP` - Channel Sounding is not supported"]
    pub fn sdc_support_channel_sounding(antenna_switch_cb: sdc_cs_antenna_switch_callback_t) -> i32;
}
pub const SDC_HCI_MSG_TYPE_NONE: sdc_hci_msg_type_t = 0;
pub const SDC_HCI_MSG_TYPE_DATA: sdc_hci_msg_type_t = 2;
pub const SDC_HCI_MSG_TYPE_EVT: sdc_hci_msg_type_t = 4;
pub const SDC_HCI_MSG_TYPE_ISO: sdc_hci_msg_type_t = 8;
pub type sdc_hci_msg_type_t = ::core::ffi::c_uint;
unsafe extern "C" {
    #[doc = "Send an HCI data packet to the SoftDevice Controller.\n\n # Arguments\n\n* `[in]` -p_data_in HCI Data packet. The first byte in the buffer should correspond to\n Handle, as specified by the Bluetooth Core Specification.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EINVAL` - Invalid input"]
    pub fn sdc_hci_data_put(p_data_in: *const u8) -> i32;
}
unsafe extern "C" {
    #[doc = "Send an HCI ISO data packet to the SoftDevice Controller.\n\n If an error is returned, the HCI ISO data packet is dropped by the SoftDevice Controller and will not be\n further processed.\n\n # Arguments\n\n* `[in]` -p_data_in HCI Data packet. The first byte in the buffer should correspond to\n Handle, as specified by the Bluetooth Core Specification.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EINVAL` - Invalid input\n * `-NRF_EPERM` - There is no data-path for the selected Handle\n * `-NRF_EAGAIN` - The data is provided too late\n * `-NRF_EFAULT` - Failure during processing of the data"]
    pub fn sdc_hci_iso_data_put(p_data_in: *const u8) -> i32;
}
unsafe extern "C" {
    #[doc = "Retrieve an HCI packet from the SoftDevice Controller.\n\n This API is non-blocking.\n\n > **Note:** The application should ensure that the size of the provided buffer is at least\n HCI_MSG_BUFFER_MAX_SIZE bytes.\n For Isochronous Channels the provided buffer should be large enough to contain the maximum supported SDU size.\n See also sdc_cfg_iso_buffer_cfg_t::rx_sdu_buffer_size and HCI_ISO_DATA_PACKET_MAX_SIZE.\n\n # Arguments\n\n* `[in,out]` -p_packet_out Buffer where the HCI packet will be stored.\n If an event is retrieved, the first byte corresponds to the Event Code.\n If a data packet is retrieved, the first byte corresponds to the Handle.\n * `[out]` -p_msg_type_out Type of HCI packet produced by the controller.\n See sdc_hci_msg_type_t for possible values.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EAGAIN` - No event available\n * `-NRF_EINVAL` - Invalid input"]
    pub fn sdc_hci_get(p_packet_out: *mut u8, p_msg_type_out: *mut u8) -> i32;
}
#[doc = "See sdc_hci_cmd_cb_set_event_mask()."]
pub const SDC_HCI_OPCODE_CMD_CB_SET_EVENT_MASK: sdc_hci_opcode_cb = 3073;
#[doc = "See sdc_hci_cmd_cb_reset()."]
pub const SDC_HCI_OPCODE_CMD_CB_RESET: sdc_hci_opcode_cb = 3075;
#[doc = "See sdc_hci_cmd_cb_read_conn_accept_timeout()."]
pub const SDC_HCI_OPCODE_CMD_CB_READ_CONN_ACCEPT_TIMEOUT: sdc_hci_opcode_cb = 3093;
#[doc = "See sdc_hci_cmd_cb_write_conn_accept_timeout()."]
pub const SDC_HCI_OPCODE_CMD_CB_WRITE_CONN_ACCEPT_TIMEOUT: sdc_hci_opcode_cb = 3094;
#[doc = "See sdc_hci_cmd_cb_read_transmit_power_level()."]
pub const SDC_HCI_OPCODE_CMD_CB_READ_TRANSMIT_POWER_LEVEL: sdc_hci_opcode_cb = 3117;
#[doc = "See sdc_hci_cmd_cb_set_controller_to_host_flow_control()."]
pub const SDC_HCI_OPCODE_CMD_CB_SET_CONTROLLER_TO_HOST_FLOW_CONTROL: sdc_hci_opcode_cb = 3121;
#[doc = "See sdc_hci_cmd_cb_host_buffer_size()."]
pub const SDC_HCI_OPCODE_CMD_CB_HOST_BUFFER_SIZE: sdc_hci_opcode_cb = 3123;
#[doc = "See sdc_hci_cmd_cb_host_number_of_completed_packets()."]
pub const SDC_HCI_OPCODE_CMD_CB_HOST_NUMBER_OF_COMPLETED_PACKETS: sdc_hci_opcode_cb = 3125;
#[doc = "See sdc_hci_cmd_cb_set_event_mask_page_2()."]
pub const SDC_HCI_OPCODE_CMD_CB_SET_EVENT_MASK_PAGE_2: sdc_hci_opcode_cb = 3171;
#[doc = "See sdc_hci_cmd_cb_read_authenticated_payload_timeout()."]
pub const SDC_HCI_OPCODE_CMD_CB_READ_AUTHENTICATED_PAYLOAD_TIMEOUT: sdc_hci_opcode_cb = 3195;
#[doc = "See sdc_hci_cmd_cb_write_authenticated_payload_timeout()."]
pub const SDC_HCI_OPCODE_CMD_CB_WRITE_AUTHENTICATED_PAYLOAD_TIMEOUT: sdc_hci_opcode_cb = 3196;
#[doc = "HCI CB OpCode Field values."]
pub type sdc_hci_opcode_cb = ::core::ffi::c_uint;
#[doc = "Event Mask.\n\n If the bit in the Event_Mask is set to a one,\n then the event associated with that bit will be enabled."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cb_event_mask_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 7usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cb_event_mask_t"][::core::mem::size_of::<sdc_hci_cb_event_mask_t>() - 7usize];
    ["Alignment of sdc_hci_cb_event_mask_t"][::core::mem::align_of::<sdc_hci_cb_event_mask_t>() - 1usize];
};
impl sdc_hci_cb_event_mask_t {
    #[inline]
    pub fn inquiry_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_inquiry_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inquiry_complete_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_inquiry_complete_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn inquiry_result_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_inquiry_result_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inquiry_result_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_inquiry_result_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn connection_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_connection_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn connection_complete_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_connection_complete_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn connection_request_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_connection_request_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn connection_request_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_connection_request_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disconnection_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_disconnection_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disconnection_complete_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_disconnection_complete_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn authentication_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_authentication_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn authentication_complete_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_authentication_complete_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn remote_name_request_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_remote_name_request_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn remote_name_request_complete_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_remote_name_request_complete_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn encryption_change_event_v1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encryption_change_event_v1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn encryption_change_event_v1_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_encryption_change_event_v1_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn change_connection_link_key_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_change_connection_link_key_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn change_connection_link_key_complete_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_change_connection_link_key_complete_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn link_key_type_changed_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_link_key_type_changed_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn link_key_type_changed_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_link_key_type_changed_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn read_remote_supported_features_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_read_remote_supported_features_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn read_remote_supported_features_complete_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_read_remote_supported_features_complete_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn read_remote_version_information_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_read_remote_version_information_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn read_remote_version_information_complete_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_read_remote_version_information_complete_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn qos_setup_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_qos_setup_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn qos_setup_complete_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_qos_setup_complete_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hardware_error_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hardware_error_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hardware_error_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hardware_error_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flush_occurred_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_flush_occurred_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flush_occurred_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_flush_occurred_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn role_change_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_role_change_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn role_change_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_role_change_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mode_change_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mode_change_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mode_change_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mode_change_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn return_link_keys_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_return_link_keys_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn return_link_keys_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_return_link_keys_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pin_code_request_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pin_code_request_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pin_code_request_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_pin_code_request_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn link_key_request_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_link_key_request_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn link_key_request_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_link_key_request_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn link_key_notification_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_link_key_notification_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn link_key_notification_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_link_key_notification_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn loopback_command_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_loopback_command_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn loopback_command_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_loopback_command_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn data_buffer_overflow_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_data_buffer_overflow_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn data_buffer_overflow_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_data_buffer_overflow_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn max_slots_change_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_max_slots_change_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn max_slots_change_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_max_slots_change_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn read_clock_offset_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_read_clock_offset_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn read_clock_offset_complete_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_read_clock_offset_complete_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn connection_packet_type_changed_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_connection_packet_type_changed_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn connection_packet_type_changed_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                25usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_connection_packet_type_changed_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn qos_violation_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_qos_violation_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn qos_violation_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_qos_violation_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used30(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used30(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used30_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                27usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used30_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                27usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn page_scan_repetition_mode_change_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_page_scan_repetition_mode_change_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn page_scan_repetition_mode_change_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_page_scan_repetition_mode_change_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_specification_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_flow_specification_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_specification_complete_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                29usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_flow_specification_complete_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                29usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn inquiry_result_with_rssi_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_inquiry_result_with_rssi_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inquiry_result_with_rssi_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_inquiry_result_with_rssi_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn read_remote_extended_features_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_read_remote_extended_features_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn read_remote_extended_features_complete_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_read_remote_extended_features_complete_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn synchronous_connection_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_synchronous_connection_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn synchronous_connection_complete_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_synchronous_connection_complete_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn synchronous_connection_changed_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_synchronous_connection_changed_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn synchronous_connection_changed_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                33usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_synchronous_connection_changed_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                33usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sniff_subrating_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sniff_subrating_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sniff_subrating_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                34usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_sniff_subrating_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                34usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn extended_inquiry_result_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_extended_inquiry_result_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn extended_inquiry_result_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                35usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_extended_inquiry_result_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                35usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn encryption_key_refresh_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encryption_key_refresh_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn encryption_key_refresh_complete_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                36usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_encryption_key_refresh_complete_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                36usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn io_capability_request_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_io_capability_request_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn io_capability_request_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                37usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_io_capability_request_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                37usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn io_capability_response_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_io_capability_response_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn io_capability_response_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                38usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_io_capability_response_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                38usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn user_confirmation_request_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_user_confirmation_request_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn user_confirmation_request_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                39usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_user_confirmation_request_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                39usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn user_passkey_request_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(40usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_user_passkey_request_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(40usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn user_passkey_request_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                40usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_user_passkey_request_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                40usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn remote_oob_data_request_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(41usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_remote_oob_data_request_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn remote_oob_data_request_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                41usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_remote_oob_data_request_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                41usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn simple_pairing_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(42usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_simple_pairing_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(42usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn simple_pairing_complete_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                42usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_simple_pairing_complete_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                42usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn link_supervision_timeout_changed_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(43usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_link_supervision_timeout_changed_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(43usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn link_supervision_timeout_changed_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                43usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_link_supervision_timeout_changed_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                43usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enhanced_flush_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(44usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enhanced_flush_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(44usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enhanced_flush_complete_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                44usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_enhanced_flush_complete_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                44usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn user_passkey_notification_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(45usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_user_passkey_notification_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(45usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn user_passkey_notification_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                45usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_user_passkey_notification_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                45usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn keypress_notification_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(46usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_keypress_notification_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(46usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn keypress_notification_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                46usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_keypress_notification_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                46usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn remote_host_supported_features_notification_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(47usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_remote_host_supported_features_notification_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(47usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn remote_host_supported_features_notification_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                47usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_remote_host_supported_features_notification_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                47usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_meta_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(48usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_meta_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(48usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_meta_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                48usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_meta_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                48usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        inquiry_complete_event: u8,
        inquiry_result_event: u8,
        connection_complete_event: u8,
        connection_request_event: u8,
        disconnection_complete_event: u8,
        authentication_complete_event: u8,
        remote_name_request_complete_event: u8,
        encryption_change_event_v1: u8,
        change_connection_link_key_complete_event: u8,
        link_key_type_changed_event: u8,
        read_remote_supported_features_complete_event: u8,
        read_remote_version_information_complete_event: u8,
        qos_setup_complete_event: u8,
        hardware_error_event: u8,
        flush_occurred_event: u8,
        role_change_event: u8,
        mode_change_event: u8,
        return_link_keys_event: u8,
        pin_code_request_event: u8,
        link_key_request_event: u8,
        link_key_notification_event: u8,
        loopback_command_event: u8,
        data_buffer_overflow_event: u8,
        max_slots_change_event: u8,
        read_clock_offset_complete_event: u8,
        connection_packet_type_changed_event: u8,
        qos_violation_event: u8,
        previously_used30: u8,
        page_scan_repetition_mode_change_event: u8,
        flow_specification_complete_event: u8,
        inquiry_result_with_rssi_event: u8,
        read_remote_extended_features_complete_event: u8,
        synchronous_connection_complete_event: u8,
        synchronous_connection_changed_event: u8,
        sniff_subrating_event: u8,
        extended_inquiry_result_event: u8,
        encryption_key_refresh_complete_event: u8,
        io_capability_request_event: u8,
        io_capability_response_event: u8,
        user_confirmation_request_event: u8,
        user_passkey_request_event: u8,
        remote_oob_data_request_event: u8,
        simple_pairing_complete_event: u8,
        link_supervision_timeout_changed_event: u8,
        enhanced_flush_complete_event: u8,
        user_passkey_notification_event: u8,
        keypress_notification_event: u8,
        remote_host_supported_features_notification_event: u8,
        le_meta_event: u8,
    ) -> __BindgenBitfieldUnit<[u8; 7usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 7usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let inquiry_complete_event: u8 = unsafe { ::core::mem::transmute(inquiry_complete_event) };
            inquiry_complete_event as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let inquiry_result_event: u8 = unsafe { ::core::mem::transmute(inquiry_result_event) };
            inquiry_result_event as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let connection_complete_event: u8 = unsafe { ::core::mem::transmute(connection_complete_event) };
            connection_complete_event as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let connection_request_event: u8 = unsafe { ::core::mem::transmute(connection_request_event) };
            connection_request_event as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let disconnection_complete_event: u8 = unsafe { ::core::mem::transmute(disconnection_complete_event) };
            disconnection_complete_event as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let authentication_complete_event: u8 = unsafe { ::core::mem::transmute(authentication_complete_event) };
            authentication_complete_event as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let remote_name_request_complete_event: u8 =
                unsafe { ::core::mem::transmute(remote_name_request_complete_event) };
            remote_name_request_complete_event as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let encryption_change_event_v1: u8 = unsafe { ::core::mem::transmute(encryption_change_event_v1) };
            encryption_change_event_v1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let change_connection_link_key_complete_event: u8 =
                unsafe { ::core::mem::transmute(change_connection_link_key_complete_event) };
            change_connection_link_key_complete_event as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let link_key_type_changed_event: u8 = unsafe { ::core::mem::transmute(link_key_type_changed_event) };
            link_key_type_changed_event as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let read_remote_supported_features_complete_event: u8 =
                unsafe { ::core::mem::transmute(read_remote_supported_features_complete_event) };
            read_remote_supported_features_complete_event as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let read_remote_version_information_complete_event: u8 =
                unsafe { ::core::mem::transmute(read_remote_version_information_complete_event) };
            read_remote_version_information_complete_event as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let qos_setup_complete_event: u8 = unsafe { ::core::mem::transmute(qos_setup_complete_event) };
            qos_setup_complete_event as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let hardware_error_event: u8 = unsafe { ::core::mem::transmute(hardware_error_event) };
            hardware_error_event as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let flush_occurred_event: u8 = unsafe { ::core::mem::transmute(flush_occurred_event) };
            flush_occurred_event as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let role_change_event: u8 = unsafe { ::core::mem::transmute(role_change_event) };
            role_change_event as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let mode_change_event: u8 = unsafe { ::core::mem::transmute(mode_change_event) };
            mode_change_event as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let return_link_keys_event: u8 = unsafe { ::core::mem::transmute(return_link_keys_event) };
            return_link_keys_event as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let pin_code_request_event: u8 = unsafe { ::core::mem::transmute(pin_code_request_event) };
            pin_code_request_event as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let link_key_request_event: u8 = unsafe { ::core::mem::transmute(link_key_request_event) };
            link_key_request_event as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let link_key_notification_event: u8 = unsafe { ::core::mem::transmute(link_key_notification_event) };
            link_key_notification_event as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let loopback_command_event: u8 = unsafe { ::core::mem::transmute(loopback_command_event) };
            loopback_command_event as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let data_buffer_overflow_event: u8 = unsafe { ::core::mem::transmute(data_buffer_overflow_event) };
            data_buffer_overflow_event as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let max_slots_change_event: u8 = unsafe { ::core::mem::transmute(max_slots_change_event) };
            max_slots_change_event as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let read_clock_offset_complete_event: u8 =
                unsafe { ::core::mem::transmute(read_clock_offset_complete_event) };
            read_clock_offset_complete_event as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let connection_packet_type_changed_event: u8 =
                unsafe { ::core::mem::transmute(connection_packet_type_changed_event) };
            connection_packet_type_changed_event as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let qos_violation_event: u8 = unsafe { ::core::mem::transmute(qos_violation_event) };
            qos_violation_event as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let previously_used30: u8 = unsafe { ::core::mem::transmute(previously_used30) };
            previously_used30 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let page_scan_repetition_mode_change_event: u8 =
                unsafe { ::core::mem::transmute(page_scan_repetition_mode_change_event) };
            page_scan_repetition_mode_change_event as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let flow_specification_complete_event: u8 =
                unsafe { ::core::mem::transmute(flow_specification_complete_event) };
            flow_specification_complete_event as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let inquiry_result_with_rssi_event: u8 = unsafe { ::core::mem::transmute(inquiry_result_with_rssi_event) };
            inquiry_result_with_rssi_event as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let read_remote_extended_features_complete_event: u8 =
                unsafe { ::core::mem::transmute(read_remote_extended_features_complete_event) };
            read_remote_extended_features_complete_event as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let synchronous_connection_complete_event: u8 =
                unsafe { ::core::mem::transmute(synchronous_connection_complete_event) };
            synchronous_connection_complete_event as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let synchronous_connection_changed_event: u8 =
                unsafe { ::core::mem::transmute(synchronous_connection_changed_event) };
            synchronous_connection_changed_event as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let sniff_subrating_event: u8 = unsafe { ::core::mem::transmute(sniff_subrating_event) };
            sniff_subrating_event as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let extended_inquiry_result_event: u8 = unsafe { ::core::mem::transmute(extended_inquiry_result_event) };
            extended_inquiry_result_event as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let encryption_key_refresh_complete_event: u8 =
                unsafe { ::core::mem::transmute(encryption_key_refresh_complete_event) };
            encryption_key_refresh_complete_event as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let io_capability_request_event: u8 = unsafe { ::core::mem::transmute(io_capability_request_event) };
            io_capability_request_event as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let io_capability_response_event: u8 = unsafe { ::core::mem::transmute(io_capability_response_event) };
            io_capability_response_event as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let user_confirmation_request_event: u8 =
                unsafe { ::core::mem::transmute(user_confirmation_request_event) };
            user_confirmation_request_event as u64
        });
        __bindgen_bitfield_unit.set(40usize, 1u8, {
            let user_passkey_request_event: u8 = unsafe { ::core::mem::transmute(user_passkey_request_event) };
            user_passkey_request_event as u64
        });
        __bindgen_bitfield_unit.set(41usize, 1u8, {
            let remote_oob_data_request_event: u8 = unsafe { ::core::mem::transmute(remote_oob_data_request_event) };
            remote_oob_data_request_event as u64
        });
        __bindgen_bitfield_unit.set(42usize, 1u8, {
            let simple_pairing_complete_event: u8 = unsafe { ::core::mem::transmute(simple_pairing_complete_event) };
            simple_pairing_complete_event as u64
        });
        __bindgen_bitfield_unit.set(43usize, 1u8, {
            let link_supervision_timeout_changed_event: u8 =
                unsafe { ::core::mem::transmute(link_supervision_timeout_changed_event) };
            link_supervision_timeout_changed_event as u64
        });
        __bindgen_bitfield_unit.set(44usize, 1u8, {
            let enhanced_flush_complete_event: u8 = unsafe { ::core::mem::transmute(enhanced_flush_complete_event) };
            enhanced_flush_complete_event as u64
        });
        __bindgen_bitfield_unit.set(45usize, 1u8, {
            let user_passkey_notification_event: u8 =
                unsafe { ::core::mem::transmute(user_passkey_notification_event) };
            user_passkey_notification_event as u64
        });
        __bindgen_bitfield_unit.set(46usize, 1u8, {
            let keypress_notification_event: u8 = unsafe { ::core::mem::transmute(keypress_notification_event) };
            keypress_notification_event as u64
        });
        __bindgen_bitfield_unit.set(47usize, 1u8, {
            let remote_host_supported_features_notification_event: u8 =
                unsafe { ::core::mem::transmute(remote_host_supported_features_notification_event) };
            remote_host_supported_features_notification_event as u64
        });
        __bindgen_bitfield_unit.set(48usize, 1u8, {
            let le_meta_event: u8 = unsafe { ::core::mem::transmute(le_meta_event) };
            le_meta_event as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Event mask page 2.\n\n If the bit in the Event_Mask is set to a one,\n then the event associated with that bit will be enabled."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cb_event_mask_page_2_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cb_event_mask_page_2_t"][::core::mem::size_of::<sdc_hci_cb_event_mask_page_2_t>() - 4usize];
    ["Alignment of sdc_hci_cb_event_mask_page_2_t"][::core::mem::align_of::<sdc_hci_cb_event_mask_page_2_t>() - 1usize];
};
impl sdc_hci_cb_event_mask_page_2_t {
    #[inline]
    pub fn previously_used0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used0_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used0_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used1_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used1_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used2_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used2_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used3_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used3_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used4_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used4_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used5_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used5_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used6_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used6_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used7_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used7_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn number_of_completed_data_blocks_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_number_of_completed_data_blocks_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn number_of_completed_data_blocks_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_number_of_completed_data_blocks_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used9(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used9(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used9_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used9_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used10(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used10(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used10_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used10_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used11(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used11(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used11_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used11_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used12(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used12(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used12_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used12_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used13(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used13(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used13_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used13_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn triggered_clock_capture_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_triggered_clock_capture_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn triggered_clock_capture_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_triggered_clock_capture_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn synchronization_train_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_synchronization_train_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn synchronization_train_complete_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_synchronization_train_complete_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn synchronization_train_received_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_synchronization_train_received_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn synchronization_train_received_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_synchronization_train_received_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn connectionless_peripheral_broadcast_receive_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_connectionless_peripheral_broadcast_receive_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn connectionless_peripheral_broadcast_receive_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_connectionless_peripheral_broadcast_receive_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn connectionless_peripheral_broadcast_timeout_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_connectionless_peripheral_broadcast_timeout_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn connectionless_peripheral_broadcast_timeout_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_connectionless_peripheral_broadcast_timeout_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn truncated_page_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_truncated_page_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn truncated_page_complete_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_truncated_page_complete_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn peripheral_page_response_timeout_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_peripheral_page_response_timeout_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn peripheral_page_response_timeout_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_peripheral_page_response_timeout_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn connectionless_peripheral_broadcast_channel_map_change_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_connectionless_peripheral_broadcast_channel_map_change_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn connectionless_peripheral_broadcast_channel_map_change_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_connectionless_peripheral_broadcast_channel_map_change_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn inquiry_response_notification_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_inquiry_response_notification_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inquiry_response_notification_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_inquiry_response_notification_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn authenticated_payload_timeout_expired_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_authenticated_payload_timeout_expired_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn authenticated_payload_timeout_expired_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_authenticated_payload_timeout_expired_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sam_status_change_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sam_status_change_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sam_status_change_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_sam_status_change_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn encryption_change_event_v2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encryption_change_event_v2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn encryption_change_event_v2_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                25usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_encryption_change_event_v2_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        previously_used0: u8,
        previously_used1: u8,
        previously_used2: u8,
        previously_used3: u8,
        previously_used4: u8,
        previously_used5: u8,
        previously_used6: u8,
        previously_used7: u8,
        number_of_completed_data_blocks_event: u8,
        previously_used9: u8,
        previously_used10: u8,
        previously_used11: u8,
        previously_used12: u8,
        previously_used13: u8,
        triggered_clock_capture_event: u8,
        synchronization_train_complete_event: u8,
        synchronization_train_received_event: u8,
        connectionless_peripheral_broadcast_receive_event: u8,
        connectionless_peripheral_broadcast_timeout_event: u8,
        truncated_page_complete_event: u8,
        peripheral_page_response_timeout_event: u8,
        connectionless_peripheral_broadcast_channel_map_change_event: u8,
        inquiry_response_notification_event: u8,
        authenticated_payload_timeout_expired_event: u8,
        sam_status_change_event: u8,
        encryption_change_event_v2: u8,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let previously_used0: u8 = unsafe { ::core::mem::transmute(previously_used0) };
            previously_used0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let previously_used1: u8 = unsafe { ::core::mem::transmute(previously_used1) };
            previously_used1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let previously_used2: u8 = unsafe { ::core::mem::transmute(previously_used2) };
            previously_used2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let previously_used3: u8 = unsafe { ::core::mem::transmute(previously_used3) };
            previously_used3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let previously_used4: u8 = unsafe { ::core::mem::transmute(previously_used4) };
            previously_used4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let previously_used5: u8 = unsafe { ::core::mem::transmute(previously_used5) };
            previously_used5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let previously_used6: u8 = unsafe { ::core::mem::transmute(previously_used6) };
            previously_used6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let previously_used7: u8 = unsafe { ::core::mem::transmute(previously_used7) };
            previously_used7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let number_of_completed_data_blocks_event: u8 =
                unsafe { ::core::mem::transmute(number_of_completed_data_blocks_event) };
            number_of_completed_data_blocks_event as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let previously_used9: u8 = unsafe { ::core::mem::transmute(previously_used9) };
            previously_used9 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let previously_used10: u8 = unsafe { ::core::mem::transmute(previously_used10) };
            previously_used10 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let previously_used11: u8 = unsafe { ::core::mem::transmute(previously_used11) };
            previously_used11 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let previously_used12: u8 = unsafe { ::core::mem::transmute(previously_used12) };
            previously_used12 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let previously_used13: u8 = unsafe { ::core::mem::transmute(previously_used13) };
            previously_used13 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let triggered_clock_capture_event: u8 = unsafe { ::core::mem::transmute(triggered_clock_capture_event) };
            triggered_clock_capture_event as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let synchronization_train_complete_event: u8 =
                unsafe { ::core::mem::transmute(synchronization_train_complete_event) };
            synchronization_train_complete_event as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let synchronization_train_received_event: u8 =
                unsafe { ::core::mem::transmute(synchronization_train_received_event) };
            synchronization_train_received_event as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let connectionless_peripheral_broadcast_receive_event: u8 =
                unsafe { ::core::mem::transmute(connectionless_peripheral_broadcast_receive_event) };
            connectionless_peripheral_broadcast_receive_event as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let connectionless_peripheral_broadcast_timeout_event: u8 =
                unsafe { ::core::mem::transmute(connectionless_peripheral_broadcast_timeout_event) };
            connectionless_peripheral_broadcast_timeout_event as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let truncated_page_complete_event: u8 = unsafe { ::core::mem::transmute(truncated_page_complete_event) };
            truncated_page_complete_event as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let peripheral_page_response_timeout_event: u8 =
                unsafe { ::core::mem::transmute(peripheral_page_response_timeout_event) };
            peripheral_page_response_timeout_event as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let connectionless_peripheral_broadcast_channel_map_change_event: u8 =
                unsafe { ::core::mem::transmute(connectionless_peripheral_broadcast_channel_map_change_event) };
            connectionless_peripheral_broadcast_channel_map_change_event as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let inquiry_response_notification_event: u8 =
                unsafe { ::core::mem::transmute(inquiry_response_notification_event) };
            inquiry_response_notification_event as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let authenticated_payload_timeout_expired_event: u8 =
                unsafe { ::core::mem::transmute(authenticated_payload_timeout_expired_event) };
            authenticated_payload_timeout_expired_event as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let sam_status_change_event: u8 = unsafe { ::core::mem::transmute(sam_status_change_event) };
            sam_status_change_event as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let encryption_change_event_v2: u8 = unsafe { ::core::mem::transmute(encryption_change_event_v2) };
            encryption_change_event_v2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Host Number Of Completed Packets array parameters."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cb_host_number_of_completed_packets_array_params_t {
    pub conn_handle: u16,
    pub host_num_completed_packets: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cb_host_number_of_completed_packets_array_params_t"]
        [::core::mem::size_of::<sdc_hci_cb_host_number_of_completed_packets_array_params_t>() - 4usize];
    ["Alignment of sdc_hci_cb_host_number_of_completed_packets_array_params_t"]
        [::core::mem::align_of::<sdc_hci_cb_host_number_of_completed_packets_array_params_t>() - 1usize];
    ["Offset of field: sdc_hci_cb_host_number_of_completed_packets_array_params_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cb_host_number_of_completed_packets_array_params_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cb_host_number_of_completed_packets_array_params_t::host_num_completed_packets"][::core::mem::offset_of!(
        sdc_hci_cb_host_number_of_completed_packets_array_params_t,
        host_num_completed_packets
    )
        - 2usize];
};
#[doc = "Set Event Mask command parameter(s)."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union sdc_hci_cmd_cb_set_event_mask_t {
    pub params: sdc_hci_cb_event_mask_t,
    pub raw: [u8; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_cb_set_event_mask_t"][::core::mem::size_of::<sdc_hci_cmd_cb_set_event_mask_t>() - 8usize];
    ["Alignment of sdc_hci_cmd_cb_set_event_mask_t"]
        [::core::mem::align_of::<sdc_hci_cmd_cb_set_event_mask_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_cb_set_event_mask_t::params"]
        [::core::mem::offset_of!(sdc_hci_cmd_cb_set_event_mask_t, params) - 0usize];
    ["Offset of field: sdc_hci_cmd_cb_set_event_mask_t::raw"]
        [::core::mem::offset_of!(sdc_hci_cmd_cb_set_event_mask_t, raw) - 0usize];
};
#[doc = "Read Connection Accept Timeout return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_cb_read_conn_accept_timeout_return_t {
    pub conn_accept_timeout: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_cb_read_conn_accept_timeout_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_cb_read_conn_accept_timeout_return_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_cb_read_conn_accept_timeout_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_cb_read_conn_accept_timeout_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_cb_read_conn_accept_timeout_return_t::conn_accept_timeout"]
        [::core::mem::offset_of!(sdc_hci_cmd_cb_read_conn_accept_timeout_return_t, conn_accept_timeout) - 0usize];
};
#[doc = "Write Connection Accept Timeout command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_cb_write_conn_accept_timeout_t {
    pub conn_accept_timeout: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_cb_write_conn_accept_timeout_t"]
        [::core::mem::size_of::<sdc_hci_cmd_cb_write_conn_accept_timeout_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_cb_write_conn_accept_timeout_t"]
        [::core::mem::align_of::<sdc_hci_cmd_cb_write_conn_accept_timeout_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_cb_write_conn_accept_timeout_t::conn_accept_timeout"]
        [::core::mem::offset_of!(sdc_hci_cmd_cb_write_conn_accept_timeout_t, conn_accept_timeout) - 0usize];
};
#[doc = "Read Transmit Power Level command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_cb_read_transmit_power_level_t {
    pub conn_handle: u16,
    pub type_: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_cb_read_transmit_power_level_t"]
        [::core::mem::size_of::<sdc_hci_cmd_cb_read_transmit_power_level_t>() - 3usize];
    ["Alignment of sdc_hci_cmd_cb_read_transmit_power_level_t"]
        [::core::mem::align_of::<sdc_hci_cmd_cb_read_transmit_power_level_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_cb_read_transmit_power_level_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_cb_read_transmit_power_level_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_cb_read_transmit_power_level_t::type_"]
        [::core::mem::offset_of!(sdc_hci_cmd_cb_read_transmit_power_level_t, type_) - 2usize];
};
#[doc = "Read Transmit Power Level return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_cb_read_transmit_power_level_return_t {
    pub conn_handle: u16,
    pub tx_power_level: i8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_cb_read_transmit_power_level_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_cb_read_transmit_power_level_return_t>() - 3usize];
    ["Alignment of sdc_hci_cmd_cb_read_transmit_power_level_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_cb_read_transmit_power_level_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_cb_read_transmit_power_level_return_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_cb_read_transmit_power_level_return_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_cb_read_transmit_power_level_return_t::tx_power_level"]
        [::core::mem::offset_of!(sdc_hci_cmd_cb_read_transmit_power_level_return_t, tx_power_level) - 2usize];
};
#[doc = "Set Controller To Host Flow Control command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_cb_set_controller_to_host_flow_control_t {
    pub flow_control_enable: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_cb_set_controller_to_host_flow_control_t"]
        [::core::mem::size_of::<sdc_hci_cmd_cb_set_controller_to_host_flow_control_t>() - 1usize];
    ["Alignment of sdc_hci_cmd_cb_set_controller_to_host_flow_control_t"]
        [::core::mem::align_of::<sdc_hci_cmd_cb_set_controller_to_host_flow_control_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_cb_set_controller_to_host_flow_control_t::flow_control_enable"][::core::mem::offset_of!(
        sdc_hci_cmd_cb_set_controller_to_host_flow_control_t,
        flow_control_enable
    ) - 0usize];
};
#[doc = "Host Buffer Size command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_cb_host_buffer_size_t {
    pub host_acl_data_packet_length: u16,
    pub host_sync_data_packet_length: u8,
    pub host_total_num_acl_data_packets: u16,
    pub host_total_num_sync_data_packets: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_cb_host_buffer_size_t"][::core::mem::size_of::<sdc_hci_cmd_cb_host_buffer_size_t>() - 7usize];
    ["Alignment of sdc_hci_cmd_cb_host_buffer_size_t"]
        [::core::mem::align_of::<sdc_hci_cmd_cb_host_buffer_size_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_cb_host_buffer_size_t::host_acl_data_packet_length"]
        [::core::mem::offset_of!(sdc_hci_cmd_cb_host_buffer_size_t, host_acl_data_packet_length) - 0usize];
    ["Offset of field: sdc_hci_cmd_cb_host_buffer_size_t::host_sync_data_packet_length"]
        [::core::mem::offset_of!(sdc_hci_cmd_cb_host_buffer_size_t, host_sync_data_packet_length) - 2usize];
    ["Offset of field: sdc_hci_cmd_cb_host_buffer_size_t::host_total_num_acl_data_packets"]
        [::core::mem::offset_of!(sdc_hci_cmd_cb_host_buffer_size_t, host_total_num_acl_data_packets) - 3usize];
    ["Offset of field: sdc_hci_cmd_cb_host_buffer_size_t::host_total_num_sync_data_packets"]
        [::core::mem::offset_of!(sdc_hci_cmd_cb_host_buffer_size_t, host_total_num_sync_data_packets) - 5usize];
};
#[doc = "Host Number Of Completed Packets command parameter(s)."]
#[repr(C, packed)]
pub struct sdc_hci_cmd_cb_host_number_of_completed_packets_t {
    pub num_handles: u8,
    pub array_params: __IncompleteArrayField<sdc_hci_cb_host_number_of_completed_packets_array_params_t>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_cb_host_number_of_completed_packets_t"]
        [::core::mem::size_of::<sdc_hci_cmd_cb_host_number_of_completed_packets_t>() - 1usize];
    ["Alignment of sdc_hci_cmd_cb_host_number_of_completed_packets_t"]
        [::core::mem::align_of::<sdc_hci_cmd_cb_host_number_of_completed_packets_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_cb_host_number_of_completed_packets_t::num_handles"]
        [::core::mem::offset_of!(sdc_hci_cmd_cb_host_number_of_completed_packets_t, num_handles) - 0usize];
    ["Offset of field: sdc_hci_cmd_cb_host_number_of_completed_packets_t::array_params"]
        [::core::mem::offset_of!(sdc_hci_cmd_cb_host_number_of_completed_packets_t, array_params) - 1usize];
};
#[doc = "Set Event Mask Page 2 command parameter(s)."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union sdc_hci_cmd_cb_set_event_mask_page_2_t {
    pub params: sdc_hci_cb_event_mask_page_2_t,
    pub raw: [u8; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_cb_set_event_mask_page_2_t"]
        [::core::mem::size_of::<sdc_hci_cmd_cb_set_event_mask_page_2_t>() - 8usize];
    ["Alignment of sdc_hci_cmd_cb_set_event_mask_page_2_t"]
        [::core::mem::align_of::<sdc_hci_cmd_cb_set_event_mask_page_2_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_cb_set_event_mask_page_2_t::params"]
        [::core::mem::offset_of!(sdc_hci_cmd_cb_set_event_mask_page_2_t, params) - 0usize];
    ["Offset of field: sdc_hci_cmd_cb_set_event_mask_page_2_t::raw"]
        [::core::mem::offset_of!(sdc_hci_cmd_cb_set_event_mask_page_2_t, raw) - 0usize];
};
#[doc = "Read Authenticated Payload Timeout command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_cb_read_authenticated_payload_timeout_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_cb_read_authenticated_payload_timeout_t"]
        [::core::mem::size_of::<sdc_hci_cmd_cb_read_authenticated_payload_timeout_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_cb_read_authenticated_payload_timeout_t"]
        [::core::mem::align_of::<sdc_hci_cmd_cb_read_authenticated_payload_timeout_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_cb_read_authenticated_payload_timeout_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_cb_read_authenticated_payload_timeout_t, conn_handle) - 0usize];
};
#[doc = "Read Authenticated Payload Timeout return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_cb_read_authenticated_payload_timeout_return_t {
    pub conn_handle: u16,
    pub authenticated_payload_timeout: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_cb_read_authenticated_payload_timeout_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_cb_read_authenticated_payload_timeout_return_t>() - 4usize];
    ["Alignment of sdc_hci_cmd_cb_read_authenticated_payload_timeout_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_cb_read_authenticated_payload_timeout_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_cb_read_authenticated_payload_timeout_return_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_cb_read_authenticated_payload_timeout_return_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_cb_read_authenticated_payload_timeout_return_t::authenticated_payload_timeout"][::core::mem::offset_of!(
        sdc_hci_cmd_cb_read_authenticated_payload_timeout_return_t,
        authenticated_payload_timeout
    )
        - 2usize];
};
#[doc = "Write Authenticated Payload Timeout command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_cb_write_authenticated_payload_timeout_t {
    pub conn_handle: u16,
    pub authenticated_payload_timeout: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_cb_write_authenticated_payload_timeout_t"]
        [::core::mem::size_of::<sdc_hci_cmd_cb_write_authenticated_payload_timeout_t>() - 4usize];
    ["Alignment of sdc_hci_cmd_cb_write_authenticated_payload_timeout_t"]
        [::core::mem::align_of::<sdc_hci_cmd_cb_write_authenticated_payload_timeout_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_cb_write_authenticated_payload_timeout_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_cb_write_authenticated_payload_timeout_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_cb_write_authenticated_payload_timeout_t::authenticated_payload_timeout"][::core::mem::offset_of!(
        sdc_hci_cmd_cb_write_authenticated_payload_timeout_t,
        authenticated_payload_timeout
    )
        - 2usize];
};
#[doc = "Write Authenticated Payload Timeout return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_cb_write_authenticated_payload_timeout_return_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_cb_write_authenticated_payload_timeout_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_cb_write_authenticated_payload_timeout_return_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_cb_write_authenticated_payload_timeout_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_cb_write_authenticated_payload_timeout_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_cb_write_authenticated_payload_timeout_return_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_cb_write_authenticated_payload_timeout_return_t, conn_handle) - 0usize];
};
unsafe extern "C" {
    #[doc = "HCI_VS_API API\n # /\n/* Set Event Mask.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.3.1\n\n The HCI_Set_Event_Mask command is used to control which events are generated\n by the HCI for the Host. If the bit in the Event_Mask is set to a one, then the event\n associated with that bit will be enabled. For an LE Controller, the LE Meta event bit\n in the event_Mask shall enable or disable all LE events in the LE Meta event (see\n Section 7.7.65). The event mask allows the Host to control how much it is interrupted.\n\n The Controller shall ignore those bits which are reserved for future use or represent\n events which it does not support. If the Host sets any of these bits to 1, the Controller\n shall act as if they were set to 0.\n\n Event(s) generated (unless masked away):\n When the HCI_Set_Event_Mask command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_cb_set_event_mask(p_params: *const sdc_hci_cmd_cb_set_event_mask_t) -> u8;
}
unsafe extern "C" {
    #[doc = "Reset.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.3.2\n\n The HCI_Reset command will reset the Controller and the Link Manager on the\n BR/EDR Controller or the Link Layer on an LE Controller. If the Controller supports both\n BR/EDR and LE then the HCI_Reset command shall reset the Link Manager, Baseband\n and Link Layer. The HCI_Reset command shall not affect the used HCI transport layer\n since the HCI transport layers may have reset mechanisms of their own. After the\n reset is completed, the current operational state will be lost, the Controller will enter\n standby mode and the Controller will automatically revert to the default values for the\n parameters for which default values are defined in the specification.\n\n Note: The HCI_Reset command will not necessarily perform a hardware reset. This is\n implementation defined.\n\n The Host shall not send additional HCI commands before the\n HCI_Command_Complete event related to the HCI_Reset command has been\n received.\n\n Event(s) generated (unless masked away):\n When the reset has been performed, an HCI_Command_Complete event shall be\n generated.\n\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_cb_reset() -> u8;
}
unsafe extern "C" {
    #[doc = "Read Connection Accept Timeout.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.3.13\n\n This command reads the value for the Connection_Accept_Timeout configuration\n parameter. See Section 6.7.\n\n Event(s) generated (unless masked away):\n When the HCI_Read_Connection_Timeout command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_cb_read_conn_accept_timeout(
        p_return: *mut sdc_hci_cmd_cb_read_conn_accept_timeout_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "Write Connection Accept Timeout.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.3.14\n\n This command writes the value for the Connection_Accept_Timeout configuration\n parameter. See Section 6.7.\n\n Event(s) generated (unless masked away):\n When the HCI_Write_Connection_Accept_Timeout command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_cb_write_conn_accept_timeout(p_params: *const sdc_hci_cmd_cb_write_conn_accept_timeout_t) -> u8;
}
unsafe extern "C" {
    #[doc = "Read Transmit Power Level.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.3.35\n\n This command reads the values for the TX_Power_Level parameter for the specified\n Connection_Handle. The Connection_Handle shall be a Connection_Handle for an ACL\n connection.\n\n Event(s) generated (unless masked away):\n When the HCI_Read_Transmit_Power_Level command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_cb_read_transmit_power_level(
        p_params: *const sdc_hci_cmd_cb_read_transmit_power_level_t,
        p_return: *mut sdc_hci_cmd_cb_read_transmit_power_level_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "Set Controller To Host Flow Control.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.3.38\n\n This command is used by the Host to turn flow control on or off for data and/or\n voice sent in the direction from the Controller to the Host. If flow control is turned off,\n the Host should not send the HCI_Host_Number_Of_Completed_Packets command.\n That command will be ignored by the Controller if it is sent by the Host and flow\n control is off. If flow control is turned on for HCI ACL Data packets and off for HCI\n Synchronous Data packets, HCI_Host_Number_Of_Completed_Packets commands\n sent by the Host should only contain Connection_Handles for ACL connections. If\n flow control is turned off for HCI ACL Data packets and on for HCI Synchronous\n Data packets, HCI_Host_Number_Of_Completed_Packets commands sent by the Host\n should only contain Connection_Handles for synchronous connections. If flow control is\n turned on for HCI ACL Data packets and HCI Synchronous Data packets, the Host will\n send HCI_Host_Number_Of_Completed_Packets commands both for ACL connections\n and synchronous connections.\n\n The Flow_Control_Enable parameter shall only be changed if no connections exist.\n\n Event(s) generated (unless masked away):\n When the HCI_Set_Controller_To_Host_Flow_Control command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_cb_set_controller_to_host_flow_control(
        p_params: *const sdc_hci_cmd_cb_set_controller_to_host_flow_control_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "Host Buffer Size.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.3.39\n\n The HCI_Host_Buffer_Size command is used by the Host to notify the Controller about\n the maximum size of the data portion of HCI ACL and Synchronous Data packets sent\n from the Controller to the Host. The Controller shall fragment the data to be transmitted\n from the Controller to the Host according to these sizes, so that the HCI Data packets\n will contain data with up to these sizes. The HCI_Host_Buffer_Size command also\n notifies the Controller about the total number of HCI ACL and Synchronous Data\n packets that can be stored in the data buffers of the Host. If flow control from the\n Controller to the Host is turned off, and the HCI_Host_Buffer_Size command has not\n been issued by the Host, this means that the Controller will send HCI Data packets\n to the Host with any lengths the Controller wants to use, and it is assumed that the\n data buffer sizes of the Host are unlimited. If flow control from the Controller to the\n Host is turned on, the HCI_Host_Buffer_Size command shall after a power-on or a reset\n always be sent by the Host before the first HCI_Host_Number_Of_Completed_Packets\n command is sent.\n\n The Set Controller To Host Flow Control command is used to turn flow control on or\n off. The Host_ACL_Data_Packet_Length parameter will be used to determine the size\n of the L2CAP fragments contained in ACL Data packets, which are transferred from\n the Controller to the Host. The Host_Synchronous_Data_Packet_Length parameter is\n used to determine the maximum size of HCI Synchronous Data packets. Both the Host\n and the Controller shall support command and event packets, where the data portion\n (excluding header) contained in the packets is 255 octets in size.\n\n The Host_Total_Num_ACL_Data_Packets parameter contains the total number of HCI\n ACL Data packets that can be stored in the data buffers of the Host. The Controller will\n determine how the buffers are to be divided between different Connection_Handles. The\n Host_Total_Num_Synchronous_Data_Packets parameter gives the same information\n for HCI Synchronous Data packets. If the Host does not support SCO or eSCO\n over HCI, then it shall set Host_Total_Num_Synchronous_Data_Packets to zero, in\n which case the Controller shall ignore the Host_Synchronous_Data_Packet_Length\n parameter.\n Note: The Host_ACL_Data_Packet_Length and\n Host_Synchronous_Data_Packet_Length command parameters do not include the\n length of the HCI ACL Data packet header or the HCI Synchronous Data packet header\n respectively.\n\n Event(s) generated (unless masked away):\n When the HCI_Host_Buffer_Size command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_cb_host_buffer_size(p_params: *const sdc_hci_cmd_cb_host_buffer_size_t) -> u8;
}
unsafe extern "C" {
    #[doc = "Host Number Of Completed Packets.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.3.40\n\n The HCI_Host_Number_Of_Completed_Packets command is used by the\n Host to indicate to the Controller the number of HCI Data packets\n that have been completed for each Connection_Handle since the\n previous HCI_Host_Number_Of_Completed_Packets command was sent to\n the Controller. This means that the corresponding buffer space has\n been freed in the Host and is available for new packets to be\n sent. Based on this information, and the Host_Total_Num_ACL_Data_Packets\n and Host_Total_Num_Synchronous_Data_Packets command parameters of the\n HCI_Host_Buffer_Size command, the Controller can determine for which\n Connection_Handles the following HCI Data packets should be sent to the Host.\n When the Host has completed one or more HCI Data packet(s) it shall send an\n HCI_Host_Number_Of_Completed_Packets command to the Controller, until it finally\n reports that all pending HCI Data packets have been completed. The frequency at\n which this command is sent is manufacturer specific.\n\n The Set Controller To Host Flow Control command is used to turn flow control on or off.\n If flow control from the Controller to the Host is turned on, the HCI_Host_Buffer_Size\n command shall always be sent by the Host after a power-on or a reset before the first\n HCI_Host_Number_Of_Completed_Packets command is sent.\n\n The HCI_Host_Number_Of_Completed_Packets command may be sent at any time by\n the Host when there is at least one connection, or if the Controller is in local loopback\n mode, independent of other commands. If the Host issues this command when neither\n of these cases applies, the Controller shall ignore it.\n\n Event(s) generated (unless masked away):\n Normally, no event is generated after the HCI_Host_Number_Of_Completed_Packets\n command has completed. However, if the HCI_Host_Number_Of_Completed_Packets\n command contains one or more invalid parameters, the Controller shall return an\n HCI_Command_Complete event containing the error code Invalid HCI Command\n Parameters (0x12). The normal flow control for commands is not used for this\n command.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_cb_host_number_of_completed_packets(
        p_params: *const sdc_hci_cmd_cb_host_number_of_completed_packets_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "Set Event Mask Page 2.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.3.69\n\n The HCI_Set_Event_Mask_Page_2 command is used to control which events are\n generated by the HCI for the Host. The Event_Mask_Page_2 is a logical extension\n to the Event_Mask parameter of the HCI_Set_Event_Mask command. If the bit in the\n Event_Mask_Page_2 is set to a one, then the event associated with that bit shall be\n enabled. The event mask allows the Host to control how much it is interrupted.\n\n The Controller shall ignore those bits which are reserved for future use or represent\n events which it does not support. If the Host sets any of these bits to 1, the Controller\n shall act as if they were set to 0.\n\n Event(s) generated (unless masked away):\n When the HCI_Set_Event_Mask_Page_2 command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_cb_set_event_mask_page_2(p_params: *const sdc_hci_cmd_cb_set_event_mask_page_2_t) -> u8;
}
unsafe extern "C" {
    #[doc = "Read Authenticated Payload Timeout.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.3.93\n\n This command reads the Authenticated_Payload_Timeout (authenticatedPayloadTO,\n see 2] Part B, Appendix B for BR/EDR connections and 6] Part B, Section 5.4\n for LE connections) parameter in the Controller on the specified Connection_Handle.\n\n When the Connection_Handle identifies a BR/EDR synchronous connection or an LE\n BIS or CIS, the Controller shall return the error code Command Disallowed (0x0C).\n\n Event(s) generated (unless masked away):\n When the HCI_Read_Authenticated_Payload_Timeout command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_cb_read_authenticated_payload_timeout(
        p_params: *const sdc_hci_cmd_cb_read_authenticated_payload_timeout_t,
        p_return: *mut sdc_hci_cmd_cb_read_authenticated_payload_timeout_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "Write Authenticated Payload Timeout.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.3.94\n\n This command writes the Authenticated_Payload_Timeout (authenticatedPayloadTO,\n see 2] Part B, Appendix B and 6] Part B, Section 5.4 for the LE connection)\n parameter in the Controller for the specified Connection_Handle.\n\n When the Connection_Handle identifies a BR/EDR ACL connection:\n\n  If the connection is in Sniff mode, the Authenticated_Payload_Timeout shall be equal\n to or greater than Tsniff.\n  If the connection is in Sniff Subrating mode, the Authenticated_Payload_Timeout shall\n be equal to or greater than\n (max subrate)xTsniff.\n  If the connection is in Hold mode, the Authenticated_Payload_Timeout shall be equal\n to or greater than the holdTO value.\n\n When the Connection_Handle identifies an LE ACL connection, the\n Authenticated_Payload_Timeout shall be equal to or greater than connInterval \n connSubrateFactor  (1 + connPeripheralLatency).\n\n When the Connection_Handle is associated with a BR/EDR ACL connection, the Link\n Manager will use this parameter to determine when to use the LMP ping sequence.\n\n When the Connection_Handle is associated with an LE ACL connection, the Link Layer\n will use this parameter to determine when to use the LE ping sequence.\n\n When the Connection_Handle identifies a BR/EDR synchronous connection or an LE\n BIS or CIS, this command shall be rejected with the error code Command Disallowed\n (0x0C).\n\n Event(s) generated (unless masked away):\n When the HCI_Write_Authenticated_Payload_Timeout command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_cb_write_authenticated_payload_timeout(
        p_params: *const sdc_hci_cmd_cb_write_authenticated_payload_timeout_t,
        p_return: *mut sdc_hci_cmd_cb_write_authenticated_payload_timeout_return_t,
    ) -> u8;
}
#[doc = "See sdc_hci_cmd_ip_read_local_version_information()."]
pub const SDC_HCI_OPCODE_CMD_IP_READ_LOCAL_VERSION_INFORMATION: sdc_hci_opcode_ip = 4097;
#[doc = "See sdc_hci_cmd_ip_read_local_supported_commands()."]
pub const SDC_HCI_OPCODE_CMD_IP_READ_LOCAL_SUPPORTED_COMMANDS: sdc_hci_opcode_ip = 4098;
#[doc = "See sdc_hci_cmd_ip_read_local_supported_features()."]
pub const SDC_HCI_OPCODE_CMD_IP_READ_LOCAL_SUPPORTED_FEATURES: sdc_hci_opcode_ip = 4099;
#[doc = "See sdc_hci_cmd_ip_read_bd_addr()."]
pub const SDC_HCI_OPCODE_CMD_IP_READ_BD_ADDR: sdc_hci_opcode_ip = 4105;
#[doc = "HCI IP OpCode Field values."]
pub type sdc_hci_opcode_ip = ::core::ffi::c_uint;
#[doc = "LMP features.\n\n See Core_v5.4, Vol 2, Part C, Section 3.3"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_ip_lmp_features_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_ip_lmp_features_t"][::core::mem::size_of::<sdc_hci_ip_lmp_features_t>() - 8usize];
    ["Alignment of sdc_hci_ip_lmp_features_t"][::core::mem::align_of::<sdc_hci_ip_lmp_features_t>() - 1usize];
};
impl sdc_hci_ip_lmp_features_t {
    #[inline]
    pub fn slot3_packets(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_slot3_packets(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn slot3_packets_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_slot3_packets_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn slot5_packets(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_slot5_packets(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn slot5_packets_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_slot5_packets_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn encryption(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encryption(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn encryption_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_encryption_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn slot_offset(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_slot_offset(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn slot_offset_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_slot_offset_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn timing_accuracy(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_timing_accuracy(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn timing_accuracy_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_timing_accuracy_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn role_switch(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_role_switch(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn role_switch_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_role_switch_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hold_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hold_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hold_mode_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hold_mode_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sniff_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sniff_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sniff_mode_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_sniff_mode_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn power_control_requests(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_power_control_requests(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn power_control_requests_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_power_control_requests_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cqddr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cqddr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cqddr_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_cqddr_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sco_link(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sco_link(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sco_link_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_sco_link_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hv2_packets(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hv2_packets(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hv2_packets_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hv2_packets_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hv3_packets(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hv3_packets(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hv3_packets_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hv3_packets_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn u_law_log_sync_data(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_u_law_log_sync_data(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn u_law_log_sync_data_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_u_law_log_sync_data_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn a_law_log_sync_data(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_a_law_log_sync_data(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn a_law_log_sync_data_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_a_law_log_sync_data_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cvsd_sync_data(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cvsd_sync_data(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cvsd_sync_data_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_cvsd_sync_data_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn paging_param_negiotiation(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_paging_param_negiotiation(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn paging_param_negiotiation_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_paging_param_negiotiation_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn power_control(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_power_control(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn power_control_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_power_control_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn transparent_sync_data(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_transparent_sync_data(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn transparent_sync_data_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_transparent_sync_data_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flow_control_lag(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_flow_control_lag(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flow_control_lag_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_flow_control_lag_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn broadcast_encryption(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_broadcast_encryption(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn broadcast_encryption_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_broadcast_encryption_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu1_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu1_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enhanced_data_rate_acl_2mbps_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enhanced_data_rate_acl_2mbps_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enhanced_data_rate_acl_2mbps_mode_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                25usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_enhanced_data_rate_acl_2mbps_mode_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enhanced_data_rate_acl_3mbps_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enhanced_data_rate_acl_3mbps_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enhanced_data_rate_acl_3mbps_mode_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_enhanced_data_rate_acl_3mbps_mode_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enhanced_inquiry_scan(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enhanced_inquiry_scan(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enhanced_inquiry_scan_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                27usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_enhanced_inquiry_scan_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                27usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn interlaced_inquiry_scan(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_interlaced_inquiry_scan(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn interlaced_inquiry_scan_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_interlaced_inquiry_scan_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn interlaced_page_scan(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_interlaced_page_scan(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn interlaced_page_scan_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                29usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_interlaced_page_scan_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                29usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rssi_with_inquiry_results(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rssi_with_inquiry_results(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rssi_with_inquiry_results_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rssi_with_inquiry_results_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ext_sco_link(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ext_sco_link(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ext_sco_link_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ext_sco_link_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ev4_packets(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ev4_packets(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ev4_packets_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ev4_packets_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ev5_packets(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ev5_packets(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ev5_packets_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                33usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ev5_packets_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                33usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu2_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                34usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu2_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                34usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn afh_capable_peripheral(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_afh_capable_peripheral(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn afh_capable_peripheral_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                35usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_afh_capable_peripheral_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                35usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn afh_classification_peripheral(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_afh_classification_peripheral(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn afh_classification_peripheral_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                36usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_afh_classification_peripheral_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                36usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn bdedr_not_supported(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bdedr_not_supported(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bdedr_not_supported_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                37usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_bdedr_not_supported_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                37usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_supported(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_supported(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_supported_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                38usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_supported_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                38usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn slot3_enhanced_data_rate(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_slot3_enhanced_data_rate(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn slot3_enhanced_data_rate_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                39usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_slot3_enhanced_data_rate_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                39usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn slot5_enhanced_data_rate(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(40usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_slot5_enhanced_data_rate(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(40usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn slot5_enhanced_data_rate_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                40usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_slot5_enhanced_data_rate_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                40usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sniff_subrating(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(41usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sniff_subrating(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sniff_subrating_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                41usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_sniff_subrating_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                41usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pause_encryption(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(42usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pause_encryption(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(42usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pause_encryption_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                42usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_pause_encryption_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                42usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn afh_capable_central(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(43usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_afh_capable_central(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(43usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn afh_capable_central_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                43usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_afh_capable_central_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                43usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn afh_classification_central(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(44usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_afh_classification_central(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(44usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn afh_classification_central_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                44usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_afh_classification_central_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                44usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enhanced_data_rate_esco_2mbps_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(45usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enhanced_data_rate_esco_2mbps_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(45usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enhanced_data_rate_esco_2mbps_mode_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                45usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_enhanced_data_rate_esco_2mbps_mode_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                45usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enhanced_data_rate_esco_3mbps_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(46usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enhanced_data_rate_esco_3mbps_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(46usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enhanced_data_rate_esco_3mbps_mode_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                46usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_enhanced_data_rate_esco_3mbps_mode_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                46usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn slot3_enhanced_data_rate_esco(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(47usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_slot3_enhanced_data_rate_esco(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(47usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn slot3_enhanced_data_rate_esco_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                47usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_slot3_enhanced_data_rate_esco_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                47usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ext_inquiry_response(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(48usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ext_inquiry_response(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(48usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ext_inquiry_response_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                48usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ext_inquiry_response_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                48usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn simultanious_le_and_bdedr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(49usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_simultanious_le_and_bdedr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(49usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn simultanious_le_and_bdedr_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                49usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_simultanious_le_and_bdedr_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                49usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(50usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(50usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu3_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                50usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu3_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                50usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn secure_simple_pairing(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(51usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_secure_simple_pairing(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(51usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn secure_simple_pairing_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                51usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_secure_simple_pairing_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                51usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn encapsulated_pdu(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(52usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encapsulated_pdu(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(52usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn encapsulated_pdu_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                52usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_encapsulated_pdu_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                52usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn errorneous_data_reporting(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_errorneous_data_reporting(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn errorneous_data_reporting_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                53usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_errorneous_data_reporting_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                53usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn non_flushable_packet_boundary(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(54usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_non_flushable_packet_boundary(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(54usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn non_flushable_packet_boundary_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                54usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_non_flushable_packet_boundary_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                54usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(55usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(55usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu4_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                55usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu4_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                55usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_link_supervision_timeout_changed_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(56usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_link_supervision_timeout_changed_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(56usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_link_supervision_timeout_changed_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                56usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_link_supervision_timeout_changed_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                56usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn variable_inquiry_tx_power_level(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(57usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_variable_inquiry_tx_power_level(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(57usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn variable_inquiry_tx_power_level_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                57usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_variable_inquiry_tx_power_level_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                57usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enhanced_power_control(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(58usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enhanced_power_control(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(58usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enhanced_power_control_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                58usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_enhanced_power_control_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                58usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(59usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(59usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu5_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                59usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu5_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                59usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(60usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(60usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu6_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                60usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu6_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                60usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(61usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(61usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu7_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                61usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu7_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                61usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu8(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(62usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu8(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(62usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu8_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                62usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu8_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                62usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ext_features(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ext_features(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ext_features_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                63usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ext_features_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                63usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slot3_packets: u8,
        slot5_packets: u8,
        encryption: u8,
        slot_offset: u8,
        timing_accuracy: u8,
        role_switch: u8,
        hold_mode: u8,
        sniff_mode: u8,
        previously_used: u8,
        power_control_requests: u8,
        cqddr: u8,
        sco_link: u8,
        hv2_packets: u8,
        hv3_packets: u8,
        u_law_log_sync_data: u8,
        a_law_log_sync_data: u8,
        cvsd_sync_data: u8,
        paging_param_negiotiation: u8,
        power_control: u8,
        transparent_sync_data: u8,
        flow_control_lag: u8,
        broadcast_encryption: u8,
        rfu1: u8,
        enhanced_data_rate_acl_2mbps_mode: u8,
        enhanced_data_rate_acl_3mbps_mode: u8,
        enhanced_inquiry_scan: u8,
        interlaced_inquiry_scan: u8,
        interlaced_page_scan: u8,
        rssi_with_inquiry_results: u8,
        ext_sco_link: u8,
        ev4_packets: u8,
        ev5_packets: u8,
        rfu2: u8,
        afh_capable_peripheral: u8,
        afh_classification_peripheral: u8,
        bdedr_not_supported: u8,
        le_supported: u8,
        slot3_enhanced_data_rate: u8,
        slot5_enhanced_data_rate: u8,
        sniff_subrating: u8,
        pause_encryption: u8,
        afh_capable_central: u8,
        afh_classification_central: u8,
        enhanced_data_rate_esco_2mbps_mode: u8,
        enhanced_data_rate_esco_3mbps_mode: u8,
        slot3_enhanced_data_rate_esco: u8,
        ext_inquiry_response: u8,
        simultanious_le_and_bdedr: u8,
        rfu3: u8,
        secure_simple_pairing: u8,
        encapsulated_pdu: u8,
        errorneous_data_reporting: u8,
        non_flushable_packet_boundary: u8,
        rfu4: u8,
        hci_link_supervision_timeout_changed_event: u8,
        variable_inquiry_tx_power_level: u8,
        enhanced_power_control: u8,
        rfu5: u8,
        rfu6: u8,
        rfu7: u8,
        rfu8: u8,
        ext_features: u8,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let slot3_packets: u8 = unsafe { ::core::mem::transmute(slot3_packets) };
            slot3_packets as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let slot5_packets: u8 = unsafe { ::core::mem::transmute(slot5_packets) };
            slot5_packets as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let encryption: u8 = unsafe { ::core::mem::transmute(encryption) };
            encryption as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let slot_offset: u8 = unsafe { ::core::mem::transmute(slot_offset) };
            slot_offset as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let timing_accuracy: u8 = unsafe { ::core::mem::transmute(timing_accuracy) };
            timing_accuracy as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let role_switch: u8 = unsafe { ::core::mem::transmute(role_switch) };
            role_switch as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let hold_mode: u8 = unsafe { ::core::mem::transmute(hold_mode) };
            hold_mode as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let sniff_mode: u8 = unsafe { ::core::mem::transmute(sniff_mode) };
            sniff_mode as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let previously_used: u8 = unsafe { ::core::mem::transmute(previously_used) };
            previously_used as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let power_control_requests: u8 = unsafe { ::core::mem::transmute(power_control_requests) };
            power_control_requests as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let cqddr: u8 = unsafe { ::core::mem::transmute(cqddr) };
            cqddr as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let sco_link: u8 = unsafe { ::core::mem::transmute(sco_link) };
            sco_link as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let hv2_packets: u8 = unsafe { ::core::mem::transmute(hv2_packets) };
            hv2_packets as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let hv3_packets: u8 = unsafe { ::core::mem::transmute(hv3_packets) };
            hv3_packets as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let u_law_log_sync_data: u8 = unsafe { ::core::mem::transmute(u_law_log_sync_data) };
            u_law_log_sync_data as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let a_law_log_sync_data: u8 = unsafe { ::core::mem::transmute(a_law_log_sync_data) };
            a_law_log_sync_data as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let cvsd_sync_data: u8 = unsafe { ::core::mem::transmute(cvsd_sync_data) };
            cvsd_sync_data as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let paging_param_negiotiation: u8 = unsafe { ::core::mem::transmute(paging_param_negiotiation) };
            paging_param_negiotiation as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let power_control: u8 = unsafe { ::core::mem::transmute(power_control) };
            power_control as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let transparent_sync_data: u8 = unsafe { ::core::mem::transmute(transparent_sync_data) };
            transparent_sync_data as u64
        });
        __bindgen_bitfield_unit.set(20usize, 3u8, {
            let flow_control_lag: u8 = unsafe { ::core::mem::transmute(flow_control_lag) };
            flow_control_lag as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let broadcast_encryption: u8 = unsafe { ::core::mem::transmute(broadcast_encryption) };
            broadcast_encryption as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let rfu1: u8 = unsafe { ::core::mem::transmute(rfu1) };
            rfu1 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let enhanced_data_rate_acl_2mbps_mode: u8 =
                unsafe { ::core::mem::transmute(enhanced_data_rate_acl_2mbps_mode) };
            enhanced_data_rate_acl_2mbps_mode as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let enhanced_data_rate_acl_3mbps_mode: u8 =
                unsafe { ::core::mem::transmute(enhanced_data_rate_acl_3mbps_mode) };
            enhanced_data_rate_acl_3mbps_mode as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let enhanced_inquiry_scan: u8 = unsafe { ::core::mem::transmute(enhanced_inquiry_scan) };
            enhanced_inquiry_scan as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let interlaced_inquiry_scan: u8 = unsafe { ::core::mem::transmute(interlaced_inquiry_scan) };
            interlaced_inquiry_scan as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let interlaced_page_scan: u8 = unsafe { ::core::mem::transmute(interlaced_page_scan) };
            interlaced_page_scan as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let rssi_with_inquiry_results: u8 = unsafe { ::core::mem::transmute(rssi_with_inquiry_results) };
            rssi_with_inquiry_results as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let ext_sco_link: u8 = unsafe { ::core::mem::transmute(ext_sco_link) };
            ext_sco_link as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let ev4_packets: u8 = unsafe { ::core::mem::transmute(ev4_packets) };
            ev4_packets as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let ev5_packets: u8 = unsafe { ::core::mem::transmute(ev5_packets) };
            ev5_packets as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let rfu2: u8 = unsafe { ::core::mem::transmute(rfu2) };
            rfu2 as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let afh_capable_peripheral: u8 = unsafe { ::core::mem::transmute(afh_capable_peripheral) };
            afh_capable_peripheral as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let afh_classification_peripheral: u8 = unsafe { ::core::mem::transmute(afh_classification_peripheral) };
            afh_classification_peripheral as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let bdedr_not_supported: u8 = unsafe { ::core::mem::transmute(bdedr_not_supported) };
            bdedr_not_supported as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let le_supported: u8 = unsafe { ::core::mem::transmute(le_supported) };
            le_supported as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let slot3_enhanced_data_rate: u8 = unsafe { ::core::mem::transmute(slot3_enhanced_data_rate) };
            slot3_enhanced_data_rate as u64
        });
        __bindgen_bitfield_unit.set(40usize, 1u8, {
            let slot5_enhanced_data_rate: u8 = unsafe { ::core::mem::transmute(slot5_enhanced_data_rate) };
            slot5_enhanced_data_rate as u64
        });
        __bindgen_bitfield_unit.set(41usize, 1u8, {
            let sniff_subrating: u8 = unsafe { ::core::mem::transmute(sniff_subrating) };
            sniff_subrating as u64
        });
        __bindgen_bitfield_unit.set(42usize, 1u8, {
            let pause_encryption: u8 = unsafe { ::core::mem::transmute(pause_encryption) };
            pause_encryption as u64
        });
        __bindgen_bitfield_unit.set(43usize, 1u8, {
            let afh_capable_central: u8 = unsafe { ::core::mem::transmute(afh_capable_central) };
            afh_capable_central as u64
        });
        __bindgen_bitfield_unit.set(44usize, 1u8, {
            let afh_classification_central: u8 = unsafe { ::core::mem::transmute(afh_classification_central) };
            afh_classification_central as u64
        });
        __bindgen_bitfield_unit.set(45usize, 1u8, {
            let enhanced_data_rate_esco_2mbps_mode: u8 =
                unsafe { ::core::mem::transmute(enhanced_data_rate_esco_2mbps_mode) };
            enhanced_data_rate_esco_2mbps_mode as u64
        });
        __bindgen_bitfield_unit.set(46usize, 1u8, {
            let enhanced_data_rate_esco_3mbps_mode: u8 =
                unsafe { ::core::mem::transmute(enhanced_data_rate_esco_3mbps_mode) };
            enhanced_data_rate_esco_3mbps_mode as u64
        });
        __bindgen_bitfield_unit.set(47usize, 1u8, {
            let slot3_enhanced_data_rate_esco: u8 = unsafe { ::core::mem::transmute(slot3_enhanced_data_rate_esco) };
            slot3_enhanced_data_rate_esco as u64
        });
        __bindgen_bitfield_unit.set(48usize, 1u8, {
            let ext_inquiry_response: u8 = unsafe { ::core::mem::transmute(ext_inquiry_response) };
            ext_inquiry_response as u64
        });
        __bindgen_bitfield_unit.set(49usize, 1u8, {
            let simultanious_le_and_bdedr: u8 = unsafe { ::core::mem::transmute(simultanious_le_and_bdedr) };
            simultanious_le_and_bdedr as u64
        });
        __bindgen_bitfield_unit.set(50usize, 1u8, {
            let rfu3: u8 = unsafe { ::core::mem::transmute(rfu3) };
            rfu3 as u64
        });
        __bindgen_bitfield_unit.set(51usize, 1u8, {
            let secure_simple_pairing: u8 = unsafe { ::core::mem::transmute(secure_simple_pairing) };
            secure_simple_pairing as u64
        });
        __bindgen_bitfield_unit.set(52usize, 1u8, {
            let encapsulated_pdu: u8 = unsafe { ::core::mem::transmute(encapsulated_pdu) };
            encapsulated_pdu as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let errorneous_data_reporting: u8 = unsafe { ::core::mem::transmute(errorneous_data_reporting) };
            errorneous_data_reporting as u64
        });
        __bindgen_bitfield_unit.set(54usize, 1u8, {
            let non_flushable_packet_boundary: u8 = unsafe { ::core::mem::transmute(non_flushable_packet_boundary) };
            non_flushable_packet_boundary as u64
        });
        __bindgen_bitfield_unit.set(55usize, 1u8, {
            let rfu4: u8 = unsafe { ::core::mem::transmute(rfu4) };
            rfu4 as u64
        });
        __bindgen_bitfield_unit.set(56usize, 1u8, {
            let hci_link_supervision_timeout_changed_event: u8 =
                unsafe { ::core::mem::transmute(hci_link_supervision_timeout_changed_event) };
            hci_link_supervision_timeout_changed_event as u64
        });
        __bindgen_bitfield_unit.set(57usize, 1u8, {
            let variable_inquiry_tx_power_level: u8 =
                unsafe { ::core::mem::transmute(variable_inquiry_tx_power_level) };
            variable_inquiry_tx_power_level as u64
        });
        __bindgen_bitfield_unit.set(58usize, 1u8, {
            let enhanced_power_control: u8 = unsafe { ::core::mem::transmute(enhanced_power_control) };
            enhanced_power_control as u64
        });
        __bindgen_bitfield_unit.set(59usize, 1u8, {
            let rfu5: u8 = unsafe { ::core::mem::transmute(rfu5) };
            rfu5 as u64
        });
        __bindgen_bitfield_unit.set(60usize, 1u8, {
            let rfu6: u8 = unsafe { ::core::mem::transmute(rfu6) };
            rfu6 as u64
        });
        __bindgen_bitfield_unit.set(61usize, 1u8, {
            let rfu7: u8 = unsafe { ::core::mem::transmute(rfu7) };
            rfu7 as u64
        });
        __bindgen_bitfield_unit.set(62usize, 1u8, {
            let rfu8: u8 = unsafe { ::core::mem::transmute(rfu8) };
            rfu8 as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let ext_features: u8 = unsafe { ::core::mem::transmute(ext_features) };
            ext_features as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Supported HCI commands.\n\n See Core_v5.4, Vol 4, Part E, Section 6.27"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_ip_supported_commands_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 49usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_ip_supported_commands_t"][::core::mem::size_of::<sdc_hci_ip_supported_commands_t>() - 49usize];
    ["Alignment of sdc_hci_ip_supported_commands_t"]
        [::core::mem::align_of::<sdc_hci_ip_supported_commands_t>() - 1usize];
};
impl sdc_hci_ip_supported_commands_t {
    #[inline]
    pub fn hci_inquiry(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_inquiry(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_inquiry_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_inquiry_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_inquiry_cancel(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_inquiry_cancel(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_inquiry_cancel_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_inquiry_cancel_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_periodic_inquiry_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_periodic_inquiry_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_periodic_inquiry_mode_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_periodic_inquiry_mode_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_exit_periodic_inquiry_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_exit_periodic_inquiry_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_exit_periodic_inquiry_mode_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_exit_periodic_inquiry_mode_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_create_connection(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_create_connection(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_create_connection_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_create_connection_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_disconnect(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_disconnect(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_disconnect_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_disconnect_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used_0_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_0_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used_0_6_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used_0_6_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_create_connection_cancel(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_create_connection_cancel(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_create_connection_cancel_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_create_connection_cancel_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_accept_connection_request(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_accept_connection_request(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_accept_connection_request_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_accept_connection_request_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_reject_connection_request(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_reject_connection_request(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_reject_connection_request_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_reject_connection_request_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_link_key_request_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_link_key_request_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_link_key_request_reply_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_link_key_request_reply_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_link_key_request_negative_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_link_key_request_negative_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_link_key_request_negative_reply_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_link_key_request_negative_reply_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_pin_code_request_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_pin_code_request_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_pin_code_request_reply_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_pin_code_request_reply_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_pin_code_request_negative_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_pin_code_request_negative_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_pin_code_request_negative_reply_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_pin_code_request_negative_reply_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_change_connection_packet_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_change_connection_packet_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_change_connection_packet_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_change_connection_packet_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_authentication_requested(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_authentication_requested(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_authentication_requested_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_authentication_requested_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_set_connection_encryption(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_connection_encryption(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_set_connection_encryption_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_set_connection_encryption_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_change_connection_link_key(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_change_connection_link_key(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_change_connection_link_key_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_change_connection_link_key_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_link_key_selection(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_link_key_selection(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_link_key_selection_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_link_key_selection_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_remote_name_request(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_remote_name_request(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_remote_name_request_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_remote_name_request_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_remote_name_request_cancel(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_remote_name_request_cancel(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_remote_name_request_cancel_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_remote_name_request_cancel_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_remote_supported_features(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_remote_supported_features(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_remote_supported_features_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_remote_supported_features_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_remote_extended_features(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_remote_extended_features(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_remote_extended_features_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_remote_extended_features_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_remote_version_information(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_remote_version_information(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_remote_version_information_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_remote_version_information_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_clock_offset(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_clock_offset(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_clock_offset_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_clock_offset_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_lmp_handle(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_lmp_handle(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_lmp_handle_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                25usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_lmp_handle_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu_3_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_3_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu_3_2_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu_3_2_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu_3_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_3_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu_3_3_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                27usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu_3_3_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                27usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu_3_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_3_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu_3_4_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu_3_4_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu_3_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_3_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu_3_5_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                29usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu_3_5_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                29usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu_3_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_3_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu_3_6_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu_3_6_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu_3_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_3_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu_3_7_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu_3_7_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu_4_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_4_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu_4_0_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu_4_0_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_hold_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_hold_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_hold_mode_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                33usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_hold_mode_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                33usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_sniff_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_sniff_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_sniff_mode_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                34usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_sniff_mode_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                34usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_exit_sniff_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_exit_sniff_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_exit_sniff_mode_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                35usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_exit_sniff_mode_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                35usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used_4_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_4_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used_4_4_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                36usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used_4_4_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                36usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used_4_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_4_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used_4_5_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                37usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used_4_5_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                37usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_qos_setup(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_qos_setup(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_qos_setup_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                38usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_qos_setup_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                38usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_role_discovery(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_role_discovery(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_role_discovery_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                39usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_role_discovery_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                39usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_switch_role(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(40usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_switch_role(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(40usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_switch_role_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                40usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_switch_role_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                40usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_link_policy_settings(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(41usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_link_policy_settings(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_link_policy_settings_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                41usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_link_policy_settings_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                41usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_link_policy_settings(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(42usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_link_policy_settings(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(42usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_link_policy_settings_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                42usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_link_policy_settings_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                42usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_default_link_policy_settings(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(43usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_default_link_policy_settings(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(43usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_default_link_policy_settings_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                43usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_default_link_policy_settings_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                43usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_default_link_policy_settings(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(44usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_default_link_policy_settings(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(44usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_default_link_policy_settings_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                44usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_default_link_policy_settings_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                44usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_flow_specification(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(45usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_flow_specification(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(45usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_flow_specification_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                45usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_flow_specification_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                45usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_set_event_mask(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(46usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_event_mask(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(46usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_set_event_mask_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                46usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_set_event_mask_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                46usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_reset(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(47usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_reset(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(47usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_reset_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                47usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_reset_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                47usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_set_event_filter(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(48usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_event_filter(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(48usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_set_event_filter_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                48usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_set_event_filter_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                48usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_flush(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(49usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_flush(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(49usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_flush_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                49usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_flush_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                49usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_pin_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(50usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_pin_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(50usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_pin_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                50usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_pin_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                50usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_pin_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(51usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_pin_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(51usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_pin_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                51usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_pin_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                51usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used_6_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(52usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_6_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(52usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used_6_4_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                52usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used_6_4_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                52usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_stored_link_key(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_stored_link_key(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_stored_link_key_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                53usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_stored_link_key_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                53usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_stored_link_key(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(54usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_stored_link_key(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(54usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_stored_link_key_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                54usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_stored_link_key_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                54usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_delete_stored_link_key(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(55usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_delete_stored_link_key(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(55usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_delete_stored_link_key_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                55usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_delete_stored_link_key_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                55usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_local_name(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(56usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_local_name(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(56usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_local_name_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                56usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_local_name_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                56usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_local_name(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(57usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_local_name(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(57usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_local_name_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                57usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_local_name_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                57usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_connection_accept_timeout(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(58usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_connection_accept_timeout(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(58usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_connection_accept_timeout_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                58usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_connection_accept_timeout_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                58usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_connection_accept_timeout(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(59usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_connection_accept_timeout(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(59usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_connection_accept_timeout_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                59usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_connection_accept_timeout_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                59usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_page_timeout(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(60usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_page_timeout(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(60usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_page_timeout_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                60usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_page_timeout_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                60usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_page_timeout(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(61usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_page_timeout(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(61usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_page_timeout_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                61usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_page_timeout_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                61usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_scan_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(62usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_scan_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(62usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_scan_enable_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                62usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_scan_enable_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                62usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_scan_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_scan_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_scan_enable_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                63usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_scan_enable_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                63usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_page_scan_activity(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(64usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_page_scan_activity(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(64usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_page_scan_activity_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                64usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_page_scan_activity_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                64usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_page_scan_activity(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(65usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_page_scan_activity(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(65usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_page_scan_activity_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                65usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_page_scan_activity_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                65usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_inquiry_scan_activity(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(66usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_inquiry_scan_activity(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(66usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_inquiry_scan_activity_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                66usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_inquiry_scan_activity_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                66usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_inquiry_scan_activity(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(67usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_inquiry_scan_activity(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(67usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_inquiry_scan_activity_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                67usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_inquiry_scan_activity_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                67usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_authentication_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(68usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_authentication_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(68usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_authentication_enable_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                68usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_authentication_enable_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                68usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_authentication_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(69usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_authentication_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(69usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_authentication_enable_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                69usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_authentication_enable_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                69usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used_8_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(70usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_8_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(70usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used_8_6_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                70usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used_8_6_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                70usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used_8_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(71usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_8_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(71usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used_8_7_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                71usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used_8_7_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                71usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_class_of_device(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(72usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_class_of_device(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(72usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_class_of_device_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                72usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_class_of_device_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                72usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_class_of_device(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(73usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_class_of_device(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(73usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_class_of_device_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                73usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_class_of_device_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                73usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_voice_setting(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(74usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_voice_setting(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(74usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_voice_setting_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                74usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_voice_setting_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                74usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_voice_setting(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(75usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_voice_setting(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(75usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_voice_setting_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                75usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_voice_setting_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                75usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_automatic_flush_timeout(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(76usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_automatic_flush_timeout(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(76usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_automatic_flush_timeout_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                76usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_automatic_flush_timeout_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                76usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_automatic_flush_timeout(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(77usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_automatic_flush_timeout(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(77usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_automatic_flush_timeout_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                77usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_automatic_flush_timeout_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                77usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_num_broadcast_retransmissions(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(78usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_num_broadcast_retransmissions(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(78usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_num_broadcast_retransmissions_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                78usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_num_broadcast_retransmissions_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                78usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_num_broadcast_retransmissions(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(79usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_num_broadcast_retransmissions(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(79usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_num_broadcast_retransmissions_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                79usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_num_broadcast_retransmissions_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                79usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_hold_mode_activity(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(80usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_hold_mode_activity(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(80usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_hold_mode_activity_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                80usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_hold_mode_activity_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                80usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_hold_mode_activity(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(81usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_hold_mode_activity(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(81usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_hold_mode_activity_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                81usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_hold_mode_activity_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                81usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_transmit_power_level(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(82usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_transmit_power_level(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(82usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_transmit_power_level_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                82usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_transmit_power_level_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                82usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_synchronous_flow_control_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(83usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_synchronous_flow_control_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(83usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_synchronous_flow_control_enable_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                83usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_synchronous_flow_control_enable_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                83usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_synchronous_flow_control_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(84usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_synchronous_flow_control_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(84usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_synchronous_flow_control_enable_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                84usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_synchronous_flow_control_enable_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                84usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_set_controller_to_host_flow_control(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(85usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_controller_to_host_flow_control(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(85usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_set_controller_to_host_flow_control_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                85usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_set_controller_to_host_flow_control_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                85usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_host_buffer_size(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(86usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_host_buffer_size(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(86usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_host_buffer_size_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                86usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_host_buffer_size_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                86usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_host_number_of_completed_packets(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(87usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_host_number_of_completed_packets(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(87usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_host_number_of_completed_packets_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                87usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_host_number_of_completed_packets_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                87usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_link_supervision_timeout(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(88usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_link_supervision_timeout(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(88usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_link_supervision_timeout_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                88usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_link_supervision_timeout_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                88usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_link_supervision_timeout(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(89usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_link_supervision_timeout(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(89usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_link_supervision_timeout_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                89usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_link_supervision_timeout_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                89usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_number_of_supported_iac(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(90usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_number_of_supported_iac(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(90usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_number_of_supported_iac_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                90usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_number_of_supported_iac_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                90usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_current_iac_lap(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(91usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_current_iac_lap(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(91usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_current_iac_lap_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                91usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_current_iac_lap_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                91usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_current_iac_lap(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(92usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_current_iac_lap(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(92usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_current_iac_lap_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                92usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_current_iac_lap_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                92usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used_11_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(93usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_11_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(93usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used_11_5_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                93usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used_11_5_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                93usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used_11_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(94usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_11_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(94usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used_11_6_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                94usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used_11_6_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                94usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used_11_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(95usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_11_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(95usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used_11_7_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                95usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used_11_7_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                95usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used_12_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(96usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_12_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(96usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used_12_0_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                96usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used_12_0_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                96usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_set_afh_host_channel_classification(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(97usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_afh_host_channel_classification(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(97usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_set_afh_host_channel_classification_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                97usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_set_afh_host_channel_classification_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                97usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_cs_read_remote_fae_table(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(98usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_cs_read_remote_fae_table(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(98usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_cs_read_remote_fae_table_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                98usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_cs_read_remote_fae_table_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                98usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_cs_write_cached_remote_fae_table(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(99usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_cs_write_cached_remote_fae_table(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(99usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_cs_write_cached_remote_fae_table_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                99usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_cs_write_cached_remote_fae_table_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                99usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_inquiry_scan_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(100usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_inquiry_scan_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(100usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_inquiry_scan_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                100usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_inquiry_scan_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                100usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_inquiry_scan_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(101usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_inquiry_scan_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(101usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_inquiry_scan_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                101usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_inquiry_scan_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                101usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_inquiry_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(102usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_inquiry_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(102usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_inquiry_mode_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                102usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_inquiry_mode_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                102usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_inquiry_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(103usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_inquiry_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(103usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_inquiry_mode_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                103usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_inquiry_mode_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                103usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_page_scan_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(104usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_page_scan_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(104usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_page_scan_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                104usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_page_scan_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                104usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_page_scan_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(105usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_page_scan_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(105usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_page_scan_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                105usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_page_scan_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                105usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_afh_channel_assessment_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(106usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_afh_channel_assessment_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(106usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_afh_channel_assessment_mode_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                106usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_afh_channel_assessment_mode_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                106usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_afh_channel_assessment_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(107usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_afh_channel_assessment_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(107usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_afh_channel_assessment_mode_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                107usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_afh_channel_assessment_mode_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                107usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu_13_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(108usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_13_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(108usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu_13_4_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                108usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu_13_4_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                108usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu_13_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(109usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_13_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(109usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu_13_5_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                109usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu_13_5_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                109usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu_13_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(110usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_13_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(110usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu_13_6_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                110usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu_13_6_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                110usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu_13_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(111usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_13_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(111usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu_13_7_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                111usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu_13_7_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                111usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu_14_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(112usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_14_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(112usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu_14_0_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                112usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu_14_0_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                112usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu_14_1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(113usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_14_1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(113usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu_14_1_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                113usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu_14_1_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                113usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu_14_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(114usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_14_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(114usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu_14_2_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                114usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu_14_2_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                114usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_local_version_information(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(115usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_local_version_information(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(115usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_local_version_information_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                115usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_local_version_information_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                115usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu_14_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(116usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_14_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(116usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu_14_4_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                116usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu_14_4_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                116usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_local_supported_features(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(117usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_local_supported_features(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(117usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_local_supported_features_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                117usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_local_supported_features_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                117usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_local_extended_features(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(118usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_local_extended_features(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(118usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_local_extended_features_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                118usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_local_extended_features_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                118usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_buffer_size(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(119usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_buffer_size(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(119usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_buffer_size_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                119usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_buffer_size_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                119usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used_15_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(120usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_15_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(120usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used_15_0_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                120usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used_15_0_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                120usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_bd_addr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(121usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_bd_addr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(121usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_bd_addr_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                121usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_bd_addr_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                121usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_failed_contact_counter(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(122usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_failed_contact_counter(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(122usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_failed_contact_counter_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                122usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_failed_contact_counter_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                122usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_reset_failed_contact_counter(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(123usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_reset_failed_contact_counter(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(123usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_reset_failed_contact_counter_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                123usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_reset_failed_contact_counter_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                123usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_link_quality(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(124usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_link_quality(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(124usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_link_quality_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                124usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_link_quality_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                124usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_rssi(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(125usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_rssi(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(125usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_rssi_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                125usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_rssi_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                125usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_afh_channel_map(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(126usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_afh_channel_map(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(126usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_afh_channel_map_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                126usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_afh_channel_map_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                126usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_clock(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(127usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_clock(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(127usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_clock_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                127usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_clock_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                127usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_loopback_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(128usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_loopback_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(128usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_loopback_mode_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                128usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_loopback_mode_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                128usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_loopback_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(129usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_loopback_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(129usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_loopback_mode_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                129usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_loopback_mode_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                129usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_enable_implementation_under_test_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(130usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_enable_implementation_under_test_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(130usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_enable_implementation_under_test_mode_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                130usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_enable_implementation_under_test_mode_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                130usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_setup_synchronous_connection_request(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(131usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_setup_synchronous_connection_request(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(131usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_setup_synchronous_connection_request_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                131usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_setup_synchronous_connection_request_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                131usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_accept_synchronous_connection_request(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(132usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_accept_synchronous_connection_request(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(132usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_accept_synchronous_connection_request_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                132usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_accept_synchronous_connection_request_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                132usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_reject_synchronous_connection_request(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(133usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_reject_synchronous_connection_request(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(133usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_reject_synchronous_connection_request_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                133usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_reject_synchronous_connection_request_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                133usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_cs_create_config(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(134usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_cs_create_config(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(134usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_cs_create_config_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                134usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_cs_create_config_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                134usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_cs_remove_config(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(135usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_cs_remove_config(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(135usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_cs_remove_config_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                135usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_cs_remove_config_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                135usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_extended_inquiry_response(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(136usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_extended_inquiry_response(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(136usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_extended_inquiry_response_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                136usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_extended_inquiry_response_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                136usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_extended_inquiry_response(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(137usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_extended_inquiry_response(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(137usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_extended_inquiry_response_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                137usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_extended_inquiry_response_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                137usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_refresh_encryption_key(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(138usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_refresh_encryption_key(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(138usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_refresh_encryption_key_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                138usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_refresh_encryption_key_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                138usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu_17_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(139usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_17_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(139usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu_17_3_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                139usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu_17_3_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                139usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_sniff_subrating(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(140usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_sniff_subrating(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(140usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_sniff_subrating_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                140usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_sniff_subrating_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                140usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_simple_pairing_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(141usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_simple_pairing_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(141usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_simple_pairing_mode_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                141usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_simple_pairing_mode_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                141usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_simple_pairing_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(142usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_simple_pairing_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(142usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_simple_pairing_mode_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                142usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_simple_pairing_mode_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                142usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_local_oob_data(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(143usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_local_oob_data(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(143usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_local_oob_data_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                143usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_local_oob_data_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                143usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_inquiry_response_transmit_power_level(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(144usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_inquiry_response_transmit_power_level(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(144usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_inquiry_response_transmit_power_level_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                144usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_inquiry_response_transmit_power_level_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                144usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_inquiry_transmit_power_level(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(145usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_inquiry_transmit_power_level(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(145usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_inquiry_transmit_power_level_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                145usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_inquiry_transmit_power_level_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                145usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_default_erroneous_data_reporting(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(146usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_default_erroneous_data_reporting(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(146usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_default_erroneous_data_reporting_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                146usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_default_erroneous_data_reporting_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                146usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_default_erroneous_data_reporting(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(147usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_default_erroneous_data_reporting(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(147usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_default_erroneous_data_reporting_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                147usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_default_erroneous_data_reporting_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                147usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu_18_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(148usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_18_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(148usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu_18_4_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                148usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu_18_4_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                148usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu_18_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(149usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_18_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(149usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu_18_5_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                149usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu_18_5_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                149usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu_18_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(150usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_18_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(150usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu_18_6_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                150usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu_18_6_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                150usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_io_capability_request_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(151usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_io_capability_request_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(151usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_io_capability_request_reply_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                151usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_io_capability_request_reply_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                151usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_user_confirmation_request_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(152usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_user_confirmation_request_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(152usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_user_confirmation_request_reply_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                152usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_user_confirmation_request_reply_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                152usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_user_confirmation_request_negative_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(153usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_user_confirmation_request_negative_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(153usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_user_confirmation_request_negative_reply_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                153usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_user_confirmation_request_negative_reply_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                153usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_user_passkey_request_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(154usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_user_passkey_request_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(154usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_user_passkey_request_reply_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                154usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_user_passkey_request_reply_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                154usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_user_passkey_request_negative_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(155usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_user_passkey_request_negative_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(155usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_user_passkey_request_negative_reply_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                155usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_user_passkey_request_negative_reply_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                155usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_remote_oob_data_request_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(156usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_remote_oob_data_request_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(156usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_remote_oob_data_request_reply_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                156usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_remote_oob_data_request_reply_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                156usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_simple_pairing_debug_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(157usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_simple_pairing_debug_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(157usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_simple_pairing_debug_mode_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                157usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_simple_pairing_debug_mode_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                157usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_enhanced_flush(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(158usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_enhanced_flush(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(158usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_enhanced_flush_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                158usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_enhanced_flush_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                158usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_remote_oob_data_request_negative_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(159usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_remote_oob_data_request_negative_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(159usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_remote_oob_data_request_negative_reply_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                159usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_remote_oob_data_request_negative_reply_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                159usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu_20_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(160usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_20_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(160usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu_20_0_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                160usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu_20_0_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                160usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu_20_1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(161usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_20_1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(161usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu_20_1_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                161usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu_20_1_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                161usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_send_keypress_notification(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(162usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_send_keypress_notification(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(162usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_send_keypress_notification_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                162usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_send_keypress_notification_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                162usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_io_capability_request_negative_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(163usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_io_capability_request_negative_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(163usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_io_capability_request_negative_reply_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                163usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_io_capability_request_negative_reply_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                163usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_encryption_key_size(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(164usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_encryption_key_size(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(164usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_encryption_key_size_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                164usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_encryption_key_size_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                164usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_cs_read_local_supported_capabilities(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(165usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_cs_read_local_supported_capabilities(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(165usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_cs_read_local_supported_capabilities_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                165usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_cs_read_local_supported_capabilities_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                165usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_cs_read_remote_supported_capabilities(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(166usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_cs_read_remote_supported_capabilities(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(166usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_cs_read_remote_supported_capabilities_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                166usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_cs_read_remote_supported_capabilities_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                166usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_cs_write_cached_remote_supported_capabilities(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(167usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_cs_write_cached_remote_supported_capabilities(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(167usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_cs_write_cached_remote_supported_capabilities_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                167usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_cs_write_cached_remote_supported_capabilities_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                167usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used_21_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(168usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_21_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(168usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used_21_0_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                168usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used_21_0_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                168usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used_21_1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(169usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_21_1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(169usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used_21_1_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                169usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used_21_1_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                169usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used_21_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(170usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_21_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(170usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used_21_2_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                170usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used_21_2_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                170usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used_21_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(171usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_21_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(171usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used_21_3_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                171usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used_21_3_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                171usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used_21_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(172usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_21_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(172usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used_21_4_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                172usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used_21_4_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                172usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used_21_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(173usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_21_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(173usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used_21_5_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                173usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used_21_5_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                173usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used_21_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(174usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_21_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(174usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used_21_6_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                174usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used_21_6_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                174usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used_21_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(175usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_21_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(175usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used_21_7_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                175usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used_21_7_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                175usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used_22_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(176usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_22_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(176usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used_22_0_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                176usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used_22_0_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                176usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used_22_1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(177usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_22_1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(177usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used_22_1_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                177usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used_22_1_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                177usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_set_event_mask_page_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(178usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_event_mask_page_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(178usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_set_event_mask_page_2_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                178usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_set_event_mask_page_2_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                178usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used_22_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(179usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_22_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(179usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used_22_3_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                179usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used_22_3_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                179usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used_22_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(180usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_22_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(180usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used_22_4_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                180usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used_22_4_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                180usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used_22_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(181usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_22_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(181usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used_22_5_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                181usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used_22_5_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                181usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used_22_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(182usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_22_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(182usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used_22_6_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                182usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used_22_6_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                182usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used_22_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(183usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_22_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(183usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used_22_7_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                183usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used_22_7_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                183usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_flow_control_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(184usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_flow_control_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(184usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_flow_control_mode_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                184usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_flow_control_mode_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                184usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_flow_control_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(185usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_flow_control_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(185usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_flow_control_mode_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                185usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_flow_control_mode_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                185usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_data_block_size(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(186usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_data_block_size(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(186usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_data_block_size_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                186usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_data_block_size_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                186usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_cs_test(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(187usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_cs_test(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(187usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_cs_test_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                187usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_cs_test_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                187usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_cs_test_end(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(188usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_cs_test_end(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(188usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_cs_test_end_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                188usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_cs_test_end_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                188usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used_23_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(189usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_23_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(189usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used_23_5_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                189usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used_23_5_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                189usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used_23_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(190usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_23_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(190usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used_23_6_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                190usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used_23_6_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                190usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used_23_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(191usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_23_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(191usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used_23_7_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                191usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used_23_7_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                191usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_enhanced_transmit_power_level(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(192usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_enhanced_transmit_power_level(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(192usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_enhanced_transmit_power_level_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                192usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_enhanced_transmit_power_level_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                192usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_cs_security_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(193usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_cs_security_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(193usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_cs_security_enable_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                193usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_cs_security_enable_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                193usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used_24_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(194usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_24_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(194usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used_24_2_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                194usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used_24_2_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                194usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used_24_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(195usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_24_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(195usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used_24_3_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                195usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used_24_3_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                195usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn previously_used_24_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(196usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_24_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(196usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn previously_used_24_4_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                196usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_previously_used_24_4_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                196usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_le_host_support(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(197usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_le_host_support(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(197usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_le_host_support_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                197usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_le_host_support_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                197usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_le_host_support(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(198usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_le_host_support(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(198usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_le_host_support_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                198usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_le_host_support_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                198usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_cs_set_default_settings(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(199usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_cs_set_default_settings(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(199usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_cs_set_default_settings_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                199usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_cs_set_default_settings_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                199usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_event_mask(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(200usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_event_mask(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(200usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_event_mask_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                200usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_event_mask_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                200usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_read_buffer_size_v1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(201usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_buffer_size_v1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(201usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_read_buffer_size_v1_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                201usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_read_buffer_size_v1_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                201usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_read_local_supported_features(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(202usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_local_supported_features(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(202usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_read_local_supported_features_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                202usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_read_local_supported_features_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                202usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu_25_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(203usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_25_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(203usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu_25_3_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                203usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu_25_3_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                203usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_random_address(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(204usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_random_address(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(204usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_random_address_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                204usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_random_address_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                204usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_advertising_parameters(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(205usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_advertising_parameters(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(205usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_advertising_parameters_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                205usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_advertising_parameters_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                205usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_read_advertising_physical_channel_tx_power(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(206usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_advertising_physical_channel_tx_power(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(206usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_read_advertising_physical_channel_tx_power_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                206usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_read_advertising_physical_channel_tx_power_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                206usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_advertising_data(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(207usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_advertising_data(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(207usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_advertising_data_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                207usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_advertising_data_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                207usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_scan_response_data(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(208usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_scan_response_data(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(208usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_scan_response_data_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                208usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_scan_response_data_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                208usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_advertising_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(209usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_advertising_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(209usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_advertising_enable_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                209usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_advertising_enable_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                209usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_scan_parameters(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(210usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_scan_parameters(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(210usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_scan_parameters_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                210usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_scan_parameters_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                210usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_scan_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(211usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_scan_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(211usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_scan_enable_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                211usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_scan_enable_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                211usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_create_connection(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(212usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_create_connection(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(212usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_create_connection_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                212usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_create_connection_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                212usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_create_connection_cancel(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(213usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_create_connection_cancel(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(213usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_create_connection_cancel_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                213usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_create_connection_cancel_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                213usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_read_filter_accept_list_size(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(214usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_filter_accept_list_size(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(214usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_read_filter_accept_list_size_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                214usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_read_filter_accept_list_size_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                214usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_clear_filter_accept_list(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(215usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_clear_filter_accept_list(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(215usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_clear_filter_accept_list_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                215usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_clear_filter_accept_list_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                215usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_add_device_to_filter_accept_list(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(216usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_add_device_to_filter_accept_list(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(216usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_add_device_to_filter_accept_list_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                216usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_add_device_to_filter_accept_list_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                216usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_remove_device_from_filter_accept_list(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(217usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_remove_device_from_filter_accept_list(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(217usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_remove_device_from_filter_accept_list_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                217usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_remove_device_from_filter_accept_list_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                217usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_connection_update(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(218usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_connection_update(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(218usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_connection_update_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                218usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_connection_update_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                218usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_host_channel_classification(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(219usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_host_channel_classification(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(219usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_host_channel_classification_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                219usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_host_channel_classification_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                219usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_read_channel_map(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(220usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_channel_map(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(220usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_read_channel_map_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                220usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_read_channel_map_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                220usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_read_remote_features(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(221usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_remote_features(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(221usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_read_remote_features_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                221usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_read_remote_features_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                221usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_encrypt(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(222usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_encrypt(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(222usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_encrypt_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                222usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_encrypt_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                222usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_rand(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(223usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_rand(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(223usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_rand_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                223usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_rand_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                223usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_enable_encryption(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(224usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_enable_encryption(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(224usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_enable_encryption_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                224usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_enable_encryption_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                224usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_long_term_key_request_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(225usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_long_term_key_request_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(225usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_long_term_key_request_reply_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                225usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_long_term_key_request_reply_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                225usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_long_term_key_request_negative_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(226usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_long_term_key_request_negative_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(226usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_long_term_key_request_negative_reply_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                226usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_long_term_key_request_negative_reply_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                226usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_read_supported_states(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(227usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_supported_states(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(227usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_read_supported_states_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                227usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_read_supported_states_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                227usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_receiver_test_v1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(228usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_receiver_test_v1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(228usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_receiver_test_v1_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                228usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_receiver_test_v1_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                228usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_transmitter_test_v1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(229usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_transmitter_test_v1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(229usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_transmitter_test_v1_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                229usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_transmitter_test_v1_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                229usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_test_end(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(230usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_test_end(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(230usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_test_end_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                230usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_test_end_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                230usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_enable_monitoring_advertisers(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(231usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_enable_monitoring_advertisers(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(231usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_enable_monitoring_advertisers_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                231usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_enable_monitoring_advertisers_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                231usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_cs_set_channel_classification(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(232usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_cs_set_channel_classification(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(232usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_cs_set_channel_classification_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                232usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_cs_set_channel_classification_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                232usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_cs_set_procedure_parameters(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(233usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_cs_set_procedure_parameters(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(233usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_cs_set_procedure_parameters_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                233usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_cs_set_procedure_parameters_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                233usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_cs_procedure_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(234usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_cs_procedure_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(234usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_cs_procedure_enable_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                234usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_cs_procedure_enable_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                234usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_enhanced_setup_synchronous_connection(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(235usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_enhanced_setup_synchronous_connection(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(235usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_enhanced_setup_synchronous_connection_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                235usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_enhanced_setup_synchronous_connection_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                235usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_enhanced_accept_synchronous_connection(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(236usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_enhanced_accept_synchronous_connection(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(236usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_enhanced_accept_synchronous_connection_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                236usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_enhanced_accept_synchronous_connection_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                236usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_local_supported_codecs(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(237usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_local_supported_codecs(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(237usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_local_supported_codecs_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                237usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_local_supported_codecs_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                237usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_set_mws_channel_parameters(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(238usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_mws_channel_parameters(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(238usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_set_mws_channel_parameters_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                238usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_set_mws_channel_parameters_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                238usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_set_external_frame_configuration(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(239usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_external_frame_configuration(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(239usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_set_external_frame_configuration_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                239usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_set_external_frame_configuration_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                239usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_set_mws_signaling(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(240usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_mws_signaling(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(240usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_set_mws_signaling_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                240usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_set_mws_signaling_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                240usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_set_mws_transport_layer(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(241usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_mws_transport_layer(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(241usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_set_mws_transport_layer_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                241usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_set_mws_transport_layer_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                241usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_set_mws_scan_frequency_table(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(242usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_mws_scan_frequency_table(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(242usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_set_mws_scan_frequency_table_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                242usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_set_mws_scan_frequency_table_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                242usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_get_mws_transport_layer_configuration(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(243usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_get_mws_transport_layer_configuration(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(243usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_get_mws_transport_layer_configuration_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                243usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_get_mws_transport_layer_configuration_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                243usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_set_mws_pattern_configuration(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(244usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_mws_pattern_configuration(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(244usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_set_mws_pattern_configuration_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                244usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_set_mws_pattern_configuration_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                244usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_set_triggered_clock_capture(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(245usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_triggered_clock_capture(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(245usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_set_triggered_clock_capture_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                245usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_set_triggered_clock_capture_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                245usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_truncated_page(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(246usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_truncated_page(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(246usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_truncated_page_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                246usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_truncated_page_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                246usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_truncated_page_cancel(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(247usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_truncated_page_cancel(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(247usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_truncated_page_cancel_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                247usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_truncated_page_cancel_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                247usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_set_connectionless_peripheral_broadcast(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(248usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_connectionless_peripheral_broadcast(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(248usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_set_connectionless_peripheral_broadcast_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                248usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_set_connectionless_peripheral_broadcast_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                248usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_set_connectionless_peripheral_broadcast_receive(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(249usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_connectionless_peripheral_broadcast_receive(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(249usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_set_connectionless_peripheral_broadcast_receive_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                249usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_set_connectionless_peripheral_broadcast_receive_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                249usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_start_synchronization_train(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(250usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_start_synchronization_train(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(250usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_start_synchronization_train_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                250usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_start_synchronization_train_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                250usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_receive_synchronization_train(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(251usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_receive_synchronization_train(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(251usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_receive_synchronization_train_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                251usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_receive_synchronization_train_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                251usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_set_reserved_lt_addr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(252usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_reserved_lt_addr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(252usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_set_reserved_lt_addr_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                252usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_set_reserved_lt_addr_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                252usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_delete_reserved_lt_addr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(253usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_delete_reserved_lt_addr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(253usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_delete_reserved_lt_addr_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                253usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_delete_reserved_lt_addr_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                253usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_set_connectionless_peripheral_broadcast_data(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(254usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_connectionless_peripheral_broadcast_data(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(254usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_set_connectionless_peripheral_broadcast_data_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                254usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_set_connectionless_peripheral_broadcast_data_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                254usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_synchronization_train_parameters(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(255usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_synchronization_train_parameters(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(255usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_synchronization_train_parameters_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                255usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_synchronization_train_parameters_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                255usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_synchronization_train_parameters(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(256usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_synchronization_train_parameters(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(256usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_synchronization_train_parameters_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                256usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_synchronization_train_parameters_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                256usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_remote_oob_extended_data_request_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(257usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_remote_oob_extended_data_request_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(257usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_remote_oob_extended_data_request_reply_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                257usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_remote_oob_extended_data_request_reply_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                257usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_secure_connections_host_support(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(258usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_secure_connections_host_support(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(258usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_secure_connections_host_support_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                258usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_secure_connections_host_support_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                258usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_secure_connections_host_support(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(259usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_secure_connections_host_support(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(259usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_secure_connections_host_support_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                259usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_secure_connections_host_support_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                259usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_authenticated_payload_timeout(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(260usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_authenticated_payload_timeout(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(260usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_authenticated_payload_timeout_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                260usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_authenticated_payload_timeout_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                260usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_authenticated_payload_timeout(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(261usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_authenticated_payload_timeout(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(261usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_authenticated_payload_timeout_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                261usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_authenticated_payload_timeout_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                261usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_local_oob_extended_data(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(262usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_local_oob_extended_data(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(262usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_local_oob_extended_data_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                262usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_local_oob_extended_data_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                262usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_secure_connections_test_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(263usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_secure_connections_test_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(263usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_secure_connections_test_mode_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                263usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_secure_connections_test_mode_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                263usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_extended_page_timeout(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(264usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_extended_page_timeout(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(264usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_extended_page_timeout_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                264usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_extended_page_timeout_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                264usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_extended_page_timeout(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(265usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_extended_page_timeout(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(265usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_extended_page_timeout_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                265usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_extended_page_timeout_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                265usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_extended_inquiry_length(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(266usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_extended_inquiry_length(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(266usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_extended_inquiry_length_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                266usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_extended_inquiry_length_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                266usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_write_extended_inquiry_length(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(267usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_extended_inquiry_length(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(267usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_write_extended_inquiry_length_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                267usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_write_extended_inquiry_length_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                267usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_remote_connection_parameter_request_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(268usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_remote_connection_parameter_request_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(268usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_remote_connection_parameter_request_reply_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                268usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_remote_connection_parameter_request_reply_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                268usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_remote_connection_parameter_request_negative_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(269usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_remote_connection_parameter_request_negative_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(269usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_remote_connection_parameter_request_negative_reply_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                269usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_remote_connection_parameter_request_negative_reply_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                269usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_data_length(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(270usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_data_length(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(270usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_data_length_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                270usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_data_length_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                270usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_read_suggested_default_data_length(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(271usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_suggested_default_data_length(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(271usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_read_suggested_default_data_length_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                271usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_read_suggested_default_data_length_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                271usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_write_suggested_default_data_length(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(272usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_write_suggested_default_data_length(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(272usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_write_suggested_default_data_length_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                272usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_write_suggested_default_data_length_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                272usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_read_local_p256_public_key(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(273usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_local_p256_public_key(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(273usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_read_local_p256_public_key_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                273usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_read_local_p256_public_key_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                273usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_generate_dhkey_v1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(274usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_generate_dhkey_v1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(274usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_generate_dhkey_v1_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                274usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_generate_dhkey_v1_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                274usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_add_device_to_resolving_list(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(275usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_add_device_to_resolving_list(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(275usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_add_device_to_resolving_list_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                275usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_add_device_to_resolving_list_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                275usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_remove_device_from_resolving_list(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(276usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_remove_device_from_resolving_list(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(276usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_remove_device_from_resolving_list_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                276usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_remove_device_from_resolving_list_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                276usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_clear_resolving_list(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(277usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_clear_resolving_list(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(277usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_clear_resolving_list_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                277usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_clear_resolving_list_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                277usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_read_resolving_list_size(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(278usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_resolving_list_size(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(278usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_read_resolving_list_size_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                278usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_read_resolving_list_size_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                278usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_read_peer_resolvable_address(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(279usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_peer_resolvable_address(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(279usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_read_peer_resolvable_address_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                279usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_read_peer_resolvable_address_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                279usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_read_local_resolvable_address(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(280usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_local_resolvable_address(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(280usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_read_local_resolvable_address_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                280usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_read_local_resolvable_address_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                280usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_address_resolution_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(281usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_address_resolution_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(281usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_address_resolution_enable_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                281usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_address_resolution_enable_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                281usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_resolvable_private_address_timeout(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(282usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_resolvable_private_address_timeout(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(282usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_resolvable_private_address_timeout_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                282usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_resolvable_private_address_timeout_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                282usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_read_maximum_data_length(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(283usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_maximum_data_length(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(283usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_read_maximum_data_length_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                283usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_read_maximum_data_length_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                283usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_read_phy(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(284usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_phy(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(284usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_read_phy_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                284usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_read_phy_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                284usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_default_phy(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(285usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_default_phy(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(285usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_default_phy_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                285usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_default_phy_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                285usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_phy(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(286usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_phy(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(286usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_phy_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                286usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_phy_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                286usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_receiver_test_v2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(287usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_receiver_test_v2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(287usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_receiver_test_v2_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                287usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_receiver_test_v2_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                287usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_transmitter_test_v2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(288usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_transmitter_test_v2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(288usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_transmitter_test_v2_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                288usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_transmitter_test_v2_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                288usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_advertising_set_random_address(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(289usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_advertising_set_random_address(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(289usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_advertising_set_random_address_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                289usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_advertising_set_random_address_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                289usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_extended_advertising_parameters(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(290usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_extended_advertising_parameters(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(290usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_extended_advertising_parameters_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                290usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_extended_advertising_parameters_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                290usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_extended_advertising_data(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(291usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_extended_advertising_data(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(291usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_extended_advertising_data_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                291usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_extended_advertising_data_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                291usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_extended_scan_response_data(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(292usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_extended_scan_response_data(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(292usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_extended_scan_response_data_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                292usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_extended_scan_response_data_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                292usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_extended_advertising_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(293usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_extended_advertising_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(293usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_extended_advertising_enable_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                293usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_extended_advertising_enable_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                293usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_read_maximum_advertising_data_length(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(294usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_maximum_advertising_data_length(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(294usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_read_maximum_advertising_data_length_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                294usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_read_maximum_advertising_data_length_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                294usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_read_number_of_supported_advertising_sets(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(295usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_number_of_supported_advertising_sets(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(295usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_read_number_of_supported_advertising_sets_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                295usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_read_number_of_supported_advertising_sets_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                295usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_remove_advertising_set(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(296usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_remove_advertising_set(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(296usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_remove_advertising_set_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                296usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_remove_advertising_set_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                296usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_clear_advertising_sets(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(297usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_clear_advertising_sets(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(297usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_clear_advertising_sets_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                297usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_clear_advertising_sets_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                297usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_periodic_advertising_parameters(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(298usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_periodic_advertising_parameters(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(298usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_periodic_advertising_parameters_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                298usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_periodic_advertising_parameters_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                298usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_periodic_advertising_data(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(299usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_periodic_advertising_data(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(299usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_periodic_advertising_data_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                299usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_periodic_advertising_data_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                299usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_periodic_advertising_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(300usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_periodic_advertising_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(300usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_periodic_advertising_enable_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                300usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_periodic_advertising_enable_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                300usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_extended_scan_parameters(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(301usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_extended_scan_parameters(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(301usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_extended_scan_parameters_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                301usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_extended_scan_parameters_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                301usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_extended_scan_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(302usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_extended_scan_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(302usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_extended_scan_enable_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                302usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_extended_scan_enable_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                302usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_extended_create_connection(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(303usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_extended_create_connection(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(303usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_extended_create_connection_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                303usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_extended_create_connection_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                303usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_periodic_advertising_create_sync(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(304usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_periodic_advertising_create_sync(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(304usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_periodic_advertising_create_sync_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                304usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_periodic_advertising_create_sync_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                304usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_periodic_advertising_create_sync_cancel(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(305usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_periodic_advertising_create_sync_cancel(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(305usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_periodic_advertising_create_sync_cancel_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                305usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_periodic_advertising_create_sync_cancel_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                305usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_periodic_advertising_terminate_sync(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(306usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_periodic_advertising_terminate_sync(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(306usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_periodic_advertising_terminate_sync_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                306usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_periodic_advertising_terminate_sync_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                306usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_add_device_to_periodic_advertiser_list(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(307usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_add_device_to_periodic_advertiser_list(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(307usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_add_device_to_periodic_advertiser_list_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                307usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_add_device_to_periodic_advertiser_list_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                307usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_remove_device_from_periodic_advertiser_list(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(308usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_remove_device_from_periodic_advertiser_list(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(308usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_remove_device_from_periodic_advertiser_list_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                308usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_remove_device_from_periodic_advertiser_list_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                308usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_clear_periodic_advertiser_list(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(309usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_clear_periodic_advertiser_list(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(309usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_clear_periodic_advertiser_list_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                309usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_clear_periodic_advertiser_list_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                309usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_read_periodic_advertiser_list_size(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(310usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_periodic_advertiser_list_size(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(310usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_read_periodic_advertiser_list_size_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                310usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_read_periodic_advertiser_list_size_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                310usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_read_transmit_power(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(311usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_transmit_power(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(311usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_read_transmit_power_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                311usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_read_transmit_power_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                311usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_read_rf_path_compensation(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(312usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_rf_path_compensation(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(312usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_read_rf_path_compensation_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                312usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_read_rf_path_compensation_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                312usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_write_rf_path_compensation(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(313usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_write_rf_path_compensation(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(313usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_write_rf_path_compensation_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                313usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_write_rf_path_compensation_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                313usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_privacy_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(314usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_privacy_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(314usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_privacy_mode_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                314usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_privacy_mode_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                314usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_receiver_test_v3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(315usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_receiver_test_v3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(315usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_receiver_test_v3_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                315usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_receiver_test_v3_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                315usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_transmitter_test_v3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(316usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_transmitter_test_v3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(316usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_transmitter_test_v3_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                316usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_transmitter_test_v3_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                316usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_connectionless_cte_transmit_parameters(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(317usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_connectionless_cte_transmit_parameters(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(317usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_connectionless_cte_transmit_parameters_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                317usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_connectionless_cte_transmit_parameters_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                317usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_connectionless_cte_transmit_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(318usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_connectionless_cte_transmit_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(318usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_connectionless_cte_transmit_enable_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                318usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_connectionless_cte_transmit_enable_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                318usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_connectionless_iq_sampling_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(319usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_connectionless_iq_sampling_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(319usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_connectionless_iq_sampling_enable_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                319usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_connectionless_iq_sampling_enable_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                319usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_connection_cte_receive_parameters(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(320usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_connection_cte_receive_parameters(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(320usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_connection_cte_receive_parameters_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                320usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_connection_cte_receive_parameters_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                320usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_connection_cte_transmit_parameters(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(321usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_connection_cte_transmit_parameters(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(321usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_connection_cte_transmit_parameters_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                321usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_connection_cte_transmit_parameters_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                321usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_connection_cte_request_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(322usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_connection_cte_request_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(322usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_connection_cte_request_enable_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                322usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_connection_cte_request_enable_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                322usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_connection_cte_response_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(323usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_connection_cte_response_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(323usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_connection_cte_response_enable_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                323usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_connection_cte_response_enable_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                323usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_read_antenna_information(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(324usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_antenna_information(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(324usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_read_antenna_information_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                324usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_read_antenna_information_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                324usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_periodic_advertising_receive_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(325usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_periodic_advertising_receive_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(325usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_periodic_advertising_receive_enable_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                325usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_periodic_advertising_receive_enable_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                325usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_periodic_advertising_sync_transfer(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(326usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_periodic_advertising_sync_transfer(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(326usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_periodic_advertising_sync_transfer_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                326usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_periodic_advertising_sync_transfer_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                326usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_periodic_advertising_set_info_transfer(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(327usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_periodic_advertising_set_info_transfer(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(327usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_periodic_advertising_set_info_transfer_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                327usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_periodic_advertising_set_info_transfer_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                327usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_periodic_advertising_sync_transfer_parameters(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(328usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_periodic_advertising_sync_transfer_parameters(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(328usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_periodic_advertising_sync_transfer_parameters_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                328usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_periodic_advertising_sync_transfer_parameters_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                328usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_default_periodic_advertising_sync_transfer_parameters(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(329usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_default_periodic_advertising_sync_transfer_parameters(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(329usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_default_periodic_advertising_sync_transfer_parameters_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                329usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_default_periodic_advertising_sync_transfer_parameters_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                329usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_generate_dhkey_v2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(330usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_generate_dhkey_v2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(330usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_generate_dhkey_v2_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                330usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_generate_dhkey_v2_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                330usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_local_simple_pairing_options(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(331usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_local_simple_pairing_options(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(331usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_local_simple_pairing_options_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                331usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_local_simple_pairing_options_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                331usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_modify_sleep_clock_accuracy(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(332usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_modify_sleep_clock_accuracy(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(332usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_modify_sleep_clock_accuracy_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                332usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_modify_sleep_clock_accuracy_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                332usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_read_buffer_size_v2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(333usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_buffer_size_v2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(333usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_read_buffer_size_v2_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                333usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_read_buffer_size_v2_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                333usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_read_iso_tx_sync(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(334usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_iso_tx_sync(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(334usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_read_iso_tx_sync_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                334usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_read_iso_tx_sync_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                334usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_cig_parameters(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(335usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_cig_parameters(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(335usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_cig_parameters_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                335usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_cig_parameters_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                335usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_cig_parameters_test(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(336usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_cig_parameters_test(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(336usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_cig_parameters_test_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                336usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_cig_parameters_test_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                336usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_create_cis(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(337usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_create_cis(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(337usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_create_cis_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                337usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_create_cis_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                337usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_remove_cig(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(338usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_remove_cig(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(338usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_remove_cig_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                338usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_remove_cig_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                338usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_accept_cis_request(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(339usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_accept_cis_request(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(339usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_accept_cis_request_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                339usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_accept_cis_request_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                339usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_reject_cis_request(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(340usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_reject_cis_request(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(340usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_reject_cis_request_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                340usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_reject_cis_request_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                340usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_create_big(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(341usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_create_big(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(341usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_create_big_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                341usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_create_big_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                341usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_create_big_test(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(342usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_create_big_test(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(342usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_create_big_test_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                342usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_create_big_test_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                342usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_terminate_big(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(343usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_terminate_big(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(343usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_terminate_big_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                343usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_terminate_big_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                343usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_big_create_sync(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(344usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_big_create_sync(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(344usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_big_create_sync_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                344usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_big_create_sync_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                344usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_big_terminate_sync(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(345usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_big_terminate_sync(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(345usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_big_terminate_sync_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                345usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_big_terminate_sync_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                345usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_request_peer_sca(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(346usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_request_peer_sca(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(346usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_request_peer_sca_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                346usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_request_peer_sca_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                346usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_setup_iso_data_path(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(347usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_setup_iso_data_path(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(347usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_setup_iso_data_path_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                347usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_setup_iso_data_path_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                347usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_remove_iso_data_path(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(348usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_remove_iso_data_path(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(348usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_remove_iso_data_path_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                348usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_remove_iso_data_path_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                348usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_iso_transmit_test(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(349usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_iso_transmit_test(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(349usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_iso_transmit_test_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                349usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_iso_transmit_test_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                349usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_iso_receive_test(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(350usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_iso_receive_test(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(350usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_iso_receive_test_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                350usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_iso_receive_test_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                350usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_iso_read_test_counters(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(351usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_iso_read_test_counters(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(351usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_iso_read_test_counters_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                351usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_iso_read_test_counters_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                351usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_iso_test_end(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(352usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_iso_test_end(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(352usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_iso_test_end_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                352usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_iso_test_end_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                352usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_host_feature(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(353usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_host_feature(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(353usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_host_feature_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                353usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_host_feature_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                353usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_read_iso_link_quality(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(354usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_iso_link_quality(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(354usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_read_iso_link_quality_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                354usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_read_iso_link_quality_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                354usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_enhanced_read_transmit_power_level(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(355usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_enhanced_read_transmit_power_level(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(355usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_enhanced_read_transmit_power_level_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                355usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_enhanced_read_transmit_power_level_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                355usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_read_remote_transmit_power_level(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(356usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_remote_transmit_power_level(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(356usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_read_remote_transmit_power_level_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                356usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_read_remote_transmit_power_level_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                356usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_path_loss_reporting_parameters(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(357usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_path_loss_reporting_parameters(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(357usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_path_loss_reporting_parameters_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                357usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_path_loss_reporting_parameters_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                357usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_path_loss_reporting_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(358usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_path_loss_reporting_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(358usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_path_loss_reporting_enable_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                358usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_path_loss_reporting_enable_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                358usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_transmit_power_reporting_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(359usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_transmit_power_reporting_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(359usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_transmit_power_reporting_enable_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                359usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_transmit_power_reporting_enable_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                359usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_transmitter_test_v4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(360usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_transmitter_test_v4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(360usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_transmitter_test_v4_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                360usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_transmitter_test_v4_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                360usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_set_ecosystem_base_interval(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(361usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_ecosystem_base_interval(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(361usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_set_ecosystem_base_interval_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                361usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_set_ecosystem_base_interval_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                361usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_local_supported_codecs_v2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(362usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_local_supported_codecs_v2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(362usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_local_supported_codecs_v2_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                362usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_local_supported_codecs_v2_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                362usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_local_supported_codec_capabilities(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(363usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_local_supported_codec_capabilities(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(363usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_local_supported_codec_capabilities_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                363usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_local_supported_codec_capabilities_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                363usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_read_local_supported_controller_delay(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(364usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_local_supported_controller_delay(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(364usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_read_local_supported_controller_delay_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                364usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_read_local_supported_controller_delay_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                364usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_configure_data_path(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(365usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_configure_data_path(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(365usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_configure_data_path_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                365usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_configure_data_path_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                365usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_data_related_address_changes(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(366usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_data_related_address_changes(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(366usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_data_related_address_changes_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                366usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_data_related_address_changes_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                366usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_set_min_encryption_key_size(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(367usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_min_encryption_key_size(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(367usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_set_min_encryption_key_size_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                367usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_set_min_encryption_key_size_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                367usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_default_subrate_command(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(368usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_default_subrate_command(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(368usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_default_subrate_command_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                368usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_default_subrate_command_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                368usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_subrate_request_command(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(369usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_subrate_request_command(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(369usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_subrate_request_command_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                369usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_subrate_request_command_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                369usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_extended_advertising_parameters_v2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(370usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_extended_advertising_parameters_v2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(370usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_extended_advertising_parameters_v2_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                370usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_extended_advertising_parameters_v2_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                370usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_decision_data(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(371usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_decision_data(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(371usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_decision_data_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                371usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_decision_data_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                371usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_decision_instructions(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(372usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_decision_instructions(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(372usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_decision_instructions_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                372usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_decision_instructions_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                372usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_periodic_advertising_subevent_data(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(373usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_periodic_advertising_subevent_data(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(373usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_periodic_advertising_subevent_data_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                373usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_periodic_advertising_subevent_data_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                373usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_periodic_advertising_response_data(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(374usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_periodic_advertising_response_data(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(374usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_periodic_advertising_response_data_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                374usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_periodic_advertising_response_data_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                374usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_periodic_sync_subevent(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(375usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_periodic_sync_subevent(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(375usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_periodic_sync_subevent_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                375usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_periodic_sync_subevent_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                375usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_extended_create_connection_v2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(376usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_extended_create_connection_v2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(376usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_extended_create_connection_v2_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                376usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_extended_create_connection_v2_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                376usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_periodic_advertising_parameters_v2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(377usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_periodic_advertising_parameters_v2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(377usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_periodic_advertising_parameters_v2_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                377usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_periodic_advertising_parameters_v2_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                377usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_read_all_local_supported_features(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(378usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_all_local_supported_features(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(378usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_read_all_local_supported_features_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                378usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_read_all_local_supported_features_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                378usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_read_all_remote_features(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(379usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_all_remote_features(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(379usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_read_all_remote_features_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                379usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_read_all_remote_features_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                379usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_set_host_feature_v2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(380usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_host_feature_v2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(380usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_set_host_feature_v2_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                380usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_set_host_feature_v2_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                380usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_add_device_to_monitored_advertisers_list(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(381usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_add_device_to_monitored_advertisers_list(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(381usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_add_device_to_monitored_advertisers_list_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                381usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_add_device_to_monitored_advertisers_list_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                381usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_remove_device_from_monitored_advertisers_list(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(382usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_remove_device_from_monitored_advertisers_list(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(382usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_remove_device_from_monitored_advertisers_list_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                382usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_remove_device_from_monitored_advertisers_list_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                382usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_clear_monitored_advertisers_list(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(383usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_clear_monitored_advertisers_list(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(383usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_clear_monitored_advertisers_list_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                383usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_clear_monitored_advertisers_list_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                383usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_read_monitored_advertisers_list_size(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(384usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_monitored_advertisers_list_size(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(384usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_read_monitored_advertisers_list_size_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                384usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_read_monitored_advertisers_list_size_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                384usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hci_le_frame_space_update(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(385usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_frame_space_update(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(385usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hci_le_frame_space_update_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 49usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                385usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hci_le_frame_space_update_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 49usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                385usize,
                1u8,
                val as u64,
            )
        }
    }
}
#[doc = "Read Local Version Information return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_ip_read_local_version_information_return_t {
    pub hci_version: u8,
    pub hci_subversion: u16,
    pub lmp_version: u8,
    pub company_identifier: u16,
    pub lmp_subversion: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_ip_read_local_version_information_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_ip_read_local_version_information_return_t>() - 8usize];
    ["Alignment of sdc_hci_cmd_ip_read_local_version_information_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_ip_read_local_version_information_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_ip_read_local_version_information_return_t::hci_version"]
        [::core::mem::offset_of!(sdc_hci_cmd_ip_read_local_version_information_return_t, hci_version) - 0usize];
    ["Offset of field: sdc_hci_cmd_ip_read_local_version_information_return_t::hci_subversion"]
        [::core::mem::offset_of!(sdc_hci_cmd_ip_read_local_version_information_return_t, hci_subversion) - 1usize];
    ["Offset of field: sdc_hci_cmd_ip_read_local_version_information_return_t::lmp_version"]
        [::core::mem::offset_of!(sdc_hci_cmd_ip_read_local_version_information_return_t, lmp_version) - 3usize];
    ["Offset of field: sdc_hci_cmd_ip_read_local_version_information_return_t::company_identifier"][::core::mem::offset_of!(
        sdc_hci_cmd_ip_read_local_version_information_return_t,
        company_identifier
    ) - 4usize];
    ["Offset of field: sdc_hci_cmd_ip_read_local_version_information_return_t::lmp_subversion"]
        [::core::mem::offset_of!(sdc_hci_cmd_ip_read_local_version_information_return_t, lmp_subversion) - 6usize];
};
#[doc = "Read Local Supported Commands return parameter(s)."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union sdc_hci_cmd_ip_read_local_supported_commands_return_t {
    pub params: sdc_hci_ip_supported_commands_t,
    pub raw: [u8; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_ip_read_local_supported_commands_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_ip_read_local_supported_commands_return_t>() - 64usize];
    ["Alignment of sdc_hci_cmd_ip_read_local_supported_commands_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_ip_read_local_supported_commands_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_ip_read_local_supported_commands_return_t::params"]
        [::core::mem::offset_of!(sdc_hci_cmd_ip_read_local_supported_commands_return_t, params) - 0usize];
    ["Offset of field: sdc_hci_cmd_ip_read_local_supported_commands_return_t::raw"]
        [::core::mem::offset_of!(sdc_hci_cmd_ip_read_local_supported_commands_return_t, raw) - 0usize];
};
#[doc = "Read Local Supported Features return parameter(s)."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union sdc_hci_cmd_ip_read_local_supported_features_return_t {
    pub params: sdc_hci_ip_lmp_features_t,
    pub raw: [u8; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_ip_read_local_supported_features_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_ip_read_local_supported_features_return_t>() - 8usize];
    ["Alignment of sdc_hci_cmd_ip_read_local_supported_features_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_ip_read_local_supported_features_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_ip_read_local_supported_features_return_t::params"]
        [::core::mem::offset_of!(sdc_hci_cmd_ip_read_local_supported_features_return_t, params) - 0usize];
    ["Offset of field: sdc_hci_cmd_ip_read_local_supported_features_return_t::raw"]
        [::core::mem::offset_of!(sdc_hci_cmd_ip_read_local_supported_features_return_t, raw) - 0usize];
};
#[doc = "Read BD_ADDR return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_ip_read_bd_addr_return_t {
    pub bd_addr: [u8; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_ip_read_bd_addr_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_ip_read_bd_addr_return_t>() - 6usize];
    ["Alignment of sdc_hci_cmd_ip_read_bd_addr_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_ip_read_bd_addr_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_ip_read_bd_addr_return_t::bd_addr"]
        [::core::mem::offset_of!(sdc_hci_cmd_ip_read_bd_addr_return_t, bd_addr) - 0usize];
};
unsafe extern "C" {
    #[doc = "HCI_VS_API API\n # /\n/* Read Local Version Information.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.4.1\n\n This command reads the values for the version information for the local Controller.\n\n The HCI_Version information defines the version information of the HCI layer. The\n LMP_Version information defines the version of the LMP. The Company_Identifier\n information indicates the manufacturer of the local device.\n\n The HCI_Subversion and LMP_Subversion are vendor-specific.\n\n Event(s) generated (unless masked away):\n When the HCI_Read_Local_Version_Information command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_ip_read_local_version_information(
        p_return: *mut sdc_hci_cmd_ip_read_local_version_information_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "Read Local Supported Commands.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.4.2\n\n This command reads the list of HCI commands supported for the local Controller.\n\n This command shall return the Supported_Commands configuration parameter.\n\n See Section 6.27 for more information.\n\n Event(s) generated (unless masked away):\n When the HCI_Read_Local_Supported_Commands command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_ip_read_local_supported_commands(
        p_return: *mut sdc_hci_cmd_ip_read_local_supported_commands_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "Read Local Supported Features.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.4.3\n\n This command requests a list of the supported features for the local BR/EDR Controller.\n This command will return a list of the LMP features. For details see 2] Part C,\n Section 3.2.\n\n Event(s) generated (unless masked away):\n When the HCI_Read_Local_Supported_Features command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_ip_read_local_supported_features(
        p_return: *mut sdc_hci_cmd_ip_read_local_supported_features_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "Read BD_ADDR.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.4.6\n\n On a BR/EDR Controller, this command reads the Bluetooth Controller address\n (BD_ADDR). (See 2] Part B, Section 1.2 and 3] Part C, Section 3.2.1).\n\n On an LE Controller, this command shall read the Public Device Address as defined in\n 6] Part B, Section 1.3. If this Controller does not have a Public Device Address, the\n value 0x000000000000 shall be returned.\n\n On a BR/EDR/LE Controller, the public address shall be the same as the BD_ADDR.\n\n Event(s) generated (unless masked away):\n When the HCI_Read_BD_ADDR command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_ip_read_bd_addr(p_return: *mut sdc_hci_cmd_ip_read_bd_addr_return_t) -> u8;
}
#[doc = "See sdc_hci_cmd_le_set_event_mask()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_EVENT_MASK: sdc_hci_opcode_le = 8193;
#[doc = "See sdc_hci_cmd_le_read_buffer_size()."]
pub const SDC_HCI_OPCODE_CMD_LE_READ_BUFFER_SIZE: sdc_hci_opcode_le = 8194;
#[doc = "See sdc_hci_cmd_le_read_local_supported_features()."]
pub const SDC_HCI_OPCODE_CMD_LE_READ_LOCAL_SUPPORTED_FEATURES: sdc_hci_opcode_le = 8195;
#[doc = "See sdc_hci_cmd_le_set_random_address()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_RANDOM_ADDRESS: sdc_hci_opcode_le = 8197;
#[doc = "See sdc_hci_cmd_le_set_adv_params()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_ADV_PARAMS: sdc_hci_opcode_le = 8198;
#[doc = "See sdc_hci_cmd_le_read_adv_physical_channel_tx_power()."]
pub const SDC_HCI_OPCODE_CMD_LE_READ_ADV_PHYSICAL_CHANNEL_TX_POWER: sdc_hci_opcode_le = 8199;
#[doc = "See sdc_hci_cmd_le_set_adv_data()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_ADV_DATA: sdc_hci_opcode_le = 8200;
#[doc = "See sdc_hci_cmd_le_set_scan_response_data()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_SCAN_RESPONSE_DATA: sdc_hci_opcode_le = 8201;
#[doc = "See sdc_hci_cmd_le_set_adv_enable()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_ADV_ENABLE: sdc_hci_opcode_le = 8202;
#[doc = "See sdc_hci_cmd_le_set_scan_params()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_SCAN_PARAMS: sdc_hci_opcode_le = 8203;
#[doc = "See sdc_hci_cmd_le_set_scan_enable()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_SCAN_ENABLE: sdc_hci_opcode_le = 8204;
#[doc = "See sdc_hci_cmd_le_create_conn()."]
pub const SDC_HCI_OPCODE_CMD_LE_CREATE_CONN: sdc_hci_opcode_le = 8205;
#[doc = "See sdc_hci_cmd_le_create_conn_cancel()."]
pub const SDC_HCI_OPCODE_CMD_LE_CREATE_CONN_CANCEL: sdc_hci_opcode_le = 8206;
#[doc = "See sdc_hci_cmd_le_read_filter_accept_list_size()."]
pub const SDC_HCI_OPCODE_CMD_LE_READ_FILTER_ACCEPT_LIST_SIZE: sdc_hci_opcode_le = 8207;
#[doc = "See sdc_hci_cmd_le_clear_filter_accept_list()."]
pub const SDC_HCI_OPCODE_CMD_LE_CLEAR_FILTER_ACCEPT_LIST: sdc_hci_opcode_le = 8208;
#[doc = "See sdc_hci_cmd_le_add_device_to_filter_accept_list()."]
pub const SDC_HCI_OPCODE_CMD_LE_ADD_DEVICE_TO_FILTER_ACCEPT_LIST: sdc_hci_opcode_le = 8209;
#[doc = "See sdc_hci_cmd_le_remove_device_from_filter_accept_list()."]
pub const SDC_HCI_OPCODE_CMD_LE_REMOVE_DEVICE_FROM_FILTER_ACCEPT_LIST: sdc_hci_opcode_le = 8210;
#[doc = "See sdc_hci_cmd_le_conn_update()."]
pub const SDC_HCI_OPCODE_CMD_LE_CONN_UPDATE: sdc_hci_opcode_le = 8211;
#[doc = "See sdc_hci_cmd_le_set_host_channel_classification()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_HOST_CHANNEL_CLASSIFICATION: sdc_hci_opcode_le = 8212;
#[doc = "See sdc_hci_cmd_le_read_channel_map()."]
pub const SDC_HCI_OPCODE_CMD_LE_READ_CHANNEL_MAP: sdc_hci_opcode_le = 8213;
#[doc = "See sdc_hci_cmd_le_read_remote_features()."]
pub const SDC_HCI_OPCODE_CMD_LE_READ_REMOTE_FEATURES: sdc_hci_opcode_le = 8214;
#[doc = "See sdc_hci_cmd_le_encrypt()."]
pub const SDC_HCI_OPCODE_CMD_LE_ENCRYPT: sdc_hci_opcode_le = 8215;
#[doc = "See sdc_hci_cmd_le_rand()."]
pub const SDC_HCI_OPCODE_CMD_LE_RAND: sdc_hci_opcode_le = 8216;
#[doc = "See sdc_hci_cmd_le_enable_encryption()."]
pub const SDC_HCI_OPCODE_CMD_LE_ENABLE_ENCRYPTION: sdc_hci_opcode_le = 8217;
#[doc = "See sdc_hci_cmd_le_long_term_key_request_reply()."]
pub const SDC_HCI_OPCODE_CMD_LE_LONG_TERM_KEY_REQUEST_REPLY: sdc_hci_opcode_le = 8218;
#[doc = "See sdc_hci_cmd_le_long_term_key_request_negative_reply()."]
pub const SDC_HCI_OPCODE_CMD_LE_LONG_TERM_KEY_REQUEST_NEGATIVE_REPLY: sdc_hci_opcode_le = 8219;
#[doc = "See sdc_hci_cmd_le_read_supported_states()."]
pub const SDC_HCI_OPCODE_CMD_LE_READ_SUPPORTED_STATES: sdc_hci_opcode_le = 8220;
#[doc = "See sdc_hci_cmd_le_set_data_length()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_DATA_LENGTH: sdc_hci_opcode_le = 8226;
#[doc = "See sdc_hci_cmd_le_read_suggested_default_data_length()."]
pub const SDC_HCI_OPCODE_CMD_LE_READ_SUGGESTED_DEFAULT_DATA_LENGTH: sdc_hci_opcode_le = 8227;
#[doc = "See sdc_hci_cmd_le_write_suggested_default_data_length()."]
pub const SDC_HCI_OPCODE_CMD_LE_WRITE_SUGGESTED_DEFAULT_DATA_LENGTH: sdc_hci_opcode_le = 8228;
#[doc = "See sdc_hci_cmd_le_add_device_to_resolving_list()."]
pub const SDC_HCI_OPCODE_CMD_LE_ADD_DEVICE_TO_RESOLVING_LIST: sdc_hci_opcode_le = 8231;
#[doc = "See sdc_hci_cmd_le_remove_device_from_resolving_list()."]
pub const SDC_HCI_OPCODE_CMD_LE_REMOVE_DEVICE_FROM_RESOLVING_LIST: sdc_hci_opcode_le = 8232;
#[doc = "See sdc_hci_cmd_le_clear_resolving_list()."]
pub const SDC_HCI_OPCODE_CMD_LE_CLEAR_RESOLVING_LIST: sdc_hci_opcode_le = 8233;
#[doc = "See sdc_hci_cmd_le_read_resolving_list_size()."]
pub const SDC_HCI_OPCODE_CMD_LE_READ_RESOLVING_LIST_SIZE: sdc_hci_opcode_le = 8234;
#[doc = "See sdc_hci_cmd_le_set_address_resolution_enable()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_ADDRESS_RESOLUTION_ENABLE: sdc_hci_opcode_le = 8237;
#[doc = "See sdc_hci_cmd_le_set_resolvable_private_address_timeout()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_RESOLVABLE_PRIVATE_ADDRESS_TIMEOUT: sdc_hci_opcode_le = 8238;
#[doc = "See sdc_hci_cmd_le_read_max_data_length()."]
pub const SDC_HCI_OPCODE_CMD_LE_READ_MAX_DATA_LENGTH: sdc_hci_opcode_le = 8239;
#[doc = "See sdc_hci_cmd_le_read_phy()."]
pub const SDC_HCI_OPCODE_CMD_LE_READ_PHY: sdc_hci_opcode_le = 8240;
#[doc = "See sdc_hci_cmd_le_set_default_phy()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_DEFAULT_PHY: sdc_hci_opcode_le = 8241;
#[doc = "See sdc_hci_cmd_le_set_phy()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_PHY: sdc_hci_opcode_le = 8242;
#[doc = "See sdc_hci_cmd_le_set_adv_set_random_address()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_ADV_SET_RANDOM_ADDRESS: sdc_hci_opcode_le = 8245;
#[doc = "See sdc_hci_cmd_le_set_ext_adv_params()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_EXT_ADV_PARAMS: sdc_hci_opcode_le = 8246;
#[doc = "See sdc_hci_cmd_le_set_ext_adv_data()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_EXT_ADV_DATA: sdc_hci_opcode_le = 8247;
#[doc = "See sdc_hci_cmd_le_set_ext_scan_response_data()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_EXT_SCAN_RESPONSE_DATA: sdc_hci_opcode_le = 8248;
#[doc = "See sdc_hci_cmd_le_set_ext_adv_enable()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_EXT_ADV_ENABLE: sdc_hci_opcode_le = 8249;
#[doc = "See sdc_hci_cmd_le_read_max_adv_data_length()."]
pub const SDC_HCI_OPCODE_CMD_LE_READ_MAX_ADV_DATA_LENGTH: sdc_hci_opcode_le = 8250;
#[doc = "See sdc_hci_cmd_le_read_number_of_supported_adv_sets()."]
pub const SDC_HCI_OPCODE_CMD_LE_READ_NUMBER_OF_SUPPORTED_ADV_SETS: sdc_hci_opcode_le = 8251;
#[doc = "See sdc_hci_cmd_le_remove_adv_set()."]
pub const SDC_HCI_OPCODE_CMD_LE_REMOVE_ADV_SET: sdc_hci_opcode_le = 8252;
#[doc = "See sdc_hci_cmd_le_clear_adv_sets()."]
pub const SDC_HCI_OPCODE_CMD_LE_CLEAR_ADV_SETS: sdc_hci_opcode_le = 8253;
#[doc = "See sdc_hci_cmd_le_set_periodic_adv_params()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_PERIODIC_ADV_PARAMS: sdc_hci_opcode_le = 8254;
#[doc = "See sdc_hci_cmd_le_set_periodic_adv_data()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_PERIODIC_ADV_DATA: sdc_hci_opcode_le = 8255;
#[doc = "See sdc_hci_cmd_le_set_periodic_adv_enable()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_PERIODIC_ADV_ENABLE: sdc_hci_opcode_le = 8256;
#[doc = "See sdc_hci_cmd_le_set_ext_scan_params()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_EXT_SCAN_PARAMS: sdc_hci_opcode_le = 8257;
#[doc = "See sdc_hci_cmd_le_set_ext_scan_enable()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_EXT_SCAN_ENABLE: sdc_hci_opcode_le = 8258;
#[doc = "See sdc_hci_cmd_le_ext_create_conn()."]
pub const SDC_HCI_OPCODE_CMD_LE_EXT_CREATE_CONN: sdc_hci_opcode_le = 8259;
#[doc = "See sdc_hci_cmd_le_periodic_adv_create_sync()."]
pub const SDC_HCI_OPCODE_CMD_LE_PERIODIC_ADV_CREATE_SYNC: sdc_hci_opcode_le = 8260;
#[doc = "See sdc_hci_cmd_le_periodic_adv_create_sync_cancel()."]
pub const SDC_HCI_OPCODE_CMD_LE_PERIODIC_ADV_CREATE_SYNC_CANCEL: sdc_hci_opcode_le = 8261;
#[doc = "See sdc_hci_cmd_le_periodic_adv_terminate_sync()."]
pub const SDC_HCI_OPCODE_CMD_LE_PERIODIC_ADV_TERMINATE_SYNC: sdc_hci_opcode_le = 8262;
#[doc = "See sdc_hci_cmd_le_add_device_to_periodic_adv_list()."]
pub const SDC_HCI_OPCODE_CMD_LE_ADD_DEVICE_TO_PERIODIC_ADV_LIST: sdc_hci_opcode_le = 8263;
#[doc = "See sdc_hci_cmd_le_remove_device_from_periodic_adv_list()."]
pub const SDC_HCI_OPCODE_CMD_LE_REMOVE_DEVICE_FROM_PERIODIC_ADV_LIST: sdc_hci_opcode_le = 8264;
#[doc = "See sdc_hci_cmd_le_clear_periodic_adv_list()."]
pub const SDC_HCI_OPCODE_CMD_LE_CLEAR_PERIODIC_ADV_LIST: sdc_hci_opcode_le = 8265;
#[doc = "See sdc_hci_cmd_le_read_periodic_adv_list_size()."]
pub const SDC_HCI_OPCODE_CMD_LE_READ_PERIODIC_ADV_LIST_SIZE: sdc_hci_opcode_le = 8266;
#[doc = "See sdc_hci_cmd_le_read_transmit_power()."]
pub const SDC_HCI_OPCODE_CMD_LE_READ_TRANSMIT_POWER: sdc_hci_opcode_le = 8267;
#[doc = "See sdc_hci_cmd_le_read_rf_path_compensation()."]
pub const SDC_HCI_OPCODE_CMD_LE_READ_RF_PATH_COMPENSATION: sdc_hci_opcode_le = 8268;
#[doc = "See sdc_hci_cmd_le_write_rf_path_compensation()."]
pub const SDC_HCI_OPCODE_CMD_LE_WRITE_RF_PATH_COMPENSATION: sdc_hci_opcode_le = 8269;
#[doc = "See sdc_hci_cmd_le_set_privacy_mode()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_PRIVACY_MODE: sdc_hci_opcode_le = 8270;
#[doc = "See sdc_hci_cmd_le_set_connless_cte_transmit_params()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_CONNLESS_CTE_TRANSMIT_PARAMS: sdc_hci_opcode_le = 8273;
#[doc = "See sdc_hci_cmd_le_set_connless_cte_transmit_enable()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_CONNLESS_CTE_TRANSMIT_ENABLE: sdc_hci_opcode_le = 8274;
#[doc = "See sdc_hci_cmd_le_set_conn_cte_transmit_params()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_CONN_CTE_TRANSMIT_PARAMS: sdc_hci_opcode_le = 8277;
#[doc = "See sdc_hci_cmd_le_conn_cte_response_enable()."]
pub const SDC_HCI_OPCODE_CMD_LE_CONN_CTE_RESPONSE_ENABLE: sdc_hci_opcode_le = 8279;
#[doc = "See sdc_hci_cmd_le_read_antenna_information()."]
pub const SDC_HCI_OPCODE_CMD_LE_READ_ANTENNA_INFORMATION: sdc_hci_opcode_le = 8280;
#[doc = "See sdc_hci_cmd_le_set_periodic_adv_receive_enable()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_PERIODIC_ADV_RECEIVE_ENABLE: sdc_hci_opcode_le = 8281;
#[doc = "See sdc_hci_cmd_le_periodic_adv_sync_transfer()."]
pub const SDC_HCI_OPCODE_CMD_LE_PERIODIC_ADV_SYNC_TRANSFER: sdc_hci_opcode_le = 8282;
#[doc = "See sdc_hci_cmd_le_periodic_adv_set_info_transfer()."]
pub const SDC_HCI_OPCODE_CMD_LE_PERIODIC_ADV_SET_INFO_TRANSFER: sdc_hci_opcode_le = 8283;
#[doc = "See sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_PERIODIC_ADV_SYNC_TRANSFER_PARAMS: sdc_hci_opcode_le = 8284;
#[doc = "See sdc_hci_cmd_le_set_default_periodic_adv_sync_transfer_params()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_DEFAULT_PERIODIC_ADV_SYNC_TRANSFER_PARAMS: sdc_hci_opcode_le = 8285;
#[doc = "See sdc_hci_cmd_le_read_buffer_size_v2()."]
pub const SDC_HCI_OPCODE_CMD_LE_READ_BUFFER_SIZE_V2: sdc_hci_opcode_le = 8288;
#[doc = "See sdc_hci_cmd_le_read_iso_tx_sync()."]
pub const SDC_HCI_OPCODE_CMD_LE_READ_ISO_TX_SYNC: sdc_hci_opcode_le = 8289;
#[doc = "See sdc_hci_cmd_le_set_cig_params()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_CIG_PARAMS: sdc_hci_opcode_le = 8290;
#[doc = "See sdc_hci_cmd_le_set_cig_params_test()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_CIG_PARAMS_TEST: sdc_hci_opcode_le = 8291;
#[doc = "See sdc_hci_cmd_le_create_cis()."]
pub const SDC_HCI_OPCODE_CMD_LE_CREATE_CIS: sdc_hci_opcode_le = 8292;
#[doc = "See sdc_hci_cmd_le_remove_cig()."]
pub const SDC_HCI_OPCODE_CMD_LE_REMOVE_CIG: sdc_hci_opcode_le = 8293;
#[doc = "See sdc_hci_cmd_le_accept_cis_request()."]
pub const SDC_HCI_OPCODE_CMD_LE_ACCEPT_CIS_REQUEST: sdc_hci_opcode_le = 8294;
#[doc = "See sdc_hci_cmd_le_reject_cis_request()."]
pub const SDC_HCI_OPCODE_CMD_LE_REJECT_CIS_REQUEST: sdc_hci_opcode_le = 8295;
#[doc = "See sdc_hci_cmd_le_create_big()."]
pub const SDC_HCI_OPCODE_CMD_LE_CREATE_BIG: sdc_hci_opcode_le = 8296;
#[doc = "See sdc_hci_cmd_le_create_big_test()."]
pub const SDC_HCI_OPCODE_CMD_LE_CREATE_BIG_TEST: sdc_hci_opcode_le = 8297;
#[doc = "See sdc_hci_cmd_le_terminate_big()."]
pub const SDC_HCI_OPCODE_CMD_LE_TERMINATE_BIG: sdc_hci_opcode_le = 8298;
#[doc = "See sdc_hci_cmd_le_big_create_sync()."]
pub const SDC_HCI_OPCODE_CMD_LE_BIG_CREATE_SYNC: sdc_hci_opcode_le = 8299;
#[doc = "See sdc_hci_cmd_le_big_terminate_sync()."]
pub const SDC_HCI_OPCODE_CMD_LE_BIG_TERMINATE_SYNC: sdc_hci_opcode_le = 8300;
#[doc = "See sdc_hci_cmd_le_request_peer_sca()."]
pub const SDC_HCI_OPCODE_CMD_LE_REQUEST_PEER_SCA: sdc_hci_opcode_le = 8301;
#[doc = "See sdc_hci_cmd_le_setup_iso_data_path()."]
pub const SDC_HCI_OPCODE_CMD_LE_SETUP_ISO_DATA_PATH: sdc_hci_opcode_le = 8302;
#[doc = "See sdc_hci_cmd_le_remove_iso_data_path()."]
pub const SDC_HCI_OPCODE_CMD_LE_REMOVE_ISO_DATA_PATH: sdc_hci_opcode_le = 8303;
#[doc = "See sdc_hci_cmd_le_iso_transmit_test()."]
pub const SDC_HCI_OPCODE_CMD_LE_ISO_TRANSMIT_TEST: sdc_hci_opcode_le = 8304;
#[doc = "See sdc_hci_cmd_le_iso_receive_test()."]
pub const SDC_HCI_OPCODE_CMD_LE_ISO_RECEIVE_TEST: sdc_hci_opcode_le = 8305;
#[doc = "See sdc_hci_cmd_le_iso_read_test_counters()."]
pub const SDC_HCI_OPCODE_CMD_LE_ISO_READ_TEST_COUNTERS: sdc_hci_opcode_le = 8306;
#[doc = "See sdc_hci_cmd_le_iso_test_end()."]
pub const SDC_HCI_OPCODE_CMD_LE_ISO_TEST_END: sdc_hci_opcode_le = 8307;
#[doc = "See sdc_hci_cmd_le_set_host_feature()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_HOST_FEATURE: sdc_hci_opcode_le = 8308;
#[doc = "See sdc_hci_cmd_le_read_iso_link_quality()."]
pub const SDC_HCI_OPCODE_CMD_LE_READ_ISO_LINK_QUALITY: sdc_hci_opcode_le = 8309;
#[doc = "See sdc_hci_cmd_le_enhanced_read_transmit_power_level()."]
pub const SDC_HCI_OPCODE_CMD_LE_ENHANCED_READ_TRANSMIT_POWER_LEVEL: sdc_hci_opcode_le = 8310;
#[doc = "See sdc_hci_cmd_le_read_remote_transmit_power_level()."]
pub const SDC_HCI_OPCODE_CMD_LE_READ_REMOTE_TRANSMIT_POWER_LEVEL: sdc_hci_opcode_le = 8311;
#[doc = "See sdc_hci_cmd_le_set_path_loss_reporting_params()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_PATH_LOSS_REPORTING_PARAMS: sdc_hci_opcode_le = 8312;
#[doc = "See sdc_hci_cmd_le_set_path_loss_reporting_enable()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_PATH_LOSS_REPORTING_ENABLE: sdc_hci_opcode_le = 8313;
#[doc = "See sdc_hci_cmd_le_set_transmit_power_reporting_enable()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_TRANSMIT_POWER_REPORTING_ENABLE: sdc_hci_opcode_le = 8314;
#[doc = "See sdc_hci_cmd_le_set_data_related_address_changes()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_DATA_RELATED_ADDRESS_CHANGES: sdc_hci_opcode_le = 8316;
#[doc = "See sdc_hci_cmd_le_set_default_subrate()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_DEFAULT_SUBRATE: sdc_hci_opcode_le = 8317;
#[doc = "See sdc_hci_cmd_le_subrate_request()."]
pub const SDC_HCI_OPCODE_CMD_LE_SUBRATE_REQUEST: sdc_hci_opcode_le = 8318;
#[doc = "See sdc_hci_cmd_le_set_ext_adv_params_v2()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_EXT_ADV_PARAMS_V2: sdc_hci_opcode_le = 8319;
#[doc = "See sdc_hci_cmd_le_set_periodic_adv_subevent_data()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_PERIODIC_ADV_SUBEVENT_DATA: sdc_hci_opcode_le = 8322;
#[doc = "See sdc_hci_cmd_le_set_periodic_adv_response_data()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_PERIODIC_ADV_RESPONSE_DATA: sdc_hci_opcode_le = 8323;
#[doc = "See sdc_hci_cmd_le_set_periodic_sync_subevent()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_PERIODIC_SYNC_SUBEVENT: sdc_hci_opcode_le = 8324;
#[doc = "See sdc_hci_cmd_le_ext_create_conn_v2()."]
pub const SDC_HCI_OPCODE_CMD_LE_EXT_CREATE_CONN_V2: sdc_hci_opcode_le = 8325;
#[doc = "See sdc_hci_cmd_le_set_periodic_adv_params_v2()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_PERIODIC_ADV_PARAMS_V2: sdc_hci_opcode_le = 8326;
#[doc = "See sdc_hci_cmd_le_cs_read_local_supported_capabilities()."]
pub const SDC_HCI_OPCODE_CMD_LE_CS_READ_LOCAL_SUPPORTED_CAPABILITIES: sdc_hci_opcode_le = 8329;
#[doc = "See sdc_hci_cmd_le_cs_read_remote_supported_capabilities()."]
pub const SDC_HCI_OPCODE_CMD_LE_CS_READ_REMOTE_SUPPORTED_CAPABILITIES: sdc_hci_opcode_le = 8330;
#[doc = "See sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities()."]
pub const SDC_HCI_OPCODE_CMD_LE_CS_WRITE_CACHED_REMOTE_SUPPORTED_CAPABILITIES: sdc_hci_opcode_le = 8331;
#[doc = "See sdc_hci_cmd_le_cs_security_enable()."]
pub const SDC_HCI_OPCODE_CMD_LE_CS_SECURITY_ENABLE: sdc_hci_opcode_le = 8332;
#[doc = "See sdc_hci_cmd_le_cs_set_default_settings()."]
pub const SDC_HCI_OPCODE_CMD_LE_CS_SET_DEFAULT_SETTINGS: sdc_hci_opcode_le = 8333;
#[doc = "See sdc_hci_cmd_le_cs_read_remote_fae_table()."]
pub const SDC_HCI_OPCODE_CMD_LE_CS_READ_REMOTE_FAE_TABLE: sdc_hci_opcode_le = 8334;
#[doc = "See sdc_hci_cmd_le_cs_write_cached_remote_fae_table()."]
pub const SDC_HCI_OPCODE_CMD_LE_CS_WRITE_CACHED_REMOTE_FAE_TABLE: sdc_hci_opcode_le = 8335;
#[doc = "See sdc_hci_cmd_le_cs_create_config()."]
pub const SDC_HCI_OPCODE_CMD_LE_CS_CREATE_CONFIG: sdc_hci_opcode_le = 8336;
#[doc = "See sdc_hci_cmd_le_cs_remove_config()."]
pub const SDC_HCI_OPCODE_CMD_LE_CS_REMOVE_CONFIG: sdc_hci_opcode_le = 8337;
#[doc = "See sdc_hci_cmd_le_cs_set_channel_classification()."]
pub const SDC_HCI_OPCODE_CMD_LE_CS_SET_CHANNEL_CLASSIFICATION: sdc_hci_opcode_le = 8338;
#[doc = "See sdc_hci_cmd_le_cs_set_procedure_params()."]
pub const SDC_HCI_OPCODE_CMD_LE_CS_SET_PROCEDURE_PARAMS: sdc_hci_opcode_le = 8339;
#[doc = "See sdc_hci_cmd_le_cs_procedure_enable()."]
pub const SDC_HCI_OPCODE_CMD_LE_CS_PROCEDURE_ENABLE: sdc_hci_opcode_le = 8340;
#[doc = "See sdc_hci_cmd_le_cs_test()."]
pub const SDC_HCI_OPCODE_CMD_LE_CS_TEST: sdc_hci_opcode_le = 8341;
#[doc = "See sdc_hci_cmd_le_cs_test_end()."]
pub const SDC_HCI_OPCODE_CMD_LE_CS_TEST_END: sdc_hci_opcode_le = 8342;
#[doc = "See sdc_hci_cmd_le_set_host_feature_v2()."]
pub const SDC_HCI_OPCODE_CMD_LE_SET_HOST_FEATURE_V2: sdc_hci_opcode_le = 8343;
#[doc = "HCI LE OpCode Field values."]
pub type sdc_hci_opcode_le = ::core::ffi::c_uint;
#[doc = "See sdc_hci_subevent_le_adv_report_t."]
pub const SDC_HCI_SUBEVENT_LE_ADV_REPORT: sdc_hci_subevent_le = 2;
#[doc = "See sdc_hci_subevent_le_directed_adv_report_t."]
pub const SDC_HCI_SUBEVENT_LE_DIRECTED_ADV_REPORT: sdc_hci_subevent_le = 11;
#[doc = "See sdc_hci_subevent_le_ext_adv_report_t."]
pub const SDC_HCI_SUBEVENT_LE_EXT_ADV_REPORT: sdc_hci_subevent_le = 13;
#[doc = "See sdc_hci_subevent_le_cis_established_t."]
pub const SDC_HCI_SUBEVENT_LE_CIS_ESTABLISHED: sdc_hci_subevent_le = 25;
#[doc = "See sdc_hci_subevent_le_subrate_change_t."]
pub const SDC_HCI_SUBEVENT_LE_SUBRATE_CHANGE: sdc_hci_subevent_le = 35;
#[doc = "See sdc_hci_subevent_le_cis_established_v2_t."]
pub const SDC_HCI_SUBEVENT_LE_CIS_ESTABLISHED_V2: sdc_hci_subevent_le = 42;
#[doc = "See sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t."]
pub const SDC_HCI_SUBEVENT_LE_CS_READ_REMOTE_SUPPORTED_CAPABILITIES_COMPLETE: sdc_hci_subevent_le = 44;
#[doc = "See sdc_hci_subevent_le_cs_read_remote_fae_table_complete_t."]
pub const SDC_HCI_SUBEVENT_LE_CS_READ_REMOTE_FAE_TABLE_COMPLETE: sdc_hci_subevent_le = 45;
#[doc = "See sdc_hci_subevent_le_cs_security_enable_complete_t."]
pub const SDC_HCI_SUBEVENT_LE_CS_SECURITY_ENABLE_COMPLETE: sdc_hci_subevent_le = 46;
#[doc = "See sdc_hci_subevent_le_cs_config_complete_t."]
pub const SDC_HCI_SUBEVENT_LE_CS_CONFIG_COMPLETE: sdc_hci_subevent_le = 47;
#[doc = "See sdc_hci_subevent_le_cs_procedure_enable_complete_t."]
pub const SDC_HCI_SUBEVENT_LE_CS_PROCEDURE_ENABLE_COMPLETE: sdc_hci_subevent_le = 48;
#[doc = "See sdc_hci_subevent_le_cs_subevent_result_t."]
pub const SDC_HCI_SUBEVENT_LE_CS_SUBEVENT_RESULT: sdc_hci_subevent_le = 49;
#[doc = "See sdc_hci_subevent_le_cs_subevent_result_continue_t."]
pub const SDC_HCI_SUBEVENT_LE_CS_SUBEVENT_RESULT_CONTINUE: sdc_hci_subevent_le = 50;
#[doc = "See sdc_hci_subevent_le_cs_test_end_complete_t."]
pub const SDC_HCI_SUBEVENT_LE_CS_TEST_END_COMPLETE: sdc_hci_subevent_le = 51;
#[doc = "LE subevent Code values."]
pub type sdc_hci_subevent_le = ::core::ffi::c_uint;
#[doc = "Advertising Event Properties parameters."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_le_adv_event_properties_params_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_le_adv_event_properties_params_t"]
        [::core::mem::size_of::<sdc_hci_le_adv_event_properties_params_t>() - 2usize];
    ["Alignment of sdc_hci_le_adv_event_properties_params_t"]
        [::core::mem::align_of::<sdc_hci_le_adv_event_properties_params_t>() - 1usize];
};
impl sdc_hci_le_adv_event_properties_params_t {
    #[inline]
    pub fn connectable_adv(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_connectable_adv(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn connectable_adv_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_connectable_adv_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scannable_adv(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_scannable_adv(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scannable_adv_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_scannable_adv_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn directed_adv(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_directed_adv(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn directed_adv_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_directed_adv_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn high_duty_cycle_adv(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_high_duty_cycle_adv(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn high_duty_cycle_adv_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_high_duty_cycle_adv_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn legacy_adv_packets(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_legacy_adv_packets(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn legacy_adv_packets_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_legacy_adv_packets_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn omit_adv_address(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_omit_adv_address(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn omit_adv_address_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_omit_adv_address_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn include_tx_power(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_include_tx_power(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn include_tx_power_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_include_tx_power_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn use_decision_pdus(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_use_decision_pdus(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn use_decision_pdus_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_use_decision_pdus_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn include_adva_in_ext_header(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_include_adva_in_ext_header(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn include_adva_in_ext_header_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_include_adva_in_ext_header_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn include_adi_in_ext_header(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_include_adi_in_ext_header(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn include_adi_in_ext_header_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_include_adi_in_ext_header_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_rfu(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                6u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        connectable_adv: u8,
        scannable_adv: u8,
        directed_adv: u8,
        high_duty_cycle_adv: u8,
        legacy_adv_packets: u8,
        omit_adv_address: u8,
        include_tx_power: u8,
        use_decision_pdus: u8,
        include_adva_in_ext_header: u8,
        include_adi_in_ext_header: u8,
        rfu: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let connectable_adv: u8 = unsafe { ::core::mem::transmute(connectable_adv) };
            connectable_adv as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let scannable_adv: u8 = unsafe { ::core::mem::transmute(scannable_adv) };
            scannable_adv as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let directed_adv: u8 = unsafe { ::core::mem::transmute(directed_adv) };
            directed_adv as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let high_duty_cycle_adv: u8 = unsafe { ::core::mem::transmute(high_duty_cycle_adv) };
            high_duty_cycle_adv as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let legacy_adv_packets: u8 = unsafe { ::core::mem::transmute(legacy_adv_packets) };
            legacy_adv_packets as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let omit_adv_address: u8 = unsafe { ::core::mem::transmute(omit_adv_address) };
            omit_adv_address as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let include_tx_power: u8 = unsafe { ::core::mem::transmute(include_tx_power) };
            include_tx_power as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let use_decision_pdus: u8 = unsafe { ::core::mem::transmute(use_decision_pdus) };
            use_decision_pdus as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let include_adva_in_ext_header: u8 = unsafe { ::core::mem::transmute(include_adva_in_ext_header) };
            include_adva_in_ext_header as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let include_adi_in_ext_header: u8 = unsafe { ::core::mem::transmute(include_adi_in_ext_header) };
            include_adi_in_ext_header as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let rfu: u8 = unsafe { ::core::mem::transmute(rfu) };
            rfu as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "LE Advertising Report array parameters."]
#[repr(C, packed)]
pub struct sdc_hci_le_adv_report_array_params_t {
    pub event_type: u8,
    pub address_type: u8,
    pub address: [u8; 6usize],
    pub data_length: u8,
    pub data: __IncompleteArrayField<u8>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_le_adv_report_array_params_t"]
        [::core::mem::size_of::<sdc_hci_le_adv_report_array_params_t>() - 9usize];
    ["Alignment of sdc_hci_le_adv_report_array_params_t"]
        [::core::mem::align_of::<sdc_hci_le_adv_report_array_params_t>() - 1usize];
    ["Offset of field: sdc_hci_le_adv_report_array_params_t::event_type"]
        [::core::mem::offset_of!(sdc_hci_le_adv_report_array_params_t, event_type) - 0usize];
    ["Offset of field: sdc_hci_le_adv_report_array_params_t::address_type"]
        [::core::mem::offset_of!(sdc_hci_le_adv_report_array_params_t, address_type) - 1usize];
    ["Offset of field: sdc_hci_le_adv_report_array_params_t::address"]
        [::core::mem::offset_of!(sdc_hci_le_adv_report_array_params_t, address) - 2usize];
    ["Offset of field: sdc_hci_le_adv_report_array_params_t::data_length"]
        [::core::mem::offset_of!(sdc_hci_le_adv_report_array_params_t, data_length) - 8usize];
    ["Offset of field: sdc_hci_le_adv_report_array_params_t::data"]
        [::core::mem::offset_of!(sdc_hci_le_adv_report_array_params_t, data) - 9usize];
};
#[doc = "LE BIG Create Sync array parameters."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_le_big_create_sync_array_params_t {
    pub bis: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_le_big_create_sync_array_params_t"]
        [::core::mem::size_of::<sdc_hci_le_big_create_sync_array_params_t>() - 1usize];
    ["Alignment of sdc_hci_le_big_create_sync_array_params_t"]
        [::core::mem::align_of::<sdc_hci_le_big_create_sync_array_params_t>() - 1usize];
    ["Offset of field: sdc_hci_le_big_create_sync_array_params_t::bis"]
        [::core::mem::offset_of!(sdc_hci_le_big_create_sync_array_params_t, bis) - 0usize];
};
#[doc = "LE Create CIS array parameters."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_le_create_cis_array_params_t {
    pub cis_conn_handle: u16,
    pub acl_conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_le_create_cis_array_params_t"]
        [::core::mem::size_of::<sdc_hci_le_create_cis_array_params_t>() - 4usize];
    ["Alignment of sdc_hci_le_create_cis_array_params_t"]
        [::core::mem::align_of::<sdc_hci_le_create_cis_array_params_t>() - 1usize];
    ["Offset of field: sdc_hci_le_create_cis_array_params_t::cis_conn_handle"]
        [::core::mem::offset_of!(sdc_hci_le_create_cis_array_params_t, cis_conn_handle) - 0usize];
    ["Offset of field: sdc_hci_le_create_cis_array_params_t::acl_conn_handle"]
        [::core::mem::offset_of!(sdc_hci_le_create_cis_array_params_t, acl_conn_handle) - 2usize];
};
#[doc = "LE CS Subevent Result array parameters."]
#[repr(C, packed)]
pub struct sdc_hci_le_cs_subevent_result_array_params_t {
    pub step_mode: u8,
    pub step_channel: u8,
    pub step_data_length: u8,
    pub step_data: __IncompleteArrayField<u8>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_le_cs_subevent_result_array_params_t"]
        [::core::mem::size_of::<sdc_hci_le_cs_subevent_result_array_params_t>() - 3usize];
    ["Alignment of sdc_hci_le_cs_subevent_result_array_params_t"]
        [::core::mem::align_of::<sdc_hci_le_cs_subevent_result_array_params_t>() - 1usize];
    ["Offset of field: sdc_hci_le_cs_subevent_result_array_params_t::step_mode"]
        [::core::mem::offset_of!(sdc_hci_le_cs_subevent_result_array_params_t, step_mode) - 0usize];
    ["Offset of field: sdc_hci_le_cs_subevent_result_array_params_t::step_channel"]
        [::core::mem::offset_of!(sdc_hci_le_cs_subevent_result_array_params_t, step_channel) - 1usize];
    ["Offset of field: sdc_hci_le_cs_subevent_result_array_params_t::step_data_length"]
        [::core::mem::offset_of!(sdc_hci_le_cs_subevent_result_array_params_t, step_data_length) - 2usize];
    ["Offset of field: sdc_hci_le_cs_subevent_result_array_params_t::step_data"]
        [::core::mem::offset_of!(sdc_hci_le_cs_subevent_result_array_params_t, step_data) - 3usize];
};
#[doc = "LE CS Subevent Result Continue array parameters."]
#[repr(C, packed)]
pub struct sdc_hci_le_cs_subevent_result_continue_array_params_t {
    pub step_mode: u8,
    pub step_channel: u8,
    pub step_data_length: u8,
    pub step_data: __IncompleteArrayField<u8>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_le_cs_subevent_result_continue_array_params_t"]
        [::core::mem::size_of::<sdc_hci_le_cs_subevent_result_continue_array_params_t>() - 3usize];
    ["Alignment of sdc_hci_le_cs_subevent_result_continue_array_params_t"]
        [::core::mem::align_of::<sdc_hci_le_cs_subevent_result_continue_array_params_t>() - 1usize];
    ["Offset of field: sdc_hci_le_cs_subevent_result_continue_array_params_t::step_mode"]
        [::core::mem::offset_of!(sdc_hci_le_cs_subevent_result_continue_array_params_t, step_mode) - 0usize];
    ["Offset of field: sdc_hci_le_cs_subevent_result_continue_array_params_t::step_channel"]
        [::core::mem::offset_of!(sdc_hci_le_cs_subevent_result_continue_array_params_t, step_channel) - 1usize];
    ["Offset of field: sdc_hci_le_cs_subevent_result_continue_array_params_t::step_data_length"]
        [::core::mem::offset_of!(sdc_hci_le_cs_subevent_result_continue_array_params_t, step_data_length) - 2usize];
    ["Offset of field: sdc_hci_le_cs_subevent_result_continue_array_params_t::step_data"]
        [::core::mem::offset_of!(sdc_hci_le_cs_subevent_result_continue_array_params_t, step_data) - 3usize];
};
#[doc = "LE Directed Advertising Report array parameters."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_le_directed_adv_report_array_params_t {
    pub event_type: u8,
    pub address_type: u8,
    pub address: [u8; 6usize],
    pub direct_address_type: u8,
    pub direct_address: [u8; 6usize],
    pub rssi: i8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_le_directed_adv_report_array_params_t"]
        [::core::mem::size_of::<sdc_hci_le_directed_adv_report_array_params_t>() - 16usize];
    ["Alignment of sdc_hci_le_directed_adv_report_array_params_t"]
        [::core::mem::align_of::<sdc_hci_le_directed_adv_report_array_params_t>() - 1usize];
    ["Offset of field: sdc_hci_le_directed_adv_report_array_params_t::event_type"]
        [::core::mem::offset_of!(sdc_hci_le_directed_adv_report_array_params_t, event_type) - 0usize];
    ["Offset of field: sdc_hci_le_directed_adv_report_array_params_t::address_type"]
        [::core::mem::offset_of!(sdc_hci_le_directed_adv_report_array_params_t, address_type) - 1usize];
    ["Offset of field: sdc_hci_le_directed_adv_report_array_params_t::address"]
        [::core::mem::offset_of!(sdc_hci_le_directed_adv_report_array_params_t, address) - 2usize];
    ["Offset of field: sdc_hci_le_directed_adv_report_array_params_t::direct_address_type"]
        [::core::mem::offset_of!(sdc_hci_le_directed_adv_report_array_params_t, direct_address_type) - 8usize];
    ["Offset of field: sdc_hci_le_directed_adv_report_array_params_t::direct_address"]
        [::core::mem::offset_of!(sdc_hci_le_directed_adv_report_array_params_t, direct_address) - 9usize];
    ["Offset of field: sdc_hci_le_directed_adv_report_array_params_t::rssi"]
        [::core::mem::offset_of!(sdc_hci_le_directed_adv_report_array_params_t, rssi) - 15usize];
};
#[doc = "Event_Type parameters for HCI_LE_Extended_Advertising_Report event."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_le_ext_adv_report_array_event_type_params_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_le_ext_adv_report_array_event_type_params_t"]
        [::core::mem::size_of::<sdc_hci_le_ext_adv_report_array_event_type_params_t>() - 2usize];
    ["Alignment of sdc_hci_le_ext_adv_report_array_event_type_params_t"]
        [::core::mem::align_of::<sdc_hci_le_ext_adv_report_array_event_type_params_t>() - 1usize];
};
impl sdc_hci_le_ext_adv_report_array_event_type_params_t {
    #[inline]
    pub fn connectable_adv(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_connectable_adv(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn connectable_adv_raw(this: *const Self) -> u16 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_connectable_adv_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scannable_adv(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_scannable_adv(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scannable_adv_raw(this: *const Self) -> u16 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_scannable_adv_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn directed_adv(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_directed_adv(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn directed_adv_raw(this: *const Self) -> u16 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_directed_adv_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_response(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_scan_response(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_response_raw(this: *const Self) -> u16 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_scan_response_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn legacy_adv_pdus_used(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_legacy_adv_pdus_used(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn legacy_adv_pdus_used_raw(this: *const Self) -> u16 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_legacy_adv_pdus_used_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn data_status(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_data_status(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn data_status_raw(this: *const Self) -> u16 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_data_status_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u16) }
    }
    #[inline]
    pub fn set_rfu(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu_raw(this: *const Self) -> u16 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                9u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_rfu_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                9u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        connectable_adv: u16,
        scannable_adv: u16,
        directed_adv: u16,
        scan_response: u16,
        legacy_adv_pdus_used: u16,
        data_status: u16,
        rfu: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let connectable_adv: u16 = unsafe { ::core::mem::transmute(connectable_adv) };
            connectable_adv as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let scannable_adv: u16 = unsafe { ::core::mem::transmute(scannable_adv) };
            scannable_adv as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let directed_adv: u16 = unsafe { ::core::mem::transmute(directed_adv) };
            directed_adv as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let scan_response: u16 = unsafe { ::core::mem::transmute(scan_response) };
            scan_response as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let legacy_adv_pdus_used: u16 = unsafe { ::core::mem::transmute(legacy_adv_pdus_used) };
            legacy_adv_pdus_used as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let data_status: u16 = unsafe { ::core::mem::transmute(data_status) };
            data_status as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let rfu: u16 = unsafe { ::core::mem::transmute(rfu) };
            rfu as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "LE Extended Advertising Report array parameters."]
#[repr(C, packed)]
pub struct sdc_hci_le_ext_adv_report_array_params_t {
    pub event_type: sdc_hci_le_ext_adv_report_array_params_t__bindgen_ty_1,
    pub address_type: u8,
    pub address: [u8; 6usize],
    pub primary_phy: u8,
    pub secondary_phy: u8,
    pub adv_sid: u8,
    pub tx_power: i8,
    pub rssi: i8,
    pub periodic_adv_interval: u16,
    pub direct_address_type: u8,
    pub direct_address: [u8; 6usize],
    pub data_length: u8,
    pub data: __IncompleteArrayField<u8>,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union sdc_hci_le_ext_adv_report_array_params_t__bindgen_ty_1 {
    pub params: sdc_hci_le_ext_adv_report_array_event_type_params_t,
    pub raw: [u8; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_le_ext_adv_report_array_params_t__bindgen_ty_1"]
        [::core::mem::size_of::<sdc_hci_le_ext_adv_report_array_params_t__bindgen_ty_1>() - 2usize];
    ["Alignment of sdc_hci_le_ext_adv_report_array_params_t__bindgen_ty_1"]
        [::core::mem::align_of::<sdc_hci_le_ext_adv_report_array_params_t__bindgen_ty_1>() - 1usize];
    ["Offset of field: sdc_hci_le_ext_adv_report_array_params_t__bindgen_ty_1::params"]
        [::core::mem::offset_of!(sdc_hci_le_ext_adv_report_array_params_t__bindgen_ty_1, params) - 0usize];
    ["Offset of field: sdc_hci_le_ext_adv_report_array_params_t__bindgen_ty_1::raw"]
        [::core::mem::offset_of!(sdc_hci_le_ext_adv_report_array_params_t__bindgen_ty_1, raw) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_le_ext_adv_report_array_params_t"]
        [::core::mem::size_of::<sdc_hci_le_ext_adv_report_array_params_t>() - 24usize];
    ["Alignment of sdc_hci_le_ext_adv_report_array_params_t"]
        [::core::mem::align_of::<sdc_hci_le_ext_adv_report_array_params_t>() - 1usize];
    ["Offset of field: sdc_hci_le_ext_adv_report_array_params_t::event_type"]
        [::core::mem::offset_of!(sdc_hci_le_ext_adv_report_array_params_t, event_type) - 0usize];
    ["Offset of field: sdc_hci_le_ext_adv_report_array_params_t::address_type"]
        [::core::mem::offset_of!(sdc_hci_le_ext_adv_report_array_params_t, address_type) - 2usize];
    ["Offset of field: sdc_hci_le_ext_adv_report_array_params_t::address"]
        [::core::mem::offset_of!(sdc_hci_le_ext_adv_report_array_params_t, address) - 3usize];
    ["Offset of field: sdc_hci_le_ext_adv_report_array_params_t::primary_phy"]
        [::core::mem::offset_of!(sdc_hci_le_ext_adv_report_array_params_t, primary_phy) - 9usize];
    ["Offset of field: sdc_hci_le_ext_adv_report_array_params_t::secondary_phy"]
        [::core::mem::offset_of!(sdc_hci_le_ext_adv_report_array_params_t, secondary_phy) - 10usize];
    ["Offset of field: sdc_hci_le_ext_adv_report_array_params_t::adv_sid"]
        [::core::mem::offset_of!(sdc_hci_le_ext_adv_report_array_params_t, adv_sid) - 11usize];
    ["Offset of field: sdc_hci_le_ext_adv_report_array_params_t::tx_power"]
        [::core::mem::offset_of!(sdc_hci_le_ext_adv_report_array_params_t, tx_power) - 12usize];
    ["Offset of field: sdc_hci_le_ext_adv_report_array_params_t::rssi"]
        [::core::mem::offset_of!(sdc_hci_le_ext_adv_report_array_params_t, rssi) - 13usize];
    ["Offset of field: sdc_hci_le_ext_adv_report_array_params_t::periodic_adv_interval"]
        [::core::mem::offset_of!(sdc_hci_le_ext_adv_report_array_params_t, periodic_adv_interval) - 14usize];
    ["Offset of field: sdc_hci_le_ext_adv_report_array_params_t::direct_address_type"]
        [::core::mem::offset_of!(sdc_hci_le_ext_adv_report_array_params_t, direct_address_type) - 16usize];
    ["Offset of field: sdc_hci_le_ext_adv_report_array_params_t::direct_address"]
        [::core::mem::offset_of!(sdc_hci_le_ext_adv_report_array_params_t, direct_address) - 17usize];
    ["Offset of field: sdc_hci_le_ext_adv_report_array_params_t::data_length"]
        [::core::mem::offset_of!(sdc_hci_le_ext_adv_report_array_params_t, data_length) - 23usize];
    ["Offset of field: sdc_hci_le_ext_adv_report_array_params_t::data"]
        [::core::mem::offset_of!(sdc_hci_le_ext_adv_report_array_params_t, data) - 24usize];
};
#[doc = "LE Extended Create Connection array parameters."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_le_ext_create_conn_array_params_t {
    pub scan_interval: u16,
    pub scan_window: u16,
    pub conn_interval_min: u16,
    pub conn_interval_max: u16,
    pub max_latency: u16,
    pub supervision_timeout: u16,
    pub min_ce_length: u16,
    pub max_ce_length: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_le_ext_create_conn_array_params_t"]
        [::core::mem::size_of::<sdc_hci_le_ext_create_conn_array_params_t>() - 16usize];
    ["Alignment of sdc_hci_le_ext_create_conn_array_params_t"]
        [::core::mem::align_of::<sdc_hci_le_ext_create_conn_array_params_t>() - 1usize];
    ["Offset of field: sdc_hci_le_ext_create_conn_array_params_t::scan_interval"]
        [::core::mem::offset_of!(sdc_hci_le_ext_create_conn_array_params_t, scan_interval) - 0usize];
    ["Offset of field: sdc_hci_le_ext_create_conn_array_params_t::scan_window"]
        [::core::mem::offset_of!(sdc_hci_le_ext_create_conn_array_params_t, scan_window) - 2usize];
    ["Offset of field: sdc_hci_le_ext_create_conn_array_params_t::conn_interval_min"]
        [::core::mem::offset_of!(sdc_hci_le_ext_create_conn_array_params_t, conn_interval_min) - 4usize];
    ["Offset of field: sdc_hci_le_ext_create_conn_array_params_t::conn_interval_max"]
        [::core::mem::offset_of!(sdc_hci_le_ext_create_conn_array_params_t, conn_interval_max) - 6usize];
    ["Offset of field: sdc_hci_le_ext_create_conn_array_params_t::max_latency"]
        [::core::mem::offset_of!(sdc_hci_le_ext_create_conn_array_params_t, max_latency) - 8usize];
    ["Offset of field: sdc_hci_le_ext_create_conn_array_params_t::supervision_timeout"]
        [::core::mem::offset_of!(sdc_hci_le_ext_create_conn_array_params_t, supervision_timeout) - 10usize];
    ["Offset of field: sdc_hci_le_ext_create_conn_array_params_t::min_ce_length"]
        [::core::mem::offset_of!(sdc_hci_le_ext_create_conn_array_params_t, min_ce_length) - 12usize];
    ["Offset of field: sdc_hci_le_ext_create_conn_array_params_t::max_ce_length"]
        [::core::mem::offset_of!(sdc_hci_le_ext_create_conn_array_params_t, max_ce_length) - 14usize];
};
#[doc = "LE Extended Create Connection array parameters."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_le_ext_create_conn_v2_array_params_t {
    pub scan_interval: u16,
    pub scan_window: u16,
    pub conn_interval_min: u16,
    pub conn_interval_max: u16,
    pub max_latency: u16,
    pub supervision_timeout: u16,
    pub min_ce_length: u16,
    pub max_ce_length: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_le_ext_create_conn_v2_array_params_t"]
        [::core::mem::size_of::<sdc_hci_le_ext_create_conn_v2_array_params_t>() - 16usize];
    ["Alignment of sdc_hci_le_ext_create_conn_v2_array_params_t"]
        [::core::mem::align_of::<sdc_hci_le_ext_create_conn_v2_array_params_t>() - 1usize];
    ["Offset of field: sdc_hci_le_ext_create_conn_v2_array_params_t::scan_interval"]
        [::core::mem::offset_of!(sdc_hci_le_ext_create_conn_v2_array_params_t, scan_interval) - 0usize];
    ["Offset of field: sdc_hci_le_ext_create_conn_v2_array_params_t::scan_window"]
        [::core::mem::offset_of!(sdc_hci_le_ext_create_conn_v2_array_params_t, scan_window) - 2usize];
    ["Offset of field: sdc_hci_le_ext_create_conn_v2_array_params_t::conn_interval_min"]
        [::core::mem::offset_of!(sdc_hci_le_ext_create_conn_v2_array_params_t, conn_interval_min) - 4usize];
    ["Offset of field: sdc_hci_le_ext_create_conn_v2_array_params_t::conn_interval_max"]
        [::core::mem::offset_of!(sdc_hci_le_ext_create_conn_v2_array_params_t, conn_interval_max) - 6usize];
    ["Offset of field: sdc_hci_le_ext_create_conn_v2_array_params_t::max_latency"]
        [::core::mem::offset_of!(sdc_hci_le_ext_create_conn_v2_array_params_t, max_latency) - 8usize];
    ["Offset of field: sdc_hci_le_ext_create_conn_v2_array_params_t::supervision_timeout"]
        [::core::mem::offset_of!(sdc_hci_le_ext_create_conn_v2_array_params_t, supervision_timeout) - 10usize];
    ["Offset of field: sdc_hci_le_ext_create_conn_v2_array_params_t::min_ce_length"]
        [::core::mem::offset_of!(sdc_hci_le_ext_create_conn_v2_array_params_t, min_ce_length) - 12usize];
    ["Offset of field: sdc_hci_le_ext_create_conn_v2_array_params_t::max_ce_length"]
        [::core::mem::offset_of!(sdc_hci_le_ext_create_conn_v2_array_params_t, max_ce_length) - 14usize];
};
#[doc = "LE event mask.\n\n If the bit in the Event_Mask is set to a one,\n then the event associated with that bit will be enabled."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_le_le_event_mask_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 6usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_le_le_event_mask_t"][::core::mem::size_of::<sdc_hci_le_le_event_mask_t>() - 6usize];
    ["Alignment of sdc_hci_le_le_event_mask_t"][::core::mem::align_of::<sdc_hci_le_le_event_mask_t>() - 1usize];
};
impl sdc_hci_le_le_event_mask_t {
    #[inline]
    pub fn le_connection_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_connection_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_connection_complete_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_connection_complete_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_advertising_report_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_advertising_report_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_advertising_report_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_advertising_report_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_connection_update_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_connection_update_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_connection_update_complete_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_connection_update_complete_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_read_remote_features_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_read_remote_features_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_read_remote_features_complete_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_read_remote_features_complete_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_long_term_key_request_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_long_term_key_request_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_long_term_key_request_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_long_term_key_request_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_remote_connection_parameter_request_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_remote_connection_parameter_request_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_remote_connection_parameter_request_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_remote_connection_parameter_request_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_data_length_change_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_data_length_change_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_data_length_change_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_data_length_change_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_read_local_p256_public_key_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_read_local_p256_public_key_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_read_local_p256_public_key_complete_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_read_local_p256_public_key_complete_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_generate_dhkey_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_generate_dhkey_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_generate_dhkey_complete_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_generate_dhkey_complete_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_enhanced_connection_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_enhanced_connection_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_enhanced_connection_complete_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_enhanced_connection_complete_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_directed_advertising_report_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_directed_advertising_report_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_directed_advertising_report_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_directed_advertising_report_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_phy_update_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_phy_update_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_phy_update_complete_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_phy_update_complete_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_extended_advertising_report_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_extended_advertising_report_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_extended_advertising_report_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_extended_advertising_report_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_periodic_advertising_sync_established_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_periodic_advertising_sync_established_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_periodic_advertising_sync_established_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_periodic_advertising_sync_established_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_periodic_advertising_report_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_periodic_advertising_report_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_periodic_advertising_report_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_periodic_advertising_report_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_periodic_advertising_sync_lost_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_periodic_advertising_sync_lost_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_periodic_advertising_sync_lost_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_periodic_advertising_sync_lost_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_scan_timeout_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_scan_timeout_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_scan_timeout_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_scan_timeout_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_advertising_set_terminated_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_advertising_set_terminated_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_advertising_set_terminated_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_advertising_set_terminated_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_scan_request_received_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_scan_request_received_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_scan_request_received_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_scan_request_received_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_channel_selection_algorithm_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_channel_selection_algorithm_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_channel_selection_algorithm_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_channel_selection_algorithm_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_connectionless_iq_report_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_connectionless_iq_report_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_connectionless_iq_report_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_connectionless_iq_report_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_connection_iq_report_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_connection_iq_report_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_connection_iq_report_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_connection_iq_report_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_cte_request_failed_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_cte_request_failed_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_cte_request_failed_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_cte_request_failed_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_periodic_advertising_sync_transfer_received_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_periodic_advertising_sync_transfer_received_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_periodic_advertising_sync_transfer_received_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_periodic_advertising_sync_transfer_received_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_cis_established_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_cis_established_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_cis_established_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_cis_established_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_cis_request_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_cis_request_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_cis_request_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                25usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_cis_request_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_create_big_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_create_big_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_create_big_complete_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_create_big_complete_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_terminate_big_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_terminate_big_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_terminate_big_complete_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                27usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_terminate_big_complete_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                27usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_big_sync_established_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_big_sync_established_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_big_sync_established_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_big_sync_established_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_big_sync_lost_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_big_sync_lost_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_big_sync_lost_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                29usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_big_sync_lost_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                29usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_request_peer_sca_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_request_peer_sca_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_request_peer_sca_complete_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_request_peer_sca_complete_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_path_loss_threshold_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_path_loss_threshold_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_path_loss_threshold_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_path_loss_threshold_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_transmit_power_reporting_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_transmit_power_reporting_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_transmit_power_reporting_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_transmit_power_reporting_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_biginfo_advertising_report_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_biginfo_advertising_report_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_biginfo_advertising_report_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                33usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_biginfo_advertising_report_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                33usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_subrate_change_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_subrate_change_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_subrate_change_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                34usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_subrate_change_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                34usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_periodic_advertising_sync_established_event_v2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_periodic_advertising_sync_established_event_v2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_periodic_advertising_sync_established_event_v2_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                35usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_periodic_advertising_sync_established_event_v2_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                35usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_periodic_advertising_report_event_v2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_periodic_advertising_report_event_v2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_periodic_advertising_report_event_v2_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                36usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_periodic_advertising_report_event_v2_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                36usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_periodic_advertising_sync_transfer_received_event_v2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_periodic_advertising_sync_transfer_received_event_v2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_periodic_advertising_sync_transfer_received_event_v2_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                37usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_periodic_advertising_sync_transfer_received_event_v2_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                37usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_periodic_advertising_subevent_data_request_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_periodic_advertising_subevent_data_request_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_periodic_advertising_subevent_data_request_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                38usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_periodic_advertising_subevent_data_request_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                38usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_periodic_advertising_response_report_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_periodic_advertising_response_report_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_periodic_advertising_response_report_event_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                39usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_periodic_advertising_response_report_event_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                39usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_enhanced_connection_complete_event_v2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(40usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_enhanced_connection_complete_event_v2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(40usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_enhanced_connection_complete_event_v2_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                40usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_enhanced_connection_complete_event_v2_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                40usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        le_connection_complete_event: u8,
        le_advertising_report_event: u8,
        le_connection_update_complete_event: u8,
        le_read_remote_features_complete_event: u8,
        le_long_term_key_request_event: u8,
        le_remote_connection_parameter_request_event: u8,
        le_data_length_change_event: u8,
        le_read_local_p256_public_key_complete_event: u8,
        le_generate_dhkey_complete_event: u8,
        le_enhanced_connection_complete_event: u8,
        le_directed_advertising_report_event: u8,
        le_phy_update_complete_event: u8,
        le_extended_advertising_report_event: u8,
        le_periodic_advertising_sync_established_event: u8,
        le_periodic_advertising_report_event: u8,
        le_periodic_advertising_sync_lost_event: u8,
        le_scan_timeout_event: u8,
        le_advertising_set_terminated_event: u8,
        le_scan_request_received_event: u8,
        le_channel_selection_algorithm_event: u8,
        le_connectionless_iq_report_event: u8,
        le_connection_iq_report_event: u8,
        le_cte_request_failed_event: u8,
        le_periodic_advertising_sync_transfer_received_event: u8,
        le_cis_established_event: u8,
        le_cis_request_event: u8,
        le_create_big_complete_event: u8,
        le_terminate_big_complete_event: u8,
        le_big_sync_established_event: u8,
        le_big_sync_lost_event: u8,
        le_request_peer_sca_complete_event: u8,
        le_path_loss_threshold_event: u8,
        le_transmit_power_reporting_event: u8,
        le_biginfo_advertising_report_event: u8,
        le_subrate_change_event: u8,
        le_periodic_advertising_sync_established_event_v2: u8,
        le_periodic_advertising_report_event_v2: u8,
        le_periodic_advertising_sync_transfer_received_event_v2: u8,
        le_periodic_advertising_subevent_data_request_event: u8,
        le_periodic_advertising_response_report_event: u8,
        le_enhanced_connection_complete_event_v2: u8,
    ) -> __BindgenBitfieldUnit<[u8; 6usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 6usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let le_connection_complete_event: u8 = unsafe { ::core::mem::transmute(le_connection_complete_event) };
            le_connection_complete_event as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let le_advertising_report_event: u8 = unsafe { ::core::mem::transmute(le_advertising_report_event) };
            le_advertising_report_event as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let le_connection_update_complete_event: u8 =
                unsafe { ::core::mem::transmute(le_connection_update_complete_event) };
            le_connection_update_complete_event as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let le_read_remote_features_complete_event: u8 =
                unsafe { ::core::mem::transmute(le_read_remote_features_complete_event) };
            le_read_remote_features_complete_event as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let le_long_term_key_request_event: u8 = unsafe { ::core::mem::transmute(le_long_term_key_request_event) };
            le_long_term_key_request_event as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let le_remote_connection_parameter_request_event: u8 =
                unsafe { ::core::mem::transmute(le_remote_connection_parameter_request_event) };
            le_remote_connection_parameter_request_event as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let le_data_length_change_event: u8 = unsafe { ::core::mem::transmute(le_data_length_change_event) };
            le_data_length_change_event as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let le_read_local_p256_public_key_complete_event: u8 =
                unsafe { ::core::mem::transmute(le_read_local_p256_public_key_complete_event) };
            le_read_local_p256_public_key_complete_event as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let le_generate_dhkey_complete_event: u8 =
                unsafe { ::core::mem::transmute(le_generate_dhkey_complete_event) };
            le_generate_dhkey_complete_event as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let le_enhanced_connection_complete_event: u8 =
                unsafe { ::core::mem::transmute(le_enhanced_connection_complete_event) };
            le_enhanced_connection_complete_event as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let le_directed_advertising_report_event: u8 =
                unsafe { ::core::mem::transmute(le_directed_advertising_report_event) };
            le_directed_advertising_report_event as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let le_phy_update_complete_event: u8 = unsafe { ::core::mem::transmute(le_phy_update_complete_event) };
            le_phy_update_complete_event as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let le_extended_advertising_report_event: u8 =
                unsafe { ::core::mem::transmute(le_extended_advertising_report_event) };
            le_extended_advertising_report_event as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let le_periodic_advertising_sync_established_event: u8 =
                unsafe { ::core::mem::transmute(le_periodic_advertising_sync_established_event) };
            le_periodic_advertising_sync_established_event as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let le_periodic_advertising_report_event: u8 =
                unsafe { ::core::mem::transmute(le_periodic_advertising_report_event) };
            le_periodic_advertising_report_event as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let le_periodic_advertising_sync_lost_event: u8 =
                unsafe { ::core::mem::transmute(le_periodic_advertising_sync_lost_event) };
            le_periodic_advertising_sync_lost_event as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let le_scan_timeout_event: u8 = unsafe { ::core::mem::transmute(le_scan_timeout_event) };
            le_scan_timeout_event as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let le_advertising_set_terminated_event: u8 =
                unsafe { ::core::mem::transmute(le_advertising_set_terminated_event) };
            le_advertising_set_terminated_event as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let le_scan_request_received_event: u8 = unsafe { ::core::mem::transmute(le_scan_request_received_event) };
            le_scan_request_received_event as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let le_channel_selection_algorithm_event: u8 =
                unsafe { ::core::mem::transmute(le_channel_selection_algorithm_event) };
            le_channel_selection_algorithm_event as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let le_connectionless_iq_report_event: u8 =
                unsafe { ::core::mem::transmute(le_connectionless_iq_report_event) };
            le_connectionless_iq_report_event as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let le_connection_iq_report_event: u8 = unsafe { ::core::mem::transmute(le_connection_iq_report_event) };
            le_connection_iq_report_event as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let le_cte_request_failed_event: u8 = unsafe { ::core::mem::transmute(le_cte_request_failed_event) };
            le_cte_request_failed_event as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let le_periodic_advertising_sync_transfer_received_event: u8 =
                unsafe { ::core::mem::transmute(le_periodic_advertising_sync_transfer_received_event) };
            le_periodic_advertising_sync_transfer_received_event as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let le_cis_established_event: u8 = unsafe { ::core::mem::transmute(le_cis_established_event) };
            le_cis_established_event as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let le_cis_request_event: u8 = unsafe { ::core::mem::transmute(le_cis_request_event) };
            le_cis_request_event as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let le_create_big_complete_event: u8 = unsafe { ::core::mem::transmute(le_create_big_complete_event) };
            le_create_big_complete_event as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let le_terminate_big_complete_event: u8 =
                unsafe { ::core::mem::transmute(le_terminate_big_complete_event) };
            le_terminate_big_complete_event as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let le_big_sync_established_event: u8 = unsafe { ::core::mem::transmute(le_big_sync_established_event) };
            le_big_sync_established_event as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let le_big_sync_lost_event: u8 = unsafe { ::core::mem::transmute(le_big_sync_lost_event) };
            le_big_sync_lost_event as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let le_request_peer_sca_complete_event: u8 =
                unsafe { ::core::mem::transmute(le_request_peer_sca_complete_event) };
            le_request_peer_sca_complete_event as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let le_path_loss_threshold_event: u8 = unsafe { ::core::mem::transmute(le_path_loss_threshold_event) };
            le_path_loss_threshold_event as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let le_transmit_power_reporting_event: u8 =
                unsafe { ::core::mem::transmute(le_transmit_power_reporting_event) };
            le_transmit_power_reporting_event as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let le_biginfo_advertising_report_event: u8 =
                unsafe { ::core::mem::transmute(le_biginfo_advertising_report_event) };
            le_biginfo_advertising_report_event as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let le_subrate_change_event: u8 = unsafe { ::core::mem::transmute(le_subrate_change_event) };
            le_subrate_change_event as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let le_periodic_advertising_sync_established_event_v2: u8 =
                unsafe { ::core::mem::transmute(le_periodic_advertising_sync_established_event_v2) };
            le_periodic_advertising_sync_established_event_v2 as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let le_periodic_advertising_report_event_v2: u8 =
                unsafe { ::core::mem::transmute(le_periodic_advertising_report_event_v2) };
            le_periodic_advertising_report_event_v2 as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let le_periodic_advertising_sync_transfer_received_event_v2: u8 =
                unsafe { ::core::mem::transmute(le_periodic_advertising_sync_transfer_received_event_v2) };
            le_periodic_advertising_sync_transfer_received_event_v2 as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let le_periodic_advertising_subevent_data_request_event: u8 =
                unsafe { ::core::mem::transmute(le_periodic_advertising_subevent_data_request_event) };
            le_periodic_advertising_subevent_data_request_event as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let le_periodic_advertising_response_report_event: u8 =
                unsafe { ::core::mem::transmute(le_periodic_advertising_response_report_event) };
            le_periodic_advertising_response_report_event as u64
        });
        __bindgen_bitfield_unit.set(40usize, 1u8, {
            let le_enhanced_connection_complete_event_v2: u8 =
                unsafe { ::core::mem::transmute(le_enhanced_connection_complete_event_v2) };
            le_enhanced_connection_complete_event_v2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "LE features.\n\n See Core_v6.0, Vol 6, Part B, Section 4.6"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_le_le_features_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_le_le_features_t"][::core::mem::size_of::<sdc_hci_le_le_features_t>() - 8usize];
    ["Alignment of sdc_hci_le_le_features_t"][::core::mem::align_of::<sdc_hci_le_le_features_t>() - 1usize];
};
impl sdc_hci_le_le_features_t {
    #[inline]
    pub fn le_encryption(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_encryption(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_encryption_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_encryption_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn connection_parameters_request(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_connection_parameters_request(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn connection_parameters_request_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_connection_parameters_request_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn extended_reject_indication(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_extended_reject_indication(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn extended_reject_indication_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_extended_reject_indication_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn slave_initiated_features_exchange(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_slave_initiated_features_exchange(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn slave_initiated_features_exchange_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_slave_initiated_features_exchange_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_ping(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_ping(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_ping_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_ping_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_data_packet_length_extension(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_data_packet_length_extension(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_data_packet_length_extension_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_data_packet_length_extension_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ll_privacy(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ll_privacy(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ll_privacy_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ll_privacy_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn extended_scanner_filter_policies(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_extended_scanner_filter_policies(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn extended_scanner_filter_policies_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_extended_scanner_filter_policies_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_2m_phy(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_2m_phy(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_2m_phy_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_2m_phy_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn stable_modulation_index_transmitter(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_stable_modulation_index_transmitter(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn stable_modulation_index_transmitter_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_stable_modulation_index_transmitter_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn stable_modulation_index_receiver(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_stable_modulation_index_receiver(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn stable_modulation_index_receiver_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_stable_modulation_index_receiver_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_coded_phy(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_coded_phy(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_coded_phy_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_coded_phy_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_extended_advertising(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_extended_advertising(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_extended_advertising_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_extended_advertising_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_periodic_advertising(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_periodic_advertising(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_periodic_advertising_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_periodic_advertising_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn channel_selection_algorithm_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_channel_selection_algorithm_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn channel_selection_algorithm_2_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_channel_selection_algorithm_2_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_Power_class_1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_Power_class_1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_Power_class_1_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_Power_class_1_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn minimum_number_of_used_channels_procedure(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_minimum_number_of_used_channels_procedure(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn minimum_number_of_used_channels_procedure_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_minimum_number_of_used_channels_procedure_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn connection_cte_request(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_connection_cte_request(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn connection_cte_request_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_connection_cte_request_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn connection_cte_response(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_connection_cte_response(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn connection_cte_response_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_connection_cte_response_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn connectionless_cte_transmitter(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_connectionless_cte_transmitter(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn connectionless_cte_transmitter_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_connectionless_cte_transmitter_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn connectionless_cte_receiver(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_connectionless_cte_receiver(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn connectionless_cte_receiver_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_connectionless_cte_receiver_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn antenna_switching_during_cte_transmission_aod(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_antenna_switching_during_cte_transmission_aod(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn antenna_switching_during_cte_transmission_aod_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_antenna_switching_during_cte_transmission_aod_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn antenna_switching_during_cte_reception_aoa(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_antenna_switching_during_cte_reception_aoa(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn antenna_switching_during_cte_reception_aoa_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_antenna_switching_during_cte_reception_aoa_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn receiving_constant_tone_extensions(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_receiving_constant_tone_extensions(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn receiving_constant_tone_extensions_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_receiving_constant_tone_extensions_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn periodic_advertising_sync_transfer_sender(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_periodic_advertising_sync_transfer_sender(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn periodic_advertising_sync_transfer_sender_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_periodic_advertising_sync_transfer_sender_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn periodic_advertising_sync_transfer_recipient(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_periodic_advertising_sync_transfer_recipient(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn periodic_advertising_sync_transfer_recipient_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                25usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_periodic_advertising_sync_transfer_recipient_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sleep_clock_accuracy_updates(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sleep_clock_accuracy_updates(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sleep_clock_accuracy_updates_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_sleep_clock_accuracy_updates_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn remote_public_key_validation(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_remote_public_key_validation(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn remote_public_key_validation_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                27usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_remote_public_key_validation_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                27usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn connected_isochronous_stream_master(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_connected_isochronous_stream_master(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn connected_isochronous_stream_master_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_connected_isochronous_stream_master_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn connected_isochronous_stream_slave(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_connected_isochronous_stream_slave(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn connected_isochronous_stream_slave_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                29usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_connected_isochronous_stream_slave_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                29usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn isochronous_broadcaster(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isochronous_broadcaster(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn isochronous_broadcaster_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_isochronous_broadcaster_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn synchronized_receiver(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_synchronized_receiver(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn synchronized_receiver_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_synchronized_receiver_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn isochronous_channels_host_support(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isochronous_channels_host_support(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn isochronous_channels_host_support_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_isochronous_channels_host_support_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_power_control_request(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_power_control_request(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_power_control_request_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                33usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_power_control_request_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                33usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_power_change_indication(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_power_change_indication(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_power_change_indication_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                34usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_power_change_indication_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                34usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn le_path_loss_monitoring(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_path_loss_monitoring(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn le_path_loss_monitoring_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                35usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_le_path_loss_monitoring_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                35usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn periodic_advertising_adi_support(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_periodic_advertising_adi_support(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn periodic_advertising_adi_support_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                36usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_periodic_advertising_adi_support_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                36usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn connection_subrating(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_connection_subrating(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn connection_subrating_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                37usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_connection_subrating_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                37usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn connection_subrating_host_support(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_connection_subrating_host_support(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn connection_subrating_host_support_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                38usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_connection_subrating_host_support_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                38usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn channel_classification(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_channel_classification(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn channel_classification_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                39usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_channel_classification_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                39usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn advertising_coding_selection(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(40usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_advertising_coding_selection(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(40usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn advertising_coding_selection_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                40usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_advertising_coding_selection_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                40usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn advertising_coding_selection_host_support(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(41usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_advertising_coding_selection_host_support(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn advertising_coding_selection_host_support_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                41usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_advertising_coding_selection_host_support_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                41usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn decision_based_advertising_filtering(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(42usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_decision_based_advertising_filtering(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(42usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn decision_based_advertising_filtering_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                42usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_decision_based_advertising_filtering_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                42usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn periodic_advertising_with_responses_advertiser(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(43usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_periodic_advertising_with_responses_advertiser(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(43usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn periodic_advertising_with_responses_advertiser_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                43usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_periodic_advertising_with_responses_advertiser_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                43usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn periodic_advertising_with_responses_scanner(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(44usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_periodic_advertising_with_responses_scanner(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(44usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn periodic_advertising_with_responses_scanner_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                44usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_periodic_advertising_with_responses_scanner_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                44usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn unsegmented_framed_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(45usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_unsegmented_framed_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(45usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn unsegmented_framed_mode_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                45usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_unsegmented_framed_mode_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                45usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn channel_sounding(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(46usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_channel_sounding(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(46usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn channel_sounding_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                46usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_channel_sounding_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                46usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn channel_sounding_host_support(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(47usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_channel_sounding_host_support(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(47usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn channel_sounding_host_support_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                47usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_channel_sounding_host_support_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                47usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn channel_sounding_tone_quality_indication(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(48usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_channel_sounding_tone_quality_indication(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(48usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn channel_sounding_tone_quality_indication_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                48usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_channel_sounding_tone_quality_indication_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                48usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu56(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(49usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu56(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(49usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu56_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                49usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu56_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                49usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu57(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(50usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu57(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(50usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu57_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                50usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu57_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                50usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu58(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(51usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu58(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(51usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu58_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                51usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu58_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                51usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu59(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(52usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu59(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(52usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu59_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                52usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu59_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                52usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu60(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu60(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu60_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                53usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu60_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                53usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu61(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(54usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu61(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(54usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu61_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                54usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu61_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                54usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu62(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(55usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu62(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(55usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu62_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                55usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu62_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                55usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ll_extended_feature_set(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(56usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ll_extended_feature_set(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(56usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ll_extended_feature_set_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                56usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ll_extended_feature_set_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                56usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        le_encryption: u8,
        connection_parameters_request: u8,
        extended_reject_indication: u8,
        slave_initiated_features_exchange: u8,
        le_ping: u8,
        le_data_packet_length_extension: u8,
        ll_privacy: u8,
        extended_scanner_filter_policies: u8,
        le_2m_phy: u8,
        stable_modulation_index_transmitter: u8,
        stable_modulation_index_receiver: u8,
        le_coded_phy: u8,
        le_extended_advertising: u8,
        le_periodic_advertising: u8,
        channel_selection_algorithm_2: u8,
        le_Power_class_1: u8,
        minimum_number_of_used_channels_procedure: u8,
        connection_cte_request: u8,
        connection_cte_response: u8,
        connectionless_cte_transmitter: u8,
        connectionless_cte_receiver: u8,
        antenna_switching_during_cte_transmission_aod: u8,
        antenna_switching_during_cte_reception_aoa: u8,
        receiving_constant_tone_extensions: u8,
        periodic_advertising_sync_transfer_sender: u8,
        periodic_advertising_sync_transfer_recipient: u8,
        sleep_clock_accuracy_updates: u8,
        remote_public_key_validation: u8,
        connected_isochronous_stream_master: u8,
        connected_isochronous_stream_slave: u8,
        isochronous_broadcaster: u8,
        synchronized_receiver: u8,
        isochronous_channels_host_support: u8,
        le_power_control_request: u8,
        le_power_change_indication: u8,
        le_path_loss_monitoring: u8,
        periodic_advertising_adi_support: u8,
        connection_subrating: u8,
        connection_subrating_host_support: u8,
        channel_classification: u8,
        advertising_coding_selection: u8,
        advertising_coding_selection_host_support: u8,
        decision_based_advertising_filtering: u8,
        periodic_advertising_with_responses_advertiser: u8,
        periodic_advertising_with_responses_scanner: u8,
        unsegmented_framed_mode: u8,
        channel_sounding: u8,
        channel_sounding_host_support: u8,
        channel_sounding_tone_quality_indication: u8,
        rfu56: u8,
        rfu57: u8,
        rfu58: u8,
        rfu59: u8,
        rfu60: u8,
        rfu61: u8,
        rfu62: u8,
        ll_extended_feature_set: u8,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let le_encryption: u8 = unsafe { ::core::mem::transmute(le_encryption) };
            le_encryption as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let connection_parameters_request: u8 = unsafe { ::core::mem::transmute(connection_parameters_request) };
            connection_parameters_request as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let extended_reject_indication: u8 = unsafe { ::core::mem::transmute(extended_reject_indication) };
            extended_reject_indication as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let slave_initiated_features_exchange: u8 =
                unsafe { ::core::mem::transmute(slave_initiated_features_exchange) };
            slave_initiated_features_exchange as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let le_ping: u8 = unsafe { ::core::mem::transmute(le_ping) };
            le_ping as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let le_data_packet_length_extension: u8 =
                unsafe { ::core::mem::transmute(le_data_packet_length_extension) };
            le_data_packet_length_extension as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ll_privacy: u8 = unsafe { ::core::mem::transmute(ll_privacy) };
            ll_privacy as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let extended_scanner_filter_policies: u8 =
                unsafe { ::core::mem::transmute(extended_scanner_filter_policies) };
            extended_scanner_filter_policies as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let le_2m_phy: u8 = unsafe { ::core::mem::transmute(le_2m_phy) };
            le_2m_phy as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let stable_modulation_index_transmitter: u8 =
                unsafe { ::core::mem::transmute(stable_modulation_index_transmitter) };
            stable_modulation_index_transmitter as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let stable_modulation_index_receiver: u8 =
                unsafe { ::core::mem::transmute(stable_modulation_index_receiver) };
            stable_modulation_index_receiver as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let le_coded_phy: u8 = unsafe { ::core::mem::transmute(le_coded_phy) };
            le_coded_phy as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let le_extended_advertising: u8 = unsafe { ::core::mem::transmute(le_extended_advertising) };
            le_extended_advertising as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let le_periodic_advertising: u8 = unsafe { ::core::mem::transmute(le_periodic_advertising) };
            le_periodic_advertising as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let channel_selection_algorithm_2: u8 = unsafe { ::core::mem::transmute(channel_selection_algorithm_2) };
            channel_selection_algorithm_2 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let le_Power_class_1: u8 = unsafe { ::core::mem::transmute(le_Power_class_1) };
            le_Power_class_1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let minimum_number_of_used_channels_procedure: u8 =
                unsafe { ::core::mem::transmute(minimum_number_of_used_channels_procedure) };
            minimum_number_of_used_channels_procedure as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let connection_cte_request: u8 = unsafe { ::core::mem::transmute(connection_cte_request) };
            connection_cte_request as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let connection_cte_response: u8 = unsafe { ::core::mem::transmute(connection_cte_response) };
            connection_cte_response as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let connectionless_cte_transmitter: u8 = unsafe { ::core::mem::transmute(connectionless_cte_transmitter) };
            connectionless_cte_transmitter as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let connectionless_cte_receiver: u8 = unsafe { ::core::mem::transmute(connectionless_cte_receiver) };
            connectionless_cte_receiver as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let antenna_switching_during_cte_transmission_aod: u8 =
                unsafe { ::core::mem::transmute(antenna_switching_during_cte_transmission_aod) };
            antenna_switching_during_cte_transmission_aod as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let antenna_switching_during_cte_reception_aoa: u8 =
                unsafe { ::core::mem::transmute(antenna_switching_during_cte_reception_aoa) };
            antenna_switching_during_cte_reception_aoa as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let receiving_constant_tone_extensions: u8 =
                unsafe { ::core::mem::transmute(receiving_constant_tone_extensions) };
            receiving_constant_tone_extensions as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let periodic_advertising_sync_transfer_sender: u8 =
                unsafe { ::core::mem::transmute(periodic_advertising_sync_transfer_sender) };
            periodic_advertising_sync_transfer_sender as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let periodic_advertising_sync_transfer_recipient: u8 =
                unsafe { ::core::mem::transmute(periodic_advertising_sync_transfer_recipient) };
            periodic_advertising_sync_transfer_recipient as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let sleep_clock_accuracy_updates: u8 = unsafe { ::core::mem::transmute(sleep_clock_accuracy_updates) };
            sleep_clock_accuracy_updates as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let remote_public_key_validation: u8 = unsafe { ::core::mem::transmute(remote_public_key_validation) };
            remote_public_key_validation as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let connected_isochronous_stream_master: u8 =
                unsafe { ::core::mem::transmute(connected_isochronous_stream_master) };
            connected_isochronous_stream_master as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let connected_isochronous_stream_slave: u8 =
                unsafe { ::core::mem::transmute(connected_isochronous_stream_slave) };
            connected_isochronous_stream_slave as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let isochronous_broadcaster: u8 = unsafe { ::core::mem::transmute(isochronous_broadcaster) };
            isochronous_broadcaster as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let synchronized_receiver: u8 = unsafe { ::core::mem::transmute(synchronized_receiver) };
            synchronized_receiver as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let isochronous_channels_host_support: u8 =
                unsafe { ::core::mem::transmute(isochronous_channels_host_support) };
            isochronous_channels_host_support as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let le_power_control_request: u8 = unsafe { ::core::mem::transmute(le_power_control_request) };
            le_power_control_request as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let le_power_change_indication: u8 = unsafe { ::core::mem::transmute(le_power_change_indication) };
            le_power_change_indication as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let le_path_loss_monitoring: u8 = unsafe { ::core::mem::transmute(le_path_loss_monitoring) };
            le_path_loss_monitoring as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let periodic_advertising_adi_support: u8 =
                unsafe { ::core::mem::transmute(periodic_advertising_adi_support) };
            periodic_advertising_adi_support as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let connection_subrating: u8 = unsafe { ::core::mem::transmute(connection_subrating) };
            connection_subrating as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let connection_subrating_host_support: u8 =
                unsafe { ::core::mem::transmute(connection_subrating_host_support) };
            connection_subrating_host_support as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let channel_classification: u8 = unsafe { ::core::mem::transmute(channel_classification) };
            channel_classification as u64
        });
        __bindgen_bitfield_unit.set(40usize, 1u8, {
            let advertising_coding_selection: u8 = unsafe { ::core::mem::transmute(advertising_coding_selection) };
            advertising_coding_selection as u64
        });
        __bindgen_bitfield_unit.set(41usize, 1u8, {
            let advertising_coding_selection_host_support: u8 =
                unsafe { ::core::mem::transmute(advertising_coding_selection_host_support) };
            advertising_coding_selection_host_support as u64
        });
        __bindgen_bitfield_unit.set(42usize, 1u8, {
            let decision_based_advertising_filtering: u8 =
                unsafe { ::core::mem::transmute(decision_based_advertising_filtering) };
            decision_based_advertising_filtering as u64
        });
        __bindgen_bitfield_unit.set(43usize, 1u8, {
            let periodic_advertising_with_responses_advertiser: u8 =
                unsafe { ::core::mem::transmute(periodic_advertising_with_responses_advertiser) };
            periodic_advertising_with_responses_advertiser as u64
        });
        __bindgen_bitfield_unit.set(44usize, 1u8, {
            let periodic_advertising_with_responses_scanner: u8 =
                unsafe { ::core::mem::transmute(periodic_advertising_with_responses_scanner) };
            periodic_advertising_with_responses_scanner as u64
        });
        __bindgen_bitfield_unit.set(45usize, 1u8, {
            let unsegmented_framed_mode: u8 = unsafe { ::core::mem::transmute(unsegmented_framed_mode) };
            unsegmented_framed_mode as u64
        });
        __bindgen_bitfield_unit.set(46usize, 1u8, {
            let channel_sounding: u8 = unsafe { ::core::mem::transmute(channel_sounding) };
            channel_sounding as u64
        });
        __bindgen_bitfield_unit.set(47usize, 1u8, {
            let channel_sounding_host_support: u8 = unsafe { ::core::mem::transmute(channel_sounding_host_support) };
            channel_sounding_host_support as u64
        });
        __bindgen_bitfield_unit.set(48usize, 1u8, {
            let channel_sounding_tone_quality_indication: u8 =
                unsafe { ::core::mem::transmute(channel_sounding_tone_quality_indication) };
            channel_sounding_tone_quality_indication as u64
        });
        __bindgen_bitfield_unit.set(49usize, 1u8, {
            let rfu56: u8 = unsafe { ::core::mem::transmute(rfu56) };
            rfu56 as u64
        });
        __bindgen_bitfield_unit.set(50usize, 1u8, {
            let rfu57: u8 = unsafe { ::core::mem::transmute(rfu57) };
            rfu57 as u64
        });
        __bindgen_bitfield_unit.set(51usize, 1u8, {
            let rfu58: u8 = unsafe { ::core::mem::transmute(rfu58) };
            rfu58 as u64
        });
        __bindgen_bitfield_unit.set(52usize, 1u8, {
            let rfu59: u8 = unsafe { ::core::mem::transmute(rfu59) };
            rfu59 as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let rfu60: u8 = unsafe { ::core::mem::transmute(rfu60) };
            rfu60 as u64
        });
        __bindgen_bitfield_unit.set(54usize, 1u8, {
            let rfu61: u8 = unsafe { ::core::mem::transmute(rfu61) };
            rfu61 as u64
        });
        __bindgen_bitfield_unit.set(55usize, 1u8, {
            let rfu62: u8 = unsafe { ::core::mem::transmute(rfu62) };
            rfu62 as u64
        });
        __bindgen_bitfield_unit.set(56usize, 1u8, {
            let ll_extended_feature_set: u8 = unsafe { ::core::mem::transmute(ll_extended_feature_set) };
            ll_extended_feature_set as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Options parameters for HCI_LE_Periodic_Advertising_Create_Sync command."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_le_periodic_adv_create_sync_options_params_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_le_periodic_adv_create_sync_options_params_t"]
        [::core::mem::size_of::<sdc_hci_le_periodic_adv_create_sync_options_params_t>() - 1usize];
    ["Alignment of sdc_hci_le_periodic_adv_create_sync_options_params_t"]
        [::core::mem::align_of::<sdc_hci_le_periodic_adv_create_sync_options_params_t>() - 1usize];
};
impl sdc_hci_le_periodic_adv_create_sync_options_params_t {
    #[inline]
    pub fn use_periodic_adv_list(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_use_periodic_adv_list(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn use_periodic_adv_list_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_use_periodic_adv_list_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disable_reporting(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_disable_reporting(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disable_reporting_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_disable_reporting_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn duplicate_filter_initially_enabled(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_duplicate_filter_initially_enabled(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn duplicate_filter_initially_enabled_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_duplicate_filter_initially_enabled_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_rfu(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                5u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        use_periodic_adv_list: u8,
        disable_reporting: u8,
        duplicate_filter_initially_enabled: u8,
        rfu: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let use_periodic_adv_list: u8 = unsafe { ::core::mem::transmute(use_periodic_adv_list) };
            use_periodic_adv_list as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let disable_reporting: u8 = unsafe { ::core::mem::transmute(disable_reporting) };
            disable_reporting as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let duplicate_filter_initially_enabled: u8 =
                unsafe { ::core::mem::transmute(duplicate_filter_initially_enabled) };
            duplicate_filter_initially_enabled as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let rfu: u8 = unsafe { ::core::mem::transmute(rfu) };
            rfu as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "LE Set CIG Parameters array parameters."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_le_set_cig_params_array_params_t {
    pub cis_id: u8,
    pub max_sdu_c_to_p: u16,
    pub max_sdu_p_to_c: u16,
    pub phy_c_to_p: u8,
    pub phy_p_to_c: u8,
    pub rtn_c_to_p: u8,
    pub rtn_p_to_c: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_le_set_cig_params_array_params_t"]
        [::core::mem::size_of::<sdc_hci_le_set_cig_params_array_params_t>() - 9usize];
    ["Alignment of sdc_hci_le_set_cig_params_array_params_t"]
        [::core::mem::align_of::<sdc_hci_le_set_cig_params_array_params_t>() - 1usize];
    ["Offset of field: sdc_hci_le_set_cig_params_array_params_t::cis_id"]
        [::core::mem::offset_of!(sdc_hci_le_set_cig_params_array_params_t, cis_id) - 0usize];
    ["Offset of field: sdc_hci_le_set_cig_params_array_params_t::max_sdu_c_to_p"]
        [::core::mem::offset_of!(sdc_hci_le_set_cig_params_array_params_t, max_sdu_c_to_p) - 1usize];
    ["Offset of field: sdc_hci_le_set_cig_params_array_params_t::max_sdu_p_to_c"]
        [::core::mem::offset_of!(sdc_hci_le_set_cig_params_array_params_t, max_sdu_p_to_c) - 3usize];
    ["Offset of field: sdc_hci_le_set_cig_params_array_params_t::phy_c_to_p"]
        [::core::mem::offset_of!(sdc_hci_le_set_cig_params_array_params_t, phy_c_to_p) - 5usize];
    ["Offset of field: sdc_hci_le_set_cig_params_array_params_t::phy_p_to_c"]
        [::core::mem::offset_of!(sdc_hci_le_set_cig_params_array_params_t, phy_p_to_c) - 6usize];
    ["Offset of field: sdc_hci_le_set_cig_params_array_params_t::rtn_c_to_p"]
        [::core::mem::offset_of!(sdc_hci_le_set_cig_params_array_params_t, rtn_c_to_p) - 7usize];
    ["Offset of field: sdc_hci_le_set_cig_params_array_params_t::rtn_p_to_c"]
        [::core::mem::offset_of!(sdc_hci_le_set_cig_params_array_params_t, rtn_p_to_c) - 8usize];
};
#[doc = "LE Set CIG Parameters output array parameters."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_le_set_cig_params_output_array_params_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_le_set_cig_params_output_array_params_t"]
        [::core::mem::size_of::<sdc_hci_le_set_cig_params_output_array_params_t>() - 2usize];
    ["Alignment of sdc_hci_le_set_cig_params_output_array_params_t"]
        [::core::mem::align_of::<sdc_hci_le_set_cig_params_output_array_params_t>() - 1usize];
    ["Offset of field: sdc_hci_le_set_cig_params_output_array_params_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_le_set_cig_params_output_array_params_t, conn_handle) - 0usize];
};
#[doc = "LE Set CIG Parameters Test array parameters."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_le_set_cig_params_test_array_params_t {
    pub cis_id: u8,
    pub nse: u8,
    pub max_sdu_c_to_p: u16,
    pub max_sdu_p_to_c: u16,
    pub max_pdu_c_to_p: u16,
    pub max_pdu_p_to_c: u16,
    pub phy_c_to_p: u8,
    pub phy_p_to_c: u8,
    pub bn_c_to_p: u8,
    pub bn_p_to_c: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_le_set_cig_params_test_array_params_t"]
        [::core::mem::size_of::<sdc_hci_le_set_cig_params_test_array_params_t>() - 14usize];
    ["Alignment of sdc_hci_le_set_cig_params_test_array_params_t"]
        [::core::mem::align_of::<sdc_hci_le_set_cig_params_test_array_params_t>() - 1usize];
    ["Offset of field: sdc_hci_le_set_cig_params_test_array_params_t::cis_id"]
        [::core::mem::offset_of!(sdc_hci_le_set_cig_params_test_array_params_t, cis_id) - 0usize];
    ["Offset of field: sdc_hci_le_set_cig_params_test_array_params_t::nse"]
        [::core::mem::offset_of!(sdc_hci_le_set_cig_params_test_array_params_t, nse) - 1usize];
    ["Offset of field: sdc_hci_le_set_cig_params_test_array_params_t::max_sdu_c_to_p"]
        [::core::mem::offset_of!(sdc_hci_le_set_cig_params_test_array_params_t, max_sdu_c_to_p) - 2usize];
    ["Offset of field: sdc_hci_le_set_cig_params_test_array_params_t::max_sdu_p_to_c"]
        [::core::mem::offset_of!(sdc_hci_le_set_cig_params_test_array_params_t, max_sdu_p_to_c) - 4usize];
    ["Offset of field: sdc_hci_le_set_cig_params_test_array_params_t::max_pdu_c_to_p"]
        [::core::mem::offset_of!(sdc_hci_le_set_cig_params_test_array_params_t, max_pdu_c_to_p) - 6usize];
    ["Offset of field: sdc_hci_le_set_cig_params_test_array_params_t::max_pdu_p_to_c"]
        [::core::mem::offset_of!(sdc_hci_le_set_cig_params_test_array_params_t, max_pdu_p_to_c) - 8usize];
    ["Offset of field: sdc_hci_le_set_cig_params_test_array_params_t::phy_c_to_p"]
        [::core::mem::offset_of!(sdc_hci_le_set_cig_params_test_array_params_t, phy_c_to_p) - 10usize];
    ["Offset of field: sdc_hci_le_set_cig_params_test_array_params_t::phy_p_to_c"]
        [::core::mem::offset_of!(sdc_hci_le_set_cig_params_test_array_params_t, phy_p_to_c) - 11usize];
    ["Offset of field: sdc_hci_le_set_cig_params_test_array_params_t::bn_c_to_p"]
        [::core::mem::offset_of!(sdc_hci_le_set_cig_params_test_array_params_t, bn_c_to_p) - 12usize];
    ["Offset of field: sdc_hci_le_set_cig_params_test_array_params_t::bn_p_to_c"]
        [::core::mem::offset_of!(sdc_hci_le_set_cig_params_test_array_params_t, bn_p_to_c) - 13usize];
};
#[doc = "LE Set CIG Parameters Test output array parameters."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_le_set_cig_params_test_output_array_params_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_le_set_cig_params_test_output_array_params_t"]
        [::core::mem::size_of::<sdc_hci_le_set_cig_params_test_output_array_params_t>() - 2usize];
    ["Alignment of sdc_hci_le_set_cig_params_test_output_array_params_t"]
        [::core::mem::align_of::<sdc_hci_le_set_cig_params_test_output_array_params_t>() - 1usize];
    ["Offset of field: sdc_hci_le_set_cig_params_test_output_array_params_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_le_set_cig_params_test_output_array_params_t, conn_handle) - 0usize];
};
#[doc = "LE Set Connection CTE Transmit Parameters array parameters."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_le_set_conn_cte_transmit_params_array_params_t {
    pub antenna_ids: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_le_set_conn_cte_transmit_params_array_params_t"]
        [::core::mem::size_of::<sdc_hci_le_set_conn_cte_transmit_params_array_params_t>() - 1usize];
    ["Alignment of sdc_hci_le_set_conn_cte_transmit_params_array_params_t"]
        [::core::mem::align_of::<sdc_hci_le_set_conn_cte_transmit_params_array_params_t>() - 1usize];
    ["Offset of field: sdc_hci_le_set_conn_cte_transmit_params_array_params_t::antenna_ids"]
        [::core::mem::offset_of!(sdc_hci_le_set_conn_cte_transmit_params_array_params_t, antenna_ids) - 0usize];
};
#[doc = "LE Set Connectionless CTE Transmit Parameters array parameters."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_le_set_connless_cte_transmit_params_array_params_t {
    pub antenna_ids: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_le_set_connless_cte_transmit_params_array_params_t"]
        [::core::mem::size_of::<sdc_hci_le_set_connless_cte_transmit_params_array_params_t>() - 1usize];
    ["Alignment of sdc_hci_le_set_connless_cte_transmit_params_array_params_t"]
        [::core::mem::align_of::<sdc_hci_le_set_connless_cte_transmit_params_array_params_t>() - 1usize];
    ["Offset of field: sdc_hci_le_set_connless_cte_transmit_params_array_params_t::antenna_ids"]
        [::core::mem::offset_of!(sdc_hci_le_set_connless_cte_transmit_params_array_params_t, antenna_ids) - 0usize];
};
#[doc = "Change Reasons parameters for HCI_LE_Set_Data_Related_Address_Changes command."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_le_set_data_related_address_changes_reasons_params_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_le_set_data_related_address_changes_reasons_params_t"]
        [::core::mem::size_of::<sdc_hci_le_set_data_related_address_changes_reasons_params_t>() - 1usize];
    ["Alignment of sdc_hci_le_set_data_related_address_changes_reasons_params_t"]
        [::core::mem::align_of::<sdc_hci_le_set_data_related_address_changes_reasons_params_t>() - 1usize];
};
impl sdc_hci_le_set_data_related_address_changes_reasons_params_t {
    #[inline]
    pub fn change_on_adv_data_change(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_change_on_adv_data_change(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn change_on_adv_data_change_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_change_on_adv_data_change_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn change_on_scan_response_data_change(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_change_on_scan_response_data_change(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn change_on_scan_response_data_change_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_change_on_scan_response_data_change_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_rfu(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                6u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        change_on_adv_data_change: u8,
        change_on_scan_response_data_change: u8,
        rfu: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let change_on_adv_data_change: u8 = unsafe { ::core::mem::transmute(change_on_adv_data_change) };
            change_on_adv_data_change as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let change_on_scan_response_data_change: u8 =
                unsafe { ::core::mem::transmute(change_on_scan_response_data_change) };
            change_on_scan_response_data_change as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let rfu: u8 = unsafe { ::core::mem::transmute(rfu) };
            rfu as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "LE Set Extended Advertising Enable array parameters."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_le_set_ext_adv_enable_array_params_t {
    pub adv_handle: u8,
    pub duration: u16,
    pub max_ext_adv_events: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_le_set_ext_adv_enable_array_params_t"]
        [::core::mem::size_of::<sdc_hci_le_set_ext_adv_enable_array_params_t>() - 4usize];
    ["Alignment of sdc_hci_le_set_ext_adv_enable_array_params_t"]
        [::core::mem::align_of::<sdc_hci_le_set_ext_adv_enable_array_params_t>() - 1usize];
    ["Offset of field: sdc_hci_le_set_ext_adv_enable_array_params_t::adv_handle"]
        [::core::mem::offset_of!(sdc_hci_le_set_ext_adv_enable_array_params_t, adv_handle) - 0usize];
    ["Offset of field: sdc_hci_le_set_ext_adv_enable_array_params_t::duration"]
        [::core::mem::offset_of!(sdc_hci_le_set_ext_adv_enable_array_params_t, duration) - 1usize];
    ["Offset of field: sdc_hci_le_set_ext_adv_enable_array_params_t::max_ext_adv_events"]
        [::core::mem::offset_of!(sdc_hci_le_set_ext_adv_enable_array_params_t, max_ext_adv_events) - 3usize];
};
#[doc = "LE Set Extended Scan Parameters array parameters."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_le_set_ext_scan_params_array_params_t {
    pub scan_type: u8,
    pub scan_interval: u16,
    pub scan_window: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_le_set_ext_scan_params_array_params_t"]
        [::core::mem::size_of::<sdc_hci_le_set_ext_scan_params_array_params_t>() - 5usize];
    ["Alignment of sdc_hci_le_set_ext_scan_params_array_params_t"]
        [::core::mem::align_of::<sdc_hci_le_set_ext_scan_params_array_params_t>() - 1usize];
    ["Offset of field: sdc_hci_le_set_ext_scan_params_array_params_t::scan_type"]
        [::core::mem::offset_of!(sdc_hci_le_set_ext_scan_params_array_params_t, scan_type) - 0usize];
    ["Offset of field: sdc_hci_le_set_ext_scan_params_array_params_t::scan_interval"]
        [::core::mem::offset_of!(sdc_hci_le_set_ext_scan_params_array_params_t, scan_interval) - 1usize];
    ["Offset of field: sdc_hci_le_set_ext_scan_params_array_params_t::scan_window"]
        [::core::mem::offset_of!(sdc_hci_le_set_ext_scan_params_array_params_t, scan_window) - 3usize];
};
#[doc = "Enable parameters for HCI_LE_Set_Periodic_Advertising_Enable command."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_le_set_periodic_adv_enable_params_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_le_set_periodic_adv_enable_params_t"]
        [::core::mem::size_of::<sdc_hci_le_set_periodic_adv_enable_params_t>() - 1usize];
    ["Alignment of sdc_hci_le_set_periodic_adv_enable_params_t"]
        [::core::mem::align_of::<sdc_hci_le_set_periodic_adv_enable_params_t>() - 1usize];
};
impl sdc_hci_le_set_periodic_adv_enable_params_t {
    #[inline]
    pub fn enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enable_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_enable_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn include_adi(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_include_adi(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn include_adi_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_include_adi_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_rfu(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                6u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(enable: u8, include_adi: u8, rfu: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enable: u8 = unsafe { ::core::mem::transmute(enable) };
            enable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let include_adi: u8 = unsafe { ::core::mem::transmute(include_adi) };
            include_adi as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let rfu: u8 = unsafe { ::core::mem::transmute(rfu) };
            rfu as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Enable parameters for HCI_LE_Set_Periodic_Advertising_Receive_Enable command."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_le_set_periodic_adv_receive_enable_params_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_le_set_periodic_adv_receive_enable_params_t"]
        [::core::mem::size_of::<sdc_hci_le_set_periodic_adv_receive_enable_params_t>() - 1usize];
    ["Alignment of sdc_hci_le_set_periodic_adv_receive_enable_params_t"]
        [::core::mem::align_of::<sdc_hci_le_set_periodic_adv_receive_enable_params_t>() - 1usize];
};
impl sdc_hci_le_set_periodic_adv_receive_enable_params_t {
    #[inline]
    pub fn enable_reporting(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable_reporting(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enable_reporting_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_enable_reporting_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enable_duplicate_filtering(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable_duplicate_filtering(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enable_duplicate_filtering_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_enable_duplicate_filtering_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfu(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_rfu(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfu_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                6u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfu_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enable_reporting: u8,
        enable_duplicate_filtering: u8,
        rfu: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enable_reporting: u8 = unsafe { ::core::mem::transmute(enable_reporting) };
            enable_reporting as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enable_duplicate_filtering: u8 = unsafe { ::core::mem::transmute(enable_duplicate_filtering) };
            enable_duplicate_filtering as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let rfu: u8 = unsafe { ::core::mem::transmute(rfu) };
            rfu as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "LE Set Periodic Advertising Subevent Data array parameters."]
#[repr(C, packed)]
pub struct sdc_hci_le_set_periodic_adv_subevent_data_array_params_t {
    pub subevent: u8,
    pub response_slot_start: u8,
    pub response_slot_count: u8,
    pub subevent_data_length: u8,
    pub subevent_data: __IncompleteArrayField<u8>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_le_set_periodic_adv_subevent_data_array_params_t"]
        [::core::mem::size_of::<sdc_hci_le_set_periodic_adv_subevent_data_array_params_t>() - 4usize];
    ["Alignment of sdc_hci_le_set_periodic_adv_subevent_data_array_params_t"]
        [::core::mem::align_of::<sdc_hci_le_set_periodic_adv_subevent_data_array_params_t>() - 1usize];
    ["Offset of field: sdc_hci_le_set_periodic_adv_subevent_data_array_params_t::subevent"]
        [::core::mem::offset_of!(sdc_hci_le_set_periodic_adv_subevent_data_array_params_t, subevent) - 0usize];
    ["Offset of field: sdc_hci_le_set_periodic_adv_subevent_data_array_params_t::response_slot_start"][::core::mem::offset_of!(
        sdc_hci_le_set_periodic_adv_subevent_data_array_params_t,
        response_slot_start
    ) - 1usize];
    ["Offset of field: sdc_hci_le_set_periodic_adv_subevent_data_array_params_t::response_slot_count"][::core::mem::offset_of!(
        sdc_hci_le_set_periodic_adv_subevent_data_array_params_t,
        response_slot_count
    ) - 2usize];
    ["Offset of field: sdc_hci_le_set_periodic_adv_subevent_data_array_params_t::subevent_data_length"][::core::mem::offset_of!(
        sdc_hci_le_set_periodic_adv_subevent_data_array_params_t,
        subevent_data_length
    ) - 3usize];
    ["Offset of field: sdc_hci_le_set_periodic_adv_subevent_data_array_params_t::subevent_data"]
        [::core::mem::offset_of!(sdc_hci_le_set_periodic_adv_subevent_data_array_params_t, subevent_data) - 4usize];
};
#[doc = "LE Advertising Report.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.7.65.2\n\n The HCI_LE_Advertising_Report event indicates that one or more Bluetooth devices\n have responded to an active scan or have broadcast advertisements that were received\n during a passive scan. The Controller may queue these advertising reports and send\n information from multiple devices in one HCI_LE_Advertising_Report event.\n\n This event shall only be generated if scanning was enabled using the\n HCI_LE_Set_Scan_Enable command. It only reports advertising events that used\n legacy advertising PDUs."]
#[repr(C, packed)]
pub struct sdc_hci_subevent_le_adv_report_t {
    pub num_reports: u8,
    #[doc = "C does not allow array of variable sized arrays, otherwise it should be sdc_hci_le_adv_report_array_params_t reports"]
    pub reports: __IncompleteArrayField<u8>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_subevent_le_adv_report_t"][::core::mem::size_of::<sdc_hci_subevent_le_adv_report_t>() - 1usize];
    ["Alignment of sdc_hci_subevent_le_adv_report_t"]
        [::core::mem::align_of::<sdc_hci_subevent_le_adv_report_t>() - 1usize];
    ["Offset of field: sdc_hci_subevent_le_adv_report_t::num_reports"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_adv_report_t, num_reports) - 0usize];
    ["Offset of field: sdc_hci_subevent_le_adv_report_t::reports"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_adv_report_t, reports) - 1usize];
};
#[doc = "LE Directed Advertising Report.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.7.65.11\n\n The HCI_LE_Directed_Advertising_Report event indicates that directed advertisements\n have been received where the advertiser is using a resolvable private address\n for the TargetA field of the advertising PDU which the Controller is unable\n to resolve and the Scanning_Filter_Policy is equal to 0x02 or 0x03, see\n Section 7.8.10. Direct_Address_Type and Direct_Address specify the address the\n directed advertisements are being directed to. Address_Type and Address specify the\n address of the advertiser sending the directed advertisements. The Controller may\n queue these advertising reports and send information from multiple advertisers in one\n HCI_LE_Directed_Advertising_Report event.\n\n This event shall only be generated if scanning was enabled using the\n HCI_LE_Set_Scan_Enable command. It only reports advertising events that used\n legacy advertising PDUs."]
#[repr(C, packed)]
pub struct sdc_hci_subevent_le_directed_adv_report_t {
    pub num_reports: u8,
    pub reports: __IncompleteArrayField<sdc_hci_le_directed_adv_report_array_params_t>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_subevent_le_directed_adv_report_t"]
        [::core::mem::size_of::<sdc_hci_subevent_le_directed_adv_report_t>() - 1usize];
    ["Alignment of sdc_hci_subevent_le_directed_adv_report_t"]
        [::core::mem::align_of::<sdc_hci_subevent_le_directed_adv_report_t>() - 1usize];
    ["Offset of field: sdc_hci_subevent_le_directed_adv_report_t::num_reports"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_directed_adv_report_t, num_reports) - 0usize];
    ["Offset of field: sdc_hci_subevent_le_directed_adv_report_t::reports"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_directed_adv_report_t, reports) - 1usize];
};
#[doc = "LE Extended Advertising Report.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.7.65.13\n\n The HCI_LE_Extended_Advertising_Report event indicates that one or more Bluetooth\n devices have responded to an active scan or have broadcast advertisements\n that were received during a passive scan. The Controller may coalesce\n multiple advertising reports from the same or different advertisers into a single\n HCI_LE_Extended_Advertising_Report event, provided all the parameters from all the\n advertising reports fit in a single HCI event.\n\n This event shall only be generated if scanning was enabled using the HCI_LE_Set_-\n Extended_Scan_Enable command. It reports advertising events using either legacy or\n extended advertising PDUs.\n\n The Controller may split the data from a single advertisement or scan response\n (whether one PDU or several) into several reports. If so, each report except the\n last shall have an Event_Type with a data status field of \"incomplete, more data to\n come\", while the last shall have the value \"complete\"; the Address_Type, Address,\n Advertising_SID, Primary_PHY, and Secondary_PHY fields shall be the same in all the\n reports. No further reports shall be sent for a given advertisement or scan response\n after one with a Data_Status other than \"incomplete, more data to come\".\n When a scan response is received, bits 0 to 2 and 4 of the event type shall indicate the\n properties of the original advertising event and the Advertising_SID field should be set\n to the value in the original scannable advertisement.\n\n An Event_Type with a data status field of \"incomplete, data truncated\" shall indicate that\n the Controller attempted to receive an AUX_CHAIN_IND PDU but was not successful or\n received it but was unable to store the data.\n\n Where the event being reported used a legacy advertising PDU, the Controller shall set\n the Event_Type to the value specified in Table 7.1.\n\n PDU Type Event_Type\n ADV_IND 0b0010011\n ADV_DIRECT_IND 0b0010101\n ADV_SCAN_IND 0b0010010\n ADV_NONCONN_IND 0b0010000\n SCAN_RSP to an ADV_IND 0b0011011\n SCAN_RSP to an ADV_SCAN_IND 0b0011010\n\n Table 7.1: Event_Type values for legacy PDUs\n\n If the Event_Type indicates a legacy PDU (bit 4 = 1), the Primary_PHY parameter\n shall indicate the LE 1M PHY and the Secondary_PHY parameter shall be set to\n 0x00. Otherwise, the Primary_PHY parameter shall indicate the PHY used to send the\n advertising PDU on the primary advertising physical channel and the Secondary_PHY\n parameter shall indicate the PHY used to send the advertising PDU(s), if any, on\n the secondary advertising physical channel. If the Advertising Coding Selection (Host\n Support) Link Layer feature bit is set (see 6] Part B, Section 4.6) and the\n Primary_PHY or Secondary_PHY parameter indicates that the LE Coded PHY was\n used, then the parameter shall also indicate which coding was used.\n\n The Periodic_Advertising_Interval parameter shall be set to zero when no periodic\n advertising exists as part of the advertising set.\n\n The Direct_Address_Type and Direct_Address parameters shall contain the TargetA\n address in the advertising PDU for directed advertising event types (bit 2 = 1). These\n parameters shall be ignored for undirected advertising event types (bit 2 = 0). If\n the TargetA address is a resolvable private address that the Controller successfully\n resolved, then the value of Direct_Address_Type shall depend on the value of the\n Own_Address_Type parameter of the command that set the extended scan parameters.\n Direct_Address shall be set as follows:\n\n  If Direct_Address_Type equals 0x02, then Direct_Address shall be set to either the\n TargetA field in the received advertisement or to the public device address of the\n scanning device.\n  If Direct_Address_Type equals 0x03, then Direct_Address shall be set to either\n the TargetA field in the received advertisement or to the address set by the\n HCI_LE_Set_Random_Address command.\n  Otherwise Direct_Address shall be set to the TargetA field in the received\n advertisement.\n\n When multiple advertising packets are used to complete a single advertising report\n (e.g., a packet containing an ADV_EXT_IND PDU combined with one containing an\n AUX_ADV_IND PDU), the RSSI parameter shall be set based on the last packet\n received and the TX_Power parameter shall be based on the last packet of the current\n advertisement or scan response received that contains a TxPower field. If there is no\n packet containing a TxPower field, then TX_Power shall be set to 0x7F. However, if\n an event has been sent with a TX_Power value other than 0x7F and a Data_Status of\n \"incomplete, more data to come\", and if no subsequent PDU with a TxPower field has\n been received, then subsequent events may instead have a TX_Power value of 0x7F.\n\n If the Controller receives an AUX_CHAIN_IND with no AdvData, it should send the\n report (or the last report if it has split the data) immediately without waiting for any\n subsequent AUX_CHAIN_IND PDUs."]
#[repr(C, packed)]
pub struct sdc_hci_subevent_le_ext_adv_report_t {
    pub num_reports: u8,
    #[doc = "C does not allow array of variable sized arrays, otherwise it should be sdc_hci_le_ext_adv_report_array_params_t reports"]
    pub reports: __IncompleteArrayField<u8>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_subevent_le_ext_adv_report_t"]
        [::core::mem::size_of::<sdc_hci_subevent_le_ext_adv_report_t>() - 1usize];
    ["Alignment of sdc_hci_subevent_le_ext_adv_report_t"]
        [::core::mem::align_of::<sdc_hci_subevent_le_ext_adv_report_t>() - 1usize];
    ["Offset of field: sdc_hci_subevent_le_ext_adv_report_t::num_reports"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_ext_adv_report_t, num_reports) - 0usize];
    ["Offset of field: sdc_hci_subevent_le_ext_adv_report_t::reports"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_ext_adv_report_t, reports) - 1usize];
};
#[doc = "LE CIS Established.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.7.65.25\n\n The HCI_LE_CIS_Established event indicates that a CIS has been established,\n was considered lost before being established, oron the Centralwas rejected\n by the Peripheral. It is generated by the Controller in the Central and Peripheral.\n The Connection_Handle parameter shall be set to the value provided in the\n HCI_LE_Create_CIS command on the Central and in the HCI_LE_CIS_Request event\n on the Peripheral.\n\n The CIG_Sync_Delay parameter is the maximum time, in microseconds, for\n transmission of PDUs of all CISes in a CIG event (see 6] Part B, Section 4.5.14.1).\n\n The CIS_Sync_Delay parameter is the maximum time, in microseconds, for\n transmission of PDUs of the specified CIS in a CIG event (see 6] Part B,\n Section 4.5.14.1).\n\n The Transport_Latency_C_To_P and Transport_Latency_P_To_C parameters are the\n actual transport latencies, in microseconds, as described in 6] Part G, Section 3.2.1\n and 6] Part G, Section 3.2.2.\n\n The PHY_C_To_P parameter indicates the PHY selected for packets from the Central to\n Peripheral.\n The PHY_P_To_C parameter indicates the PHY selected for packets from the\n Peripheral to Central.\n\n The remaining parameters are the corresponding parameters of the CIS (see 6]\n Part B, Section 4.5.13.1).\n\n If this event is generated on the Peripheral with a non-zero status, the Controller shall\n delete the Connection_Handle and any associated ISO data paths."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_subevent_le_cis_established_t {
    pub status: u8,
    pub conn_handle: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 12usize]>,
    pub phy_c_to_p: u8,
    pub phy_p_to_c: u8,
    pub nse: u8,
    pub bn_c_to_p: u8,
    pub bn_p_to_c: u8,
    pub ft_c_to_p: u8,
    pub ft_p_to_c: u8,
    pub max_pdu_c_to_p: u16,
    pub max_pdu_p_to_c: u16,
    pub iso_interval: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_subevent_le_cis_established_t"]
        [::core::mem::size_of::<sdc_hci_subevent_le_cis_established_t>() - 28usize];
    ["Alignment of sdc_hci_subevent_le_cis_established_t"]
        [::core::mem::align_of::<sdc_hci_subevent_le_cis_established_t>() - 1usize];
    ["Offset of field: sdc_hci_subevent_le_cis_established_t::status"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cis_established_t, status) - 0usize];
    ["Offset of field: sdc_hci_subevent_le_cis_established_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cis_established_t, conn_handle) - 1usize];
    ["Offset of field: sdc_hci_subevent_le_cis_established_t::phy_c_to_p"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cis_established_t, phy_c_to_p) - 15usize];
    ["Offset of field: sdc_hci_subevent_le_cis_established_t::phy_p_to_c"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cis_established_t, phy_p_to_c) - 16usize];
    ["Offset of field: sdc_hci_subevent_le_cis_established_t::nse"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cis_established_t, nse) - 17usize];
    ["Offset of field: sdc_hci_subevent_le_cis_established_t::bn_c_to_p"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cis_established_t, bn_c_to_p) - 18usize];
    ["Offset of field: sdc_hci_subevent_le_cis_established_t::bn_p_to_c"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cis_established_t, bn_p_to_c) - 19usize];
    ["Offset of field: sdc_hci_subevent_le_cis_established_t::ft_c_to_p"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cis_established_t, ft_c_to_p) - 20usize];
    ["Offset of field: sdc_hci_subevent_le_cis_established_t::ft_p_to_c"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cis_established_t, ft_p_to_c) - 21usize];
    ["Offset of field: sdc_hci_subevent_le_cis_established_t::max_pdu_c_to_p"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cis_established_t, max_pdu_c_to_p) - 22usize];
    ["Offset of field: sdc_hci_subevent_le_cis_established_t::max_pdu_p_to_c"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cis_established_t, max_pdu_p_to_c) - 24usize];
    ["Offset of field: sdc_hci_subevent_le_cis_established_t::iso_interval"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cis_established_t, iso_interval) - 26usize];
};
impl sdc_hci_subevent_le_cis_established_t {
    #[inline]
    pub fn cig_sync_delay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_cig_sync_delay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cig_sync_delay_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cig_sync_delay_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cis_sync_delay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_cis_sync_delay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cis_sync_delay_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cis_sync_delay_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn transport_latency_c_to_p(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(48usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_transport_latency_c_to_p(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(48usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn transport_latency_c_to_p_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                48usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_transport_latency_c_to_p_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                48usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn transport_latency_p_to_c(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(72usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_transport_latency_p_to_c(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(72usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn transport_latency_p_to_c_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                72usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_transport_latency_p_to_c_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                72usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cig_sync_delay: u32,
        cis_sync_delay: u32,
        transport_latency_c_to_p: u32,
        transport_latency_p_to_c: u32,
    ) -> __BindgenBitfieldUnit<[u8; 12usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 12usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let cig_sync_delay: u32 = unsafe { ::core::mem::transmute(cig_sync_delay) };
            cig_sync_delay as u64
        });
        __bindgen_bitfield_unit.set(24usize, 24u8, {
            let cis_sync_delay: u32 = unsafe { ::core::mem::transmute(cis_sync_delay) };
            cis_sync_delay as u64
        });
        __bindgen_bitfield_unit.set(48usize, 24u8, {
            let transport_latency_c_to_p: u32 = unsafe { ::core::mem::transmute(transport_latency_c_to_p) };
            transport_latency_c_to_p as u64
        });
        __bindgen_bitfield_unit.set(72usize, 24u8, {
            let transport_latency_p_to_c: u32 = unsafe { ::core::mem::transmute(transport_latency_p_to_c) };
            transport_latency_p_to_c as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "LE Subrate Change.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.7.65.35\n\n The HCI_LE_Subrate_Change event is used to indicate that a Connection Subrate\n Update procedure has completed and some parameters of the specified connection\n have changed.\n\n This event shall be issued if the HCI_LE_Subrate_Request command was issued by\n the Host or the parameters are updated successfully following a request from the peer\n device. If no parameters are updated following a request from the peer device or the\n parameters were changed using the Connection Update procedure, then this event shall\n not be issued."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_subevent_le_subrate_change_t {
    pub status: u8,
    pub conn_handle: u16,
    pub subrate_factor: u16,
    pub peripheral_latency: u16,
    pub continuation_number: u16,
    pub supervision_timeout: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_subevent_le_subrate_change_t"]
        [::core::mem::size_of::<sdc_hci_subevent_le_subrate_change_t>() - 11usize];
    ["Alignment of sdc_hci_subevent_le_subrate_change_t"]
        [::core::mem::align_of::<sdc_hci_subevent_le_subrate_change_t>() - 1usize];
    ["Offset of field: sdc_hci_subevent_le_subrate_change_t::status"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_subrate_change_t, status) - 0usize];
    ["Offset of field: sdc_hci_subevent_le_subrate_change_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_subrate_change_t, conn_handle) - 1usize];
    ["Offset of field: sdc_hci_subevent_le_subrate_change_t::subrate_factor"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_subrate_change_t, subrate_factor) - 3usize];
    ["Offset of field: sdc_hci_subevent_le_subrate_change_t::peripheral_latency"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_subrate_change_t, peripheral_latency) - 5usize];
    ["Offset of field: sdc_hci_subevent_le_subrate_change_t::continuation_number"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_subrate_change_t, continuation_number) - 7usize];
    ["Offset of field: sdc_hci_subevent_le_subrate_change_t::supervision_timeout"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_subrate_change_t, supervision_timeout) - 9usize];
};
#[doc = "LE CIS Established v2.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.7.65.25\n\n The HCI_LE_CIS_Established event indicates that a CIS has been established,\n was considered lost before being established, oron the Centralwas rejected\n by the Peripheral. It is generated by the Controller in the Central and Peripheral.\n The Connection_Handle parameter shall be set to the value provided in the\n HCI_LE_Create_CIS command on the Central and in the HCI_LE_CIS_Request event\n on the Peripheral.\n\n The CIG_Sync_Delay parameter is the maximum time, in microseconds, for\n transmission of PDUs of all CISes in a CIG event (see 6] Part B, Section 4.5.14.1).\n\n The CIS_Sync_Delay parameter is the maximum time, in microseconds, for\n transmission of PDUs of the specified CIS in a CIG event (see 6] Part B,\n Section 4.5.14.1).\n\n The Transport_Latency_C_To_P and Transport_Latency_P_To_C parameters are the\n actual transport latencies, in microseconds, as described in 6] Part G, Section 3.2.1\n and 6] Part G, Section 3.2.2.\n\n The PHY_C_To_P parameter indicates the PHY selected for packets from the Central to\n Peripheral.\n The PHY_P_To_C parameter indicates the PHY selected for packets from the\n Peripheral to Central.\n\n The remaining parameters are the corresponding parameters of the CIS (see 6]\n Part B, Section 4.5.13.1).\n\n If this event is generated on the Peripheral with a non-zero status, the Controller shall\n delete the Connection_Handle and any associated ISO data paths."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_subevent_le_cis_established_v2_t {
    pub status: u8,
    pub conn_handle: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 12usize]>,
    pub phy_c_to_p: u8,
    pub phy_p_to_c: u8,
    pub nse: u8,
    pub bn_c_to_p: u8,
    pub bn_p_to_c: u8,
    pub ft_c_to_p: u8,
    pub ft_p_to_c: u8,
    pub max_pdu_c_to_p: u16,
    pub max_pdu_p_to_c: u16,
    pub iso_interval: u16,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub max_sdu_c_to_p: u16,
    pub max_sdu_p_to_c: u16,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 6usize]>,
    pub framing: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_subevent_le_cis_established_v2_t"]
        [::core::mem::size_of::<sdc_hci_subevent_le_cis_established_v2_t>() - 42usize];
    ["Alignment of sdc_hci_subevent_le_cis_established_v2_t"]
        [::core::mem::align_of::<sdc_hci_subevent_le_cis_established_v2_t>() - 1usize];
    ["Offset of field: sdc_hci_subevent_le_cis_established_v2_t::status"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cis_established_v2_t, status) - 0usize];
    ["Offset of field: sdc_hci_subevent_le_cis_established_v2_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cis_established_v2_t, conn_handle) - 1usize];
    ["Offset of field: sdc_hci_subevent_le_cis_established_v2_t::phy_c_to_p"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cis_established_v2_t, phy_c_to_p) - 15usize];
    ["Offset of field: sdc_hci_subevent_le_cis_established_v2_t::phy_p_to_c"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cis_established_v2_t, phy_p_to_c) - 16usize];
    ["Offset of field: sdc_hci_subevent_le_cis_established_v2_t::nse"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cis_established_v2_t, nse) - 17usize];
    ["Offset of field: sdc_hci_subevent_le_cis_established_v2_t::bn_c_to_p"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cis_established_v2_t, bn_c_to_p) - 18usize];
    ["Offset of field: sdc_hci_subevent_le_cis_established_v2_t::bn_p_to_c"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cis_established_v2_t, bn_p_to_c) - 19usize];
    ["Offset of field: sdc_hci_subevent_le_cis_established_v2_t::ft_c_to_p"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cis_established_v2_t, ft_c_to_p) - 20usize];
    ["Offset of field: sdc_hci_subevent_le_cis_established_v2_t::ft_p_to_c"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cis_established_v2_t, ft_p_to_c) - 21usize];
    ["Offset of field: sdc_hci_subevent_le_cis_established_v2_t::max_pdu_c_to_p"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cis_established_v2_t, max_pdu_c_to_p) - 22usize];
    ["Offset of field: sdc_hci_subevent_le_cis_established_v2_t::max_pdu_p_to_c"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cis_established_v2_t, max_pdu_p_to_c) - 24usize];
    ["Offset of field: sdc_hci_subevent_le_cis_established_v2_t::iso_interval"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cis_established_v2_t, iso_interval) - 26usize];
    ["Offset of field: sdc_hci_subevent_le_cis_established_v2_t::max_sdu_c_to_p"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cis_established_v2_t, max_sdu_c_to_p) - 31usize];
    ["Offset of field: sdc_hci_subevent_le_cis_established_v2_t::max_sdu_p_to_c"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cis_established_v2_t, max_sdu_p_to_c) - 33usize];
    ["Offset of field: sdc_hci_subevent_le_cis_established_v2_t::framing"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cis_established_v2_t, framing) - 41usize];
};
impl sdc_hci_subevent_le_cis_established_v2_t {
    #[inline]
    pub fn cig_sync_delay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_cig_sync_delay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cig_sync_delay_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cig_sync_delay_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cis_sync_delay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_cis_sync_delay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cis_sync_delay_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cis_sync_delay_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn transport_latency_c_to_p(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(48usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_transport_latency_c_to_p(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(48usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn transport_latency_c_to_p_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                48usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_transport_latency_c_to_p_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                48usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn transport_latency_p_to_c(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(72usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_transport_latency_p_to_c(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(72usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn transport_latency_p_to_c_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                72usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_transport_latency_p_to_c_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                72usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cig_sync_delay: u32,
        cis_sync_delay: u32,
        transport_latency_c_to_p: u32,
        transport_latency_p_to_c: u32,
    ) -> __BindgenBitfieldUnit<[u8; 12usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 12usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let cig_sync_delay: u32 = unsafe { ::core::mem::transmute(cig_sync_delay) };
            cig_sync_delay as u64
        });
        __bindgen_bitfield_unit.set(24usize, 24u8, {
            let cis_sync_delay: u32 = unsafe { ::core::mem::transmute(cis_sync_delay) };
            cis_sync_delay as u64
        });
        __bindgen_bitfield_unit.set(48usize, 24u8, {
            let transport_latency_c_to_p: u32 = unsafe { ::core::mem::transmute(transport_latency_c_to_p) };
            transport_latency_c_to_p as u64
        });
        __bindgen_bitfield_unit.set(72usize, 24u8, {
            let transport_latency_p_to_c: u32 = unsafe { ::core::mem::transmute(transport_latency_p_to_c) };
            transport_latency_p_to_c as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn sub_interval(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_sub_interval(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sub_interval_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sub_interval_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(sub_interval: u32) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let sub_interval: u32 = unsafe { ::core::mem::transmute(sub_interval) };
            sub_interval as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn sdu_interval_c_to_p(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_sdu_interval_c_to_p(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sdu_interval_c_to_p_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_3),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sdu_interval_c_to_p_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_3),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sdu_interval_p_to_c(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(24usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_sdu_interval_p_to_c(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(24usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sdu_interval_p_to_c_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_3),
                24usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sdu_interval_p_to_c_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_3),
                24usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_3(sdu_interval_c_to_p: u32, sdu_interval_p_to_c: u32) -> __BindgenBitfieldUnit<[u8; 6usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 6usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let sdu_interval_c_to_p: u32 = unsafe { ::core::mem::transmute(sdu_interval_c_to_p) };
            sdu_interval_c_to_p as u64
        });
        __bindgen_bitfield_unit.set(24usize, 24u8, {
            let sdu_interval_p_to_c: u32 = unsafe { ::core::mem::transmute(sdu_interval_p_to_c) };
            sdu_interval_p_to_c as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "LE CS Read Remote Supported Capabilities Complete.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.7.65.39\n\n The HCI_LE_CS_Read_Remote_Supported_Capabilities_Complete event shall be\n generated when a locally initiated CS Capabilities Exchange procedure has completed\n or when the local Controller has received an LL_CS_CAPABILITIES_REQ from the\n remote Controller.\n\n The Num_Config_Supported parameter indicates the number of CS configurations that\n are supported by the remote Controller.\n\n The Max_Consecutive_Procedures_Supported parameter indicates the maximum\n number of consecutive CS procedures that are supported by the remote Controller.\n The Num_Antennas_Supported parameter indicates the number of antenna elements\n that are available for CS tone exchanges.\n\n The Max_Antenna_Paths_Supported parameter indicates the maximum number of\n antenna paths that are supported by the remote Controller for CS tone exchanges.\n\n The Roles_Supported parameter indicates the CS roles that are supported by the\n remote Controller.\n\n The Modes_Supported parameter indicates the optional CS modes that are supported\n by the remote Controller.\n\n The RTT_Capability, RTT_AA_Only_N, RTT_Sounding_N, and RTT_Random_-\n Payload_N parameters indicate the time-of-flight accuracy as described in 6] Part\n B, Section 2.4.2.44.\n\n The NADM_Sounding_Capability and NADM_Random_Capability parameters indicate\n the support by the remote Controller for reporting Normalized Attack Detector Metric\n (NADM) when a CS_SYNC with a sounding sequence or random sequence is received.\n\n The CS_SYNC_PHYs_Supported parameter indicates the optional transmit and receive\n PHYs supported by the remote Controller for CS_SYNC exchanges as described in 6] Part H, Section 4.3.\n\n The Subfeatures_Supported parameter indicates which of the following optional\n subfeatures are supported by the remote Controller:\n\n  A Frequency Actuation Error of zero for all allowed CS channels as described in 6] Part A, Section 3.5.\n  Channel Selection Algorithm #3c as described in 6] Part H, Section 4.1.4.2.\n  Phase-based ranging from a sounding sequence as described in 6] Part H,\n Section 3.3.1.\n\n The T_IP1_Times_Supported, T_IP2_Times_Supported, T_FCS_Times_Supported,\n T_PM_Times_Supported, and T_SW_Time_Supported parameters indicate the\n supported optional time durations used in CS steps as described in 6] Part H,\n Section 4.3.\n\n The TX_SNR_Capability parameter indicated the supported SNR levels used in RTT\n packets as described in 6] Part A, Section 3.1.3."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t {
    pub status: u8,
    pub conn_handle: u16,
    pub num_config_supported: u8,
    pub max_consecutive_procedures_supported: u16,
    pub num_antennas_supported: u8,
    pub max_antenna_paths_supported: u8,
    pub roles_supported: u8,
    pub modes_supported: u8,
    pub rtt_capability: u8,
    pub rtt_aa_only_n: u8,
    pub rtt_sounding_n: u8,
    pub rtt_random_payload_n: u8,
    pub nadm_sounding_capability: u16,
    pub nadm_random_capability: u16,
    pub cs_sync_phys_supported: u8,
    pub subfeatures_supported: u16,
    pub t_ip1_times_supported: u16,
    pub t_ip2_times_supported: u16,
    pub t_fcs_times_supported: u16,
    pub t_pm_times_supported: u16,
    pub t_sw_time_supported: u8,
    pub tx_snr_capability: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t"]
        [::core::mem::size_of::<sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t>() - 31usize];
    ["Alignment of sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t"]
        [::core::mem::align_of::<sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t>() - 1usize];
    ["Offset of field: sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t::status"][::core::mem::offset_of!(
        sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t,
        status
    ) - 0usize];
    ["Offset of field: sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t::conn_handle"][::core::mem::offset_of!(
        sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t,
        conn_handle
    ) - 1usize];
    ["Offset of field: sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t::num_config_supported"][::core::mem::offset_of!(
        sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t,
        num_config_supported
    )
        - 3usize];
    [
        "Offset of field: sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t::max_consecutive_procedures_supported",
    ][::core::mem::offset_of!(
        sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t,
        max_consecutive_procedures_supported
    ) - 4usize];
    ["Offset of field: sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t::num_antennas_supported"][::core::mem::offset_of!(
        sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t,
        num_antennas_supported
    )
        - 6usize];
    [
        "Offset of field: sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t::max_antenna_paths_supported",
    ][::core::mem::offset_of!(
        sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t,
        max_antenna_paths_supported
    ) - 7usize];
    ["Offset of field: sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t::roles_supported"][::core::mem::offset_of!(
        sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t,
        roles_supported
    )
        - 8usize];
    ["Offset of field: sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t::modes_supported"][::core::mem::offset_of!(
        sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t,
        modes_supported
    )
        - 9usize];
    ["Offset of field: sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t::rtt_capability"][::core::mem::offset_of!(
        sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t,
        rtt_capability
    )
        - 10usize];
    ["Offset of field: sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t::rtt_aa_only_n"][::core::mem::offset_of!(
        sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t,
        rtt_aa_only_n
    )
        - 11usize];
    ["Offset of field: sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t::rtt_sounding_n"][::core::mem::offset_of!(
        sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t,
        rtt_sounding_n
    )
        - 12usize];
    ["Offset of field: sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t::rtt_random_payload_n"][::core::mem::offset_of!(
        sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t,
        rtt_random_payload_n
    )
        - 13usize];
    ["Offset of field: sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t::nadm_sounding_capability"]
        [::core::mem::offset_of!(
            sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t,
            nadm_sounding_capability
        ) - 14usize];
    ["Offset of field: sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t::nadm_random_capability"][::core::mem::offset_of!(
        sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t,
        nadm_random_capability
    )
        - 16usize];
    ["Offset of field: sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t::cs_sync_phys_supported"][::core::mem::offset_of!(
        sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t,
        cs_sync_phys_supported
    )
        - 18usize];
    ["Offset of field: sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t::subfeatures_supported"][::core::mem::offset_of!(
        sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t,
        subfeatures_supported
    )
        - 19usize];
    ["Offset of field: sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t::t_ip1_times_supported"][::core::mem::offset_of!(
        sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t,
        t_ip1_times_supported
    )
        - 21usize];
    ["Offset of field: sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t::t_ip2_times_supported"][::core::mem::offset_of!(
        sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t,
        t_ip2_times_supported
    )
        - 23usize];
    ["Offset of field: sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t::t_fcs_times_supported"][::core::mem::offset_of!(
        sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t,
        t_fcs_times_supported
    )
        - 25usize];
    ["Offset of field: sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t::t_pm_times_supported"][::core::mem::offset_of!(
        sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t,
        t_pm_times_supported
    )
        - 27usize];
    ["Offset of field: sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t::t_sw_time_supported"][::core::mem::offset_of!(
        sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t,
        t_sw_time_supported
    )
        - 29usize];
    ["Offset of field: sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t::tx_snr_capability"][::core::mem::offset_of!(
        sdc_hci_subevent_le_cs_read_remote_supported_capabilities_complete_t,
        tx_snr_capability
    )
        - 30usize];
};
#[doc = "LE CS Read Remote FAE Table Complete.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.7.65.40\n\n The HCI_LE_CS_Read_Remote_FAE_Table_Complete event shall be generated when\n a locally initiated CS Mode-0 Frequency Actuation Error Table Update procedure has\n completed."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_subevent_le_cs_read_remote_fae_table_complete_t {
    pub status: u8,
    pub conn_handle: u16,
    pub remote_fae_table: [u8; 72usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_subevent_le_cs_read_remote_fae_table_complete_t"]
        [::core::mem::size_of::<sdc_hci_subevent_le_cs_read_remote_fae_table_complete_t>() - 75usize];
    ["Alignment of sdc_hci_subevent_le_cs_read_remote_fae_table_complete_t"]
        [::core::mem::align_of::<sdc_hci_subevent_le_cs_read_remote_fae_table_complete_t>() - 1usize];
    ["Offset of field: sdc_hci_subevent_le_cs_read_remote_fae_table_complete_t::status"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_read_remote_fae_table_complete_t, status) - 0usize];
    ["Offset of field: sdc_hci_subevent_le_cs_read_remote_fae_table_complete_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_read_remote_fae_table_complete_t, conn_handle) - 1usize];
    ["Offset of field: sdc_hci_subevent_le_cs_read_remote_fae_table_complete_t::remote_fae_table"][::core::mem::offset_of!(
        sdc_hci_subevent_le_cs_read_remote_fae_table_complete_t,
        remote_fae_table
    ) - 3usize];
};
#[doc = "LE CS Security Enable Complete.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.7.65.41\n\n The HCI_LE_CS_Security_Enable_Complete event shall be generated when a locally\n initiated CS Security Start procedure has completed or when the local Controller has\n responded to a CS security request from the remote Controller."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_subevent_le_cs_security_enable_complete_t {
    pub status: u8,
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_subevent_le_cs_security_enable_complete_t"]
        [::core::mem::size_of::<sdc_hci_subevent_le_cs_security_enable_complete_t>() - 3usize];
    ["Alignment of sdc_hci_subevent_le_cs_security_enable_complete_t"]
        [::core::mem::align_of::<sdc_hci_subevent_le_cs_security_enable_complete_t>() - 1usize];
    ["Offset of field: sdc_hci_subevent_le_cs_security_enable_complete_t::status"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_security_enable_complete_t, status) - 0usize];
    ["Offset of field: sdc_hci_subevent_le_cs_security_enable_complete_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_security_enable_complete_t, conn_handle) - 1usize];
};
#[doc = "LE CS Config Complete.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.7.65.42\n\n The HCI_LE_CS_Config_Complete event shall be generated when a locally initiated\n Channel Sounding Configuration procedure has completed or when the local Controller\n has responded to a CS configuration request from the remote Controller for the CS\n configuration identified by Config_ID or when a CS configuration is created only with\n local context. The Action parameter indicates if a CS configuration was requested to be\n created or removed. The Status parameter indicates whether the request indicated by\n the Action parameter was successful.\n\n When the Action parameter is set to 0x00, all the remaining event parameters are\n ignored.\n The Main_Mode_Type and Sub_Mode_Type parameters indicate the CS modes used\n during the CS procedure for the specified CS configuration. The Min_Main_Mode_Steps\n and Max_Main_Mode_Steps parameters indicate the range of main mode CS steps\n executed before a submode CS step is executed during the CS procedure. The\n Main_Mode_Repetition parameter indicates the number of main mode CS steps\n repeated from the last CS subevent at the beginning of the current CS subevent. The\n Mode_0_Steps parameter indicates the number of mode-0 CS steps included at the\n beginning of each CS subevent.\n\n The Role parameter indicates the CS role for the local Controller for the specified CS\n configuration. The RTT_Type parameter indicates the RTT variant to be used during the\n CS procedure, and the CS_SYNC_PHY parameter indicates the PHY to be used for\n CS_SYNC exchanges during the CS procedure for the specified CS configuration.\n\n The Channel_Map parameter indicates the channels to be used or unused during the\n CS procedure, and the Channel_Map_Repetition parameter indicates the number of\n times the channels specified by Channel_Map will be repeated for non-mode-0 steps\n during the CS procedure (see 6] Part H, Section 4.1.4).\n\n The Channel_Selection_Type parameter indicates the Channel Selection Algorithm\n to be used during the CS procedure for non-mode-0 steps. When the\n Channel_Selection_Type parameter is set to 0x01, the Ch3c_Shape and the\n Ch3c_Jump parameters indicate the selected shape and channels to be skipped as\n described in 6] Part H, Section 4.1.4.2.\n\n The T_IP1_Time, T_IP2_Time, T_FCS_Time, T_PM_Time, and T_SW_Time\n parameters indicate the time durations used in CS steps as described in 6] Part\n H, Section 4.3."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_subevent_le_cs_config_complete_t {
    pub status: u8,
    pub conn_handle: u16,
    pub config_id: u8,
    pub action: u8,
    pub main_mode_type: u8,
    pub sub_mode_type: u8,
    pub min_main_mode_steps: u8,
    pub max_main_mode_steps: u8,
    pub main_mode_repetition: u8,
    pub mode_0_steps: u8,
    pub role: u8,
    pub rtt_type: u8,
    pub cs_sync_phy: u8,
    pub channel_map: [u8; 10usize],
    pub channel_map_repetition: u8,
    pub channel_selection_type: u8,
    pub ch3c_shape: u8,
    pub ch3c_jump: u8,
    pub reserved: u8,
    pub t_ip1_time: u8,
    pub t_ip2_time: u8,
    pub t_fcs_time: u8,
    pub t_pm_time: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_subevent_le_cs_config_complete_t"]
        [::core::mem::size_of::<sdc_hci_subevent_le_cs_config_complete_t>() - 33usize];
    ["Alignment of sdc_hci_subevent_le_cs_config_complete_t"]
        [::core::mem::align_of::<sdc_hci_subevent_le_cs_config_complete_t>() - 1usize];
    ["Offset of field: sdc_hci_subevent_le_cs_config_complete_t::status"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_config_complete_t, status) - 0usize];
    ["Offset of field: sdc_hci_subevent_le_cs_config_complete_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_config_complete_t, conn_handle) - 1usize];
    ["Offset of field: sdc_hci_subevent_le_cs_config_complete_t::config_id"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_config_complete_t, config_id) - 3usize];
    ["Offset of field: sdc_hci_subevent_le_cs_config_complete_t::action"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_config_complete_t, action) - 4usize];
    ["Offset of field: sdc_hci_subevent_le_cs_config_complete_t::main_mode_type"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_config_complete_t, main_mode_type) - 5usize];
    ["Offset of field: sdc_hci_subevent_le_cs_config_complete_t::sub_mode_type"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_config_complete_t, sub_mode_type) - 6usize];
    ["Offset of field: sdc_hci_subevent_le_cs_config_complete_t::min_main_mode_steps"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_config_complete_t, min_main_mode_steps) - 7usize];
    ["Offset of field: sdc_hci_subevent_le_cs_config_complete_t::max_main_mode_steps"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_config_complete_t, max_main_mode_steps) - 8usize];
    ["Offset of field: sdc_hci_subevent_le_cs_config_complete_t::main_mode_repetition"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_config_complete_t, main_mode_repetition) - 9usize];
    ["Offset of field: sdc_hci_subevent_le_cs_config_complete_t::mode_0_steps"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_config_complete_t, mode_0_steps) - 10usize];
    ["Offset of field: sdc_hci_subevent_le_cs_config_complete_t::role"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_config_complete_t, role) - 11usize];
    ["Offset of field: sdc_hci_subevent_le_cs_config_complete_t::rtt_type"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_config_complete_t, rtt_type) - 12usize];
    ["Offset of field: sdc_hci_subevent_le_cs_config_complete_t::cs_sync_phy"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_config_complete_t, cs_sync_phy) - 13usize];
    ["Offset of field: sdc_hci_subevent_le_cs_config_complete_t::channel_map"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_config_complete_t, channel_map) - 14usize];
    ["Offset of field: sdc_hci_subevent_le_cs_config_complete_t::channel_map_repetition"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_config_complete_t, channel_map_repetition) - 24usize];
    ["Offset of field: sdc_hci_subevent_le_cs_config_complete_t::channel_selection_type"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_config_complete_t, channel_selection_type) - 25usize];
    ["Offset of field: sdc_hci_subevent_le_cs_config_complete_t::ch3c_shape"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_config_complete_t, ch3c_shape) - 26usize];
    ["Offset of field: sdc_hci_subevent_le_cs_config_complete_t::ch3c_jump"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_config_complete_t, ch3c_jump) - 27usize];
    ["Offset of field: sdc_hci_subevent_le_cs_config_complete_t::reserved"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_config_complete_t, reserved) - 28usize];
    ["Offset of field: sdc_hci_subevent_le_cs_config_complete_t::t_ip1_time"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_config_complete_t, t_ip1_time) - 29usize];
    ["Offset of field: sdc_hci_subevent_le_cs_config_complete_t::t_ip2_time"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_config_complete_t, t_ip2_time) - 30usize];
    ["Offset of field: sdc_hci_subevent_le_cs_config_complete_t::t_fcs_time"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_config_complete_t, t_fcs_time) - 31usize];
    ["Offset of field: sdc_hci_subevent_le_cs_config_complete_t::t_pm_time"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_config_complete_t, t_pm_time) - 32usize];
};
#[doc = "LE CS Procedure Enable Complete.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.7.65.43\n\n The HCI_LE_CS_Procedure_Enable_Complete event shall be generated when the\n local or remote Controller has scheduled a new CS procedure measurement or disabled\n an ongoing CS procedure measurement as a result of an HCI_LE_CS_Procedure_-\n Enable command. When a new CS procedure measurement is enabled, the HCI_LE_-\n CS_Procedure_Enable_Complete event shall be sent to the Host after the LL_CS_IND\n is transmitted or received and before any CS subevent results are available.\n\n When the State parameter is set to 0x00, all the remaining event parameters are\n ignored.\n\n The Tone_Antenna_Config_Selection parameter indicates the Antenna Configuration\n Index used in the CS procedure.\n\n The Controller shall set the Selected_TX_Power parameter to the transmit power level\n that it will use for the CS procedures as described in 6] Part B, Section 5.1.26. If the\n radiated power level will vary between packets (e.g., because of frequency-dependent\n properties of the transmitter), then the value should be the best estimate of the transmit\n power level that will be used.\n\n The Subevent_Len parameter indicates the selected maximum duration of each CS\n subevent during the CS procedure. The Subevents_Per_Event parameter indicates\n the number of CS subevents that are anchored off the same associated LE ACL\n anchor point. The Subevent_Interval parameter indicates the gap between the start\n of two consecutive CS subevents that are anchored off the same associated LE\n ACL anchor point. The Event_Interval parameter indicates the number of connection\n intervals between consecutive LE ACL anchor points from which CS subevents are\n anchored.\n\n The Procedure_Interval parameter indicates the selected interval between consecutive\n CS procedures, in units of ACL connection events. The Procedure_Count parameter\n indicates the selected number of consecutive CS procedures to be scheduled as\n part of this measurement. The Max_Procedure_Len parameter indicates the selected\n maximum duration of each CS procedure."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_subevent_le_cs_procedure_enable_complete_t {
    pub status: u8,
    pub conn_handle: u16,
    pub config_id: u8,
    pub state: u8,
    pub tone_antenna_config_selection: u8,
    pub selected_tx_power: i8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub subevents_per_event: u8,
    pub subevent_interval: u16,
    pub event_interval: u16,
    pub procedure_interval: u16,
    pub procedure_count: u16,
    pub max_procedure_len: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_subevent_le_cs_procedure_enable_complete_t"]
        [::core::mem::size_of::<sdc_hci_subevent_le_cs_procedure_enable_complete_t>() - 21usize];
    ["Alignment of sdc_hci_subevent_le_cs_procedure_enable_complete_t"]
        [::core::mem::align_of::<sdc_hci_subevent_le_cs_procedure_enable_complete_t>() - 1usize];
    ["Offset of field: sdc_hci_subevent_le_cs_procedure_enable_complete_t::status"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_procedure_enable_complete_t, status) - 0usize];
    ["Offset of field: sdc_hci_subevent_le_cs_procedure_enable_complete_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_procedure_enable_complete_t, conn_handle) - 1usize];
    ["Offset of field: sdc_hci_subevent_le_cs_procedure_enable_complete_t::config_id"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_procedure_enable_complete_t, config_id) - 3usize];
    ["Offset of field: sdc_hci_subevent_le_cs_procedure_enable_complete_t::state"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_procedure_enable_complete_t, state) - 4usize];
    ["Offset of field: sdc_hci_subevent_le_cs_procedure_enable_complete_t::tone_antenna_config_selection"][::core::mem::offset_of!(
        sdc_hci_subevent_le_cs_procedure_enable_complete_t,
        tone_antenna_config_selection
    ) - 5usize];
    ["Offset of field: sdc_hci_subevent_le_cs_procedure_enable_complete_t::selected_tx_power"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_procedure_enable_complete_t, selected_tx_power) - 6usize];
    ["Offset of field: sdc_hci_subevent_le_cs_procedure_enable_complete_t::subevents_per_event"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_procedure_enable_complete_t, subevents_per_event) - 10usize];
    ["Offset of field: sdc_hci_subevent_le_cs_procedure_enable_complete_t::subevent_interval"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_procedure_enable_complete_t, subevent_interval) - 11usize];
    ["Offset of field: sdc_hci_subevent_le_cs_procedure_enable_complete_t::event_interval"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_procedure_enable_complete_t, event_interval) - 13usize];
    ["Offset of field: sdc_hci_subevent_le_cs_procedure_enable_complete_t::procedure_interval"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_procedure_enable_complete_t, procedure_interval) - 15usize];
    ["Offset of field: sdc_hci_subevent_le_cs_procedure_enable_complete_t::procedure_count"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_procedure_enable_complete_t, procedure_count) - 17usize];
    ["Offset of field: sdc_hci_subevent_le_cs_procedure_enable_complete_t::max_procedure_len"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_procedure_enable_complete_t, max_procedure_len) - 19usize];
};
impl sdc_hci_subevent_le_cs_procedure_enable_complete_t {
    #[inline]
    pub fn subevent_len(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_subevent_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn subevent_len_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_subevent_len_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(subevent_len: u32) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let subevent_len: u32 = unsafe { ::core::mem::transmute(subevent_len) };
            subevent_len as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "LE CS Subevent Result.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.7.65.44\n\n The HCI_LE_CS_Subevent_Result event shall be generated when the local Controller\n has results to report for a CS subevent during the CS procedure. Depending on\n the number of CS steps in the CS subevent, the Controller may choose to report\n complete or partial results. When the number of CS steps exceeds the maximum HCI\n event size, the Controller may report further results for the CS subevent using the\n HCI_LE_CS_Subevent_Result_Continue event.\n\n When Connection_Handle is set to 0x0FFF, the Config_ID and Start_ACL_Conn_-\n Event_Counter parameters shall be ignored.\n\n The Start_ACL_Conn_Event_Counter parameter indicates the starting ACL connection\n event count from which the CS event results reported in this HCI event are anchored. A\n CS procedure may have CS subevents in multiple ACL connection events anchored\n to the same ACL connection event count as defined by the Event_Interval return\n parameter in the HCI_LE_CS_Procedure_Enable_Complete event.\n\n The Procedure_Counter parameter indicates the associated CS procedure count for the\n results reported in this HCI event (see 6] Part B, Section 5.1.24).\n The Frequency_Compensation parameter indicates the value of the fractional frequency\n offset (FFO) used by the initiator device to align the timing of CS steps and transmit\n frequencies during non-mode-0 CS steps (see 6] Part A, Section 3.5.1).\n\n The Reference_Power_Level parameter is expressed in dBm and is described in 6]\n Part H, Section 4.6 and 6] Part H, Section 3.3.1. If the reference power level value\n is not available during a subevent, then this value shall be set to 0x7F.\n\n When bits 0 to 3 of Subevent_Done_Status are set to 0x1, the Controller shall send\n one or more LE CS Subevent Result Continue events for the current CS subevent.\n Otherwise, the Controller sends no further events for the current CS subevent.\n\n When bits 0 to 3 of Procedure_Done_Status are set to 0x1, the Controller shall send\n one or more LE CS Subevent Result or LE CS Subevent Result Continue events for the\n current or subsequent CS procedure. Otherwise, the Controller sends no further events\n for the current CS procedure. When bits 0 to 3 of Procedure_Done_Status are set to\n 0xF or when results of all CS procedures are sent to the Host, the Controller sends no\n further events until a new CS procedure measurement is enabled by the Host.\n\n The allowed combinations of Procedure_Done_Status and Subevent_Done_Status are\n shown in Table 7.2.\n\n Procedure_Done_Status Allowed values of Subevent_Done_Status\n (Bits 0 to 3) (Bits 0 to 3)\n 0x0 0x0, 0xF\n 0x1 0x0, 0x1, 0xF\n 0xF 0x0, 0xF\n Table 7.2: Allowed combinations of done status\n\n The Num_Antenna_Paths parameter indicates the number of antenna paths used for\n CS tone exchanges.\n\n The Num_Steps_Reported parameter indicates the number of CS steps for which\n results are reported. The Step_Modeparameter indicates the CS mode for each CS\n step, and the Step_Channelparameter indicates the channel used for each CS step.\n A Controller may return a value 0 when a subevent is aborted.\n\n The Step_Data_Lengthand Step_Dataparameters indicate the reported data\n that varies based on the CS mode and the CS role of the local device. When\n Step_Data_Lengthis set to zero, it indicates that the Step may have been aborted for\n unspecified reasons. Otherwise, the Step_Dataindicates the mode- and role-specific\n information being reported.\n\n For each CS procedure in a repeat sequence, the Controller shall report the results\n for each CS step in each CS subevent of the CS procedure even if the CS step has\n been aborted for any reason. In order to terminate reporting of pending CS steps in\n a CS subevent, the Controller shall set the Subevent_Done_Status parameter to 0xF\n in the HCI_LE_CS_Subevent_Result or the HCI_LE_CS_Subevent_Result_Continue\n event and shall not report any additional HCI_LE_CS_Subevent_Result_Continue\n events for that CS subevent. The Controller may terminate reporting of pending\n CS procedures by setting the Procedure_Done_Status parameter to 0xF in the\n HCI_LE_CS_Subevent_Result or the HCI_LE_CS_Subevent_Result_Continue event\n and shall not report any additional HCI_LE_CS_Subevent_Result_Continue events for\n that CS measurement."]
#[repr(C, packed)]
pub struct sdc_hci_subevent_le_cs_subevent_result_t {
    pub conn_handle: u16,
    pub config_id: u8,
    pub start_acl_conn_event_counter: u16,
    pub procedure_counter: u16,
    pub frequency_compensation: u16,
    pub reference_power_level: i8,
    pub procedure_done_status: u8,
    pub subevent_done_status: u8,
    pub abort_reason: u8,
    pub num_antenna_paths: u8,
    pub num_steps_reported: u8,
    #[doc = "C does not allow array of variable sized arrays, otherwise it should be sdc_hci_le_cs_subevent_result_array_params_t data"]
    pub data: __IncompleteArrayField<u8>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_subevent_le_cs_subevent_result_t"]
        [::core::mem::size_of::<sdc_hci_subevent_le_cs_subevent_result_t>() - 15usize];
    ["Alignment of sdc_hci_subevent_le_cs_subevent_result_t"]
        [::core::mem::align_of::<sdc_hci_subevent_le_cs_subevent_result_t>() - 1usize];
    ["Offset of field: sdc_hci_subevent_le_cs_subevent_result_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_subevent_result_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_subevent_le_cs_subevent_result_t::config_id"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_subevent_result_t, config_id) - 2usize];
    ["Offset of field: sdc_hci_subevent_le_cs_subevent_result_t::start_acl_conn_event_counter"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_subevent_result_t, start_acl_conn_event_counter) - 3usize];
    ["Offset of field: sdc_hci_subevent_le_cs_subevent_result_t::procedure_counter"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_subevent_result_t, procedure_counter) - 5usize];
    ["Offset of field: sdc_hci_subevent_le_cs_subevent_result_t::frequency_compensation"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_subevent_result_t, frequency_compensation) - 7usize];
    ["Offset of field: sdc_hci_subevent_le_cs_subevent_result_t::reference_power_level"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_subevent_result_t, reference_power_level) - 9usize];
    ["Offset of field: sdc_hci_subevent_le_cs_subevent_result_t::procedure_done_status"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_subevent_result_t, procedure_done_status) - 10usize];
    ["Offset of field: sdc_hci_subevent_le_cs_subevent_result_t::subevent_done_status"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_subevent_result_t, subevent_done_status) - 11usize];
    ["Offset of field: sdc_hci_subevent_le_cs_subevent_result_t::abort_reason"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_subevent_result_t, abort_reason) - 12usize];
    ["Offset of field: sdc_hci_subevent_le_cs_subevent_result_t::num_antenna_paths"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_subevent_result_t, num_antenna_paths) - 13usize];
    ["Offset of field: sdc_hci_subevent_le_cs_subevent_result_t::num_steps_reported"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_subevent_result_t, num_steps_reported) - 14usize];
    ["Offset of field: sdc_hci_subevent_le_cs_subevent_result_t::data"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_subevent_result_t, data) - 15usize];
};
#[doc = "LE CS Subevent Result Continue.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.7.65.45\n\n The HCI_LE_CS_Subevent_Result_Continue event shall be generated after the local\n Controller has completed a new CS subevent measurement and has already sent an\n HCI_LE_CS_Subevent_Result event for the specified CS subevent.\n\n When Connection_Handle is set to 0x0FFF, the Config_ID parameter shall be ignored."]
#[repr(C, packed)]
pub struct sdc_hci_subevent_le_cs_subevent_result_continue_t {
    pub conn_handle: u16,
    pub config_id: u8,
    pub procedure_done_status: u8,
    pub subevent_done_status: u8,
    pub abort_reason: u8,
    pub num_antenna_paths: u8,
    pub num_steps_reported: u8,
    #[doc = "C does not allow array of variable sized arrays, otherwise it should be sdc_hci_le_cs_subevent_result_continue_array_params_t data"]
    pub data: __IncompleteArrayField<u8>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_subevent_le_cs_subevent_result_continue_t"]
        [::core::mem::size_of::<sdc_hci_subevent_le_cs_subevent_result_continue_t>() - 8usize];
    ["Alignment of sdc_hci_subevent_le_cs_subevent_result_continue_t"]
        [::core::mem::align_of::<sdc_hci_subevent_le_cs_subevent_result_continue_t>() - 1usize];
    ["Offset of field: sdc_hci_subevent_le_cs_subevent_result_continue_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_subevent_result_continue_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_subevent_le_cs_subevent_result_continue_t::config_id"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_subevent_result_continue_t, config_id) - 2usize];
    ["Offset of field: sdc_hci_subevent_le_cs_subevent_result_continue_t::procedure_done_status"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_subevent_result_continue_t, procedure_done_status) - 3usize];
    ["Offset of field: sdc_hci_subevent_le_cs_subevent_result_continue_t::subevent_done_status"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_subevent_result_continue_t, subevent_done_status) - 4usize];
    ["Offset of field: sdc_hci_subevent_le_cs_subevent_result_continue_t::abort_reason"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_subevent_result_continue_t, abort_reason) - 5usize];
    ["Offset of field: sdc_hci_subevent_le_cs_subevent_result_continue_t::num_antenna_paths"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_subevent_result_continue_t, num_antenna_paths) - 6usize];
    ["Offset of field: sdc_hci_subevent_le_cs_subevent_result_continue_t::num_steps_reported"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_subevent_result_continue_t, num_steps_reported) - 7usize];
    ["Offset of field: sdc_hci_subevent_le_cs_subevent_result_continue_t::data"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_subevent_result_continue_t, data) - 8usize];
};
#[doc = "LE CS Test End Complete.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.7.65.46\n\n The HCI_LE_CS_Test_End_Complete event shall be generated when the local\n Controller has stopped an ongoing CS test as a result of the HCI_LE_CS_Test_End\n command. When the HCI_LE_CS_Test_End command is issued by the Host, the\n HCI_LE_CS_Test_End_Complete event shall be sent to the Host after any pending CS\n test result events are sent to the Host."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_subevent_le_cs_test_end_complete_t {
    pub status: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_subevent_le_cs_test_end_complete_t"]
        [::core::mem::size_of::<sdc_hci_subevent_le_cs_test_end_complete_t>() - 1usize];
    ["Alignment of sdc_hci_subevent_le_cs_test_end_complete_t"]
        [::core::mem::align_of::<sdc_hci_subevent_le_cs_test_end_complete_t>() - 1usize];
    ["Offset of field: sdc_hci_subevent_le_cs_test_end_complete_t::status"]
        [::core::mem::offset_of!(sdc_hci_subevent_le_cs_test_end_complete_t, status) - 0usize];
};
#[doc = "LE Set Event Mask command parameter(s)."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union sdc_hci_cmd_le_set_event_mask_t {
    pub params: sdc_hci_le_le_event_mask_t,
    pub raw: [u8; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_event_mask_t"][::core::mem::size_of::<sdc_hci_cmd_le_set_event_mask_t>() - 8usize];
    ["Alignment of sdc_hci_cmd_le_set_event_mask_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_event_mask_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_event_mask_t::params"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_event_mask_t, params) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_event_mask_t::raw"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_event_mask_t, raw) - 0usize];
};
#[doc = "LE Read Buffer Size return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_buffer_size_return_t {
    pub le_acl_data_packet_length: u16,
    pub total_num_le_acl_data_packets: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_read_buffer_size_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_read_buffer_size_return_t>() - 3usize];
    ["Alignment of sdc_hci_cmd_le_read_buffer_size_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_read_buffer_size_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_read_buffer_size_return_t::le_acl_data_packet_length"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_buffer_size_return_t, le_acl_data_packet_length) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_read_buffer_size_return_t::total_num_le_acl_data_packets"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_buffer_size_return_t, total_num_le_acl_data_packets) - 2usize];
};
#[doc = "LE Read Local Supported Features Page 0 return parameter(s)."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union sdc_hci_cmd_le_read_local_supported_features_return_t {
    pub params: sdc_hci_le_le_features_t,
    pub raw: [u8; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_read_local_supported_features_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_read_local_supported_features_return_t>() - 8usize];
    ["Alignment of sdc_hci_cmd_le_read_local_supported_features_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_read_local_supported_features_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_read_local_supported_features_return_t::params"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_local_supported_features_return_t, params) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_read_local_supported_features_return_t::raw"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_local_supported_features_return_t, raw) - 0usize];
};
#[doc = "LE Set Random Address command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_random_address_t {
    pub random_address: [u8; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_random_address_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_random_address_t>() - 6usize];
    ["Alignment of sdc_hci_cmd_le_set_random_address_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_random_address_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_random_address_t::random_address"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_random_address_t, random_address) - 0usize];
};
#[doc = "LE Set Advertising Parameters command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_adv_params_t {
    pub adv_interval_min: u16,
    pub adv_interval_max: u16,
    pub adv_type: u8,
    pub own_address_type: u8,
    pub peer_address_type: u8,
    pub peer_address: [u8; 6usize],
    pub adv_channel_map: u8,
    pub adv_filter_policy: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_adv_params_t"][::core::mem::size_of::<sdc_hci_cmd_le_set_adv_params_t>() - 15usize];
    ["Alignment of sdc_hci_cmd_le_set_adv_params_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_adv_params_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_adv_params_t::adv_interval_min"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_adv_params_t, adv_interval_min) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_adv_params_t::adv_interval_max"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_adv_params_t, adv_interval_max) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_set_adv_params_t::adv_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_adv_params_t, adv_type) - 4usize];
    ["Offset of field: sdc_hci_cmd_le_set_adv_params_t::own_address_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_adv_params_t, own_address_type) - 5usize];
    ["Offset of field: sdc_hci_cmd_le_set_adv_params_t::peer_address_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_adv_params_t, peer_address_type) - 6usize];
    ["Offset of field: sdc_hci_cmd_le_set_adv_params_t::peer_address"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_adv_params_t, peer_address) - 7usize];
    ["Offset of field: sdc_hci_cmd_le_set_adv_params_t::adv_channel_map"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_adv_params_t, adv_channel_map) - 13usize];
    ["Offset of field: sdc_hci_cmd_le_set_adv_params_t::adv_filter_policy"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_adv_params_t, adv_filter_policy) - 14usize];
};
#[doc = "LE Read Advertising Physical Channel Tx Power return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_adv_physical_channel_tx_power_return_t {
    pub tx_power_level: i8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_read_adv_physical_channel_tx_power_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_read_adv_physical_channel_tx_power_return_t>() - 1usize];
    ["Alignment of sdc_hci_cmd_le_read_adv_physical_channel_tx_power_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_read_adv_physical_channel_tx_power_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_read_adv_physical_channel_tx_power_return_t::tx_power_level"][::core::mem::offset_of!(
        sdc_hci_cmd_le_read_adv_physical_channel_tx_power_return_t,
        tx_power_level
    ) - 0usize];
};
#[doc = "LE Set Advertising Data command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_adv_data_t {
    pub adv_data_length: u8,
    pub adv_data: [u8; 31usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_adv_data_t"][::core::mem::size_of::<sdc_hci_cmd_le_set_adv_data_t>() - 32usize];
    ["Alignment of sdc_hci_cmd_le_set_adv_data_t"][::core::mem::align_of::<sdc_hci_cmd_le_set_adv_data_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_adv_data_t::adv_data_length"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_adv_data_t, adv_data_length) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_adv_data_t::adv_data"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_adv_data_t, adv_data) - 1usize];
};
#[doc = "LE Set Scan Response Data command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_scan_response_data_t {
    pub scan_response_data_length: u8,
    pub scan_response_data: [u8; 31usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_scan_response_data_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_scan_response_data_t>() - 32usize];
    ["Alignment of sdc_hci_cmd_le_set_scan_response_data_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_scan_response_data_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_scan_response_data_t::scan_response_data_length"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_scan_response_data_t, scan_response_data_length) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_scan_response_data_t::scan_response_data"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_scan_response_data_t, scan_response_data) - 1usize];
};
#[doc = "LE Set Advertising Enable command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_adv_enable_t {
    pub adv_enable: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_adv_enable_t"][::core::mem::size_of::<sdc_hci_cmd_le_set_adv_enable_t>() - 1usize];
    ["Alignment of sdc_hci_cmd_le_set_adv_enable_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_adv_enable_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_adv_enable_t::adv_enable"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_adv_enable_t, adv_enable) - 0usize];
};
#[doc = "LE Set Scan Parameters command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_scan_params_t {
    pub le_scan_type: u8,
    pub le_scan_interval: u16,
    pub le_scan_window: u16,
    pub own_address_type: u8,
    pub scanning_filter_policy: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_scan_params_t"][::core::mem::size_of::<sdc_hci_cmd_le_set_scan_params_t>() - 7usize];
    ["Alignment of sdc_hci_cmd_le_set_scan_params_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_scan_params_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_scan_params_t::le_scan_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_scan_params_t, le_scan_type) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_scan_params_t::le_scan_interval"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_scan_params_t, le_scan_interval) - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_scan_params_t::le_scan_window"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_scan_params_t, le_scan_window) - 3usize];
    ["Offset of field: sdc_hci_cmd_le_set_scan_params_t::own_address_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_scan_params_t, own_address_type) - 5usize];
    ["Offset of field: sdc_hci_cmd_le_set_scan_params_t::scanning_filter_policy"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_scan_params_t, scanning_filter_policy) - 6usize];
};
#[doc = "LE Set Scan Enable command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_scan_enable_t {
    pub le_scan_enable: u8,
    pub filter_duplicates: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_scan_enable_t"][::core::mem::size_of::<sdc_hci_cmd_le_set_scan_enable_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_set_scan_enable_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_scan_enable_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_scan_enable_t::le_scan_enable"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_scan_enable_t, le_scan_enable) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_scan_enable_t::filter_duplicates"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_scan_enable_t, filter_duplicates) - 1usize];
};
#[doc = "LE Create Connection command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_create_conn_t {
    pub le_scan_interval: u16,
    pub le_scan_window: u16,
    pub initiator_filter_policy: u8,
    pub peer_address_type: u8,
    pub peer_address: [u8; 6usize],
    pub own_address_type: u8,
    pub conn_interval_min: u16,
    pub conn_interval_max: u16,
    pub max_latency: u16,
    pub supervision_timeout: u16,
    pub min_ce_length: u16,
    pub max_ce_length: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_create_conn_t"][::core::mem::size_of::<sdc_hci_cmd_le_create_conn_t>() - 25usize];
    ["Alignment of sdc_hci_cmd_le_create_conn_t"][::core::mem::align_of::<sdc_hci_cmd_le_create_conn_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_create_conn_t::le_scan_interval"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_conn_t, le_scan_interval) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_create_conn_t::le_scan_window"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_conn_t, le_scan_window) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_create_conn_t::initiator_filter_policy"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_conn_t, initiator_filter_policy) - 4usize];
    ["Offset of field: sdc_hci_cmd_le_create_conn_t::peer_address_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_conn_t, peer_address_type) - 5usize];
    ["Offset of field: sdc_hci_cmd_le_create_conn_t::peer_address"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_conn_t, peer_address) - 6usize];
    ["Offset of field: sdc_hci_cmd_le_create_conn_t::own_address_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_conn_t, own_address_type) - 12usize];
    ["Offset of field: sdc_hci_cmd_le_create_conn_t::conn_interval_min"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_conn_t, conn_interval_min) - 13usize];
    ["Offset of field: sdc_hci_cmd_le_create_conn_t::conn_interval_max"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_conn_t, conn_interval_max) - 15usize];
    ["Offset of field: sdc_hci_cmd_le_create_conn_t::max_latency"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_conn_t, max_latency) - 17usize];
    ["Offset of field: sdc_hci_cmd_le_create_conn_t::supervision_timeout"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_conn_t, supervision_timeout) - 19usize];
    ["Offset of field: sdc_hci_cmd_le_create_conn_t::min_ce_length"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_conn_t, min_ce_length) - 21usize];
    ["Offset of field: sdc_hci_cmd_le_create_conn_t::max_ce_length"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_conn_t, max_ce_length) - 23usize];
};
#[doc = "LE Read Filter Accept List Size return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_filter_accept_list_size_return_t {
    pub filter_accept_list_size: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_read_filter_accept_list_size_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_read_filter_accept_list_size_return_t>() - 1usize];
    ["Alignment of sdc_hci_cmd_le_read_filter_accept_list_size_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_read_filter_accept_list_size_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_read_filter_accept_list_size_return_t::filter_accept_list_size"][::core::mem::offset_of!(
        sdc_hci_cmd_le_read_filter_accept_list_size_return_t,
        filter_accept_list_size
    ) - 0usize];
};
#[doc = "LE Add Device To Filter Accept List command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_add_device_to_filter_accept_list_t {
    pub address_type: u8,
    pub address: [u8; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_add_device_to_filter_accept_list_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_add_device_to_filter_accept_list_t>() - 7usize];
    ["Alignment of sdc_hci_cmd_le_add_device_to_filter_accept_list_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_add_device_to_filter_accept_list_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_add_device_to_filter_accept_list_t::address_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_add_device_to_filter_accept_list_t, address_type) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_add_device_to_filter_accept_list_t::address"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_add_device_to_filter_accept_list_t, address) - 1usize];
};
#[doc = "LE Remove Device From Filter Accept List command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_remove_device_from_filter_accept_list_t {
    pub address_type: u8,
    pub address: [u8; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_remove_device_from_filter_accept_list_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_remove_device_from_filter_accept_list_t>() - 7usize];
    ["Alignment of sdc_hci_cmd_le_remove_device_from_filter_accept_list_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_remove_device_from_filter_accept_list_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_remove_device_from_filter_accept_list_t::address_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_remove_device_from_filter_accept_list_t, address_type) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_remove_device_from_filter_accept_list_t::address"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_remove_device_from_filter_accept_list_t, address) - 1usize];
};
#[doc = "LE Connection Update command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_conn_update_t {
    pub conn_handle: u16,
    pub conn_interval_min: u16,
    pub conn_interval_max: u16,
    pub max_latency: u16,
    pub supervision_timeout: u16,
    pub min_ce_length: u16,
    pub max_ce_length: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_conn_update_t"][::core::mem::size_of::<sdc_hci_cmd_le_conn_update_t>() - 14usize];
    ["Alignment of sdc_hci_cmd_le_conn_update_t"][::core::mem::align_of::<sdc_hci_cmd_le_conn_update_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_conn_update_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_conn_update_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_conn_update_t::conn_interval_min"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_conn_update_t, conn_interval_min) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_conn_update_t::conn_interval_max"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_conn_update_t, conn_interval_max) - 4usize];
    ["Offset of field: sdc_hci_cmd_le_conn_update_t::max_latency"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_conn_update_t, max_latency) - 6usize];
    ["Offset of field: sdc_hci_cmd_le_conn_update_t::supervision_timeout"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_conn_update_t, supervision_timeout) - 8usize];
    ["Offset of field: sdc_hci_cmd_le_conn_update_t::min_ce_length"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_conn_update_t, min_ce_length) - 10usize];
    ["Offset of field: sdc_hci_cmd_le_conn_update_t::max_ce_length"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_conn_update_t, max_ce_length) - 12usize];
};
#[doc = "LE Set Host Channel Classification command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_host_channel_classification_t {
    pub channel_map: [u8; 5usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_host_channel_classification_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_host_channel_classification_t>() - 5usize];
    ["Alignment of sdc_hci_cmd_le_set_host_channel_classification_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_host_channel_classification_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_host_channel_classification_t::channel_map"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_host_channel_classification_t, channel_map) - 0usize];
};
#[doc = "LE Read Channel Map command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_channel_map_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_read_channel_map_t"][::core::mem::size_of::<sdc_hci_cmd_le_read_channel_map_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_read_channel_map_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_read_channel_map_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_read_channel_map_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_channel_map_t, conn_handle) - 0usize];
};
#[doc = "LE Read Channel Map return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_channel_map_return_t {
    pub conn_handle: u16,
    pub channel_map: [u8; 5usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_read_channel_map_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_read_channel_map_return_t>() - 7usize];
    ["Alignment of sdc_hci_cmd_le_read_channel_map_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_read_channel_map_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_read_channel_map_return_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_channel_map_return_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_read_channel_map_return_t::channel_map"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_channel_map_return_t, channel_map) - 2usize];
};
#[doc = "LE Read Remote Features command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_remote_features_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_read_remote_features_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_read_remote_features_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_read_remote_features_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_read_remote_features_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_read_remote_features_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_remote_features_t, conn_handle) - 0usize];
};
#[doc = "LE Encrypt command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_encrypt_t {
    pub key: [u8; 16usize],
    pub plaintext_data: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_encrypt_t"][::core::mem::size_of::<sdc_hci_cmd_le_encrypt_t>() - 32usize];
    ["Alignment of sdc_hci_cmd_le_encrypt_t"][::core::mem::align_of::<sdc_hci_cmd_le_encrypt_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_encrypt_t::key"][::core::mem::offset_of!(sdc_hci_cmd_le_encrypt_t, key) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_encrypt_t::plaintext_data"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_encrypt_t, plaintext_data) - 16usize];
};
#[doc = "LE Encrypt return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_encrypt_return_t {
    pub encrypted_data: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_encrypt_return_t"][::core::mem::size_of::<sdc_hci_cmd_le_encrypt_return_t>() - 16usize];
    ["Alignment of sdc_hci_cmd_le_encrypt_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_encrypt_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_encrypt_return_t::encrypted_data"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_encrypt_return_t, encrypted_data) - 0usize];
};
#[doc = "LE Rand return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_rand_return_t {
    pub random_number: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_rand_return_t"][::core::mem::size_of::<sdc_hci_cmd_le_rand_return_t>() - 8usize];
    ["Alignment of sdc_hci_cmd_le_rand_return_t"][::core::mem::align_of::<sdc_hci_cmd_le_rand_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_rand_return_t::random_number"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_rand_return_t, random_number) - 0usize];
};
#[doc = "LE Enable Encryption command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_enable_encryption_t {
    pub conn_handle: u16,
    pub random_number: [u8; 8usize],
    pub encrypted_diversifier: [u8; 2usize],
    pub long_term_key: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_enable_encryption_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_enable_encryption_t>() - 28usize];
    ["Alignment of sdc_hci_cmd_le_enable_encryption_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_enable_encryption_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_enable_encryption_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_enable_encryption_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_enable_encryption_t::random_number"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_enable_encryption_t, random_number) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_enable_encryption_t::encrypted_diversifier"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_enable_encryption_t, encrypted_diversifier) - 10usize];
    ["Offset of field: sdc_hci_cmd_le_enable_encryption_t::long_term_key"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_enable_encryption_t, long_term_key) - 12usize];
};
#[doc = "LE Long Term Key Request Reply command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_long_term_key_request_reply_t {
    pub conn_handle: u16,
    pub long_term_key: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_long_term_key_request_reply_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_long_term_key_request_reply_t>() - 18usize];
    ["Alignment of sdc_hci_cmd_le_long_term_key_request_reply_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_long_term_key_request_reply_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_long_term_key_request_reply_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_long_term_key_request_reply_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_long_term_key_request_reply_t::long_term_key"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_long_term_key_request_reply_t, long_term_key) - 2usize];
};
#[doc = "LE Long Term Key Request Reply return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_long_term_key_request_reply_return_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_long_term_key_request_reply_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_long_term_key_request_reply_return_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_long_term_key_request_reply_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_long_term_key_request_reply_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_long_term_key_request_reply_return_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_long_term_key_request_reply_return_t, conn_handle) - 0usize];
};
#[doc = "LE Long Term Key Request Negative Reply command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_long_term_key_request_negative_reply_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_long_term_key_request_negative_reply_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_long_term_key_request_negative_reply_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_long_term_key_request_negative_reply_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_long_term_key_request_negative_reply_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_long_term_key_request_negative_reply_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_long_term_key_request_negative_reply_t, conn_handle) - 0usize];
};
#[doc = "LE Long Term Key Request Negative Reply return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_long_term_key_request_negative_reply_return_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_long_term_key_request_negative_reply_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_long_term_key_request_negative_reply_return_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_long_term_key_request_negative_reply_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_long_term_key_request_negative_reply_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_long_term_key_request_negative_reply_return_t::conn_handle"][::core::mem::offset_of!(
        sdc_hci_cmd_le_long_term_key_request_negative_reply_return_t,
        conn_handle
    ) - 0usize];
};
#[doc = "LE Read Supported States return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_supported_states_return_t {
    #[doc = "See the table in Core v6.0, Vol 4, Part E, Section 7.8.27."]
    pub le_states: [u8; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_read_supported_states_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_read_supported_states_return_t>() - 8usize];
    ["Alignment of sdc_hci_cmd_le_read_supported_states_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_read_supported_states_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_read_supported_states_return_t::le_states"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_supported_states_return_t, le_states) - 0usize];
};
#[doc = "LE Set Data Length command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_data_length_t {
    pub conn_handle: u16,
    pub tx_octets: u16,
    pub tx_time: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_data_length_t"][::core::mem::size_of::<sdc_hci_cmd_le_set_data_length_t>() - 6usize];
    ["Alignment of sdc_hci_cmd_le_set_data_length_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_data_length_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_data_length_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_data_length_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_data_length_t::tx_octets"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_data_length_t, tx_octets) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_set_data_length_t::tx_time"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_data_length_t, tx_time) - 4usize];
};
#[doc = "LE Set Data Length return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_data_length_return_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_data_length_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_data_length_return_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_set_data_length_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_data_length_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_data_length_return_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_data_length_return_t, conn_handle) - 0usize];
};
#[doc = "LE Read Suggested Default Data Length return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_suggested_default_data_length_return_t {
    pub suggested_max_tx_octets: u16,
    pub suggested_max_tx_time: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_read_suggested_default_data_length_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_read_suggested_default_data_length_return_t>() - 4usize];
    ["Alignment of sdc_hci_cmd_le_read_suggested_default_data_length_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_read_suggested_default_data_length_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_read_suggested_default_data_length_return_t::suggested_max_tx_octets"][::core::mem::offset_of!(
        sdc_hci_cmd_le_read_suggested_default_data_length_return_t,
        suggested_max_tx_octets
    )
        - 0usize];
    ["Offset of field: sdc_hci_cmd_le_read_suggested_default_data_length_return_t::suggested_max_tx_time"][::core::mem::offset_of!(
        sdc_hci_cmd_le_read_suggested_default_data_length_return_t,
        suggested_max_tx_time
    ) - 2usize];
};
#[doc = "LE Write Suggested Default Data Length command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_write_suggested_default_data_length_t {
    pub suggested_max_tx_octets: u16,
    pub suggested_max_tx_time: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_write_suggested_default_data_length_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_write_suggested_default_data_length_t>() - 4usize];
    ["Alignment of sdc_hci_cmd_le_write_suggested_default_data_length_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_write_suggested_default_data_length_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_write_suggested_default_data_length_t::suggested_max_tx_octets"][::core::mem::offset_of!(
        sdc_hci_cmd_le_write_suggested_default_data_length_t,
        suggested_max_tx_octets
    ) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_write_suggested_default_data_length_t::suggested_max_tx_time"][::core::mem::offset_of!(
        sdc_hci_cmd_le_write_suggested_default_data_length_t,
        suggested_max_tx_time
    ) - 2usize];
};
#[doc = "LE Add Device To Resolving List command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_add_device_to_resolving_list_t {
    pub peer_identity_address_type: u8,
    pub peer_identity_address: [u8; 6usize],
    pub peer_irk: [u8; 16usize],
    pub local_irk: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_add_device_to_resolving_list_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_add_device_to_resolving_list_t>() - 39usize];
    ["Alignment of sdc_hci_cmd_le_add_device_to_resolving_list_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_add_device_to_resolving_list_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_add_device_to_resolving_list_t::peer_identity_address_type"][::core::mem::offset_of!(
        sdc_hci_cmd_le_add_device_to_resolving_list_t,
        peer_identity_address_type
    ) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_add_device_to_resolving_list_t::peer_identity_address"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_add_device_to_resolving_list_t, peer_identity_address) - 1usize];
    ["Offset of field: sdc_hci_cmd_le_add_device_to_resolving_list_t::peer_irk"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_add_device_to_resolving_list_t, peer_irk) - 7usize];
    ["Offset of field: sdc_hci_cmd_le_add_device_to_resolving_list_t::local_irk"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_add_device_to_resolving_list_t, local_irk) - 23usize];
};
#[doc = "LE Remove Device From Resolving List command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_remove_device_from_resolving_list_t {
    pub peer_identity_address_type: u8,
    pub peer_identity_address: [u8; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_remove_device_from_resolving_list_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_remove_device_from_resolving_list_t>() - 7usize];
    ["Alignment of sdc_hci_cmd_le_remove_device_from_resolving_list_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_remove_device_from_resolving_list_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_remove_device_from_resolving_list_t::peer_identity_address_type"][::core::mem::offset_of!(
        sdc_hci_cmd_le_remove_device_from_resolving_list_t,
        peer_identity_address_type
    ) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_remove_device_from_resolving_list_t::peer_identity_address"][::core::mem::offset_of!(
        sdc_hci_cmd_le_remove_device_from_resolving_list_t,
        peer_identity_address
    ) - 1usize];
};
#[doc = "LE Read Resolving List Size return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_resolving_list_size_return_t {
    pub resolving_list_size: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_read_resolving_list_size_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_read_resolving_list_size_return_t>() - 1usize];
    ["Alignment of sdc_hci_cmd_le_read_resolving_list_size_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_read_resolving_list_size_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_read_resolving_list_size_return_t::resolving_list_size"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_resolving_list_size_return_t, resolving_list_size) - 0usize];
};
#[doc = "LE Set Address Resolution Enable command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_address_resolution_enable_t {
    pub address_resolution_enable: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_address_resolution_enable_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_address_resolution_enable_t>() - 1usize];
    ["Alignment of sdc_hci_cmd_le_set_address_resolution_enable_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_address_resolution_enable_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_address_resolution_enable_t::address_resolution_enable"][::core::mem::offset_of!(
        sdc_hci_cmd_le_set_address_resolution_enable_t,
        address_resolution_enable
    ) - 0usize];
};
#[doc = "LE Set Resolvable Private Address Timeout command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_resolvable_private_address_timeout_t {
    pub rpa_timeout: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_resolvable_private_address_timeout_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_resolvable_private_address_timeout_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_set_resolvable_private_address_timeout_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_resolvable_private_address_timeout_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_resolvable_private_address_timeout_t::rpa_timeout"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_resolvable_private_address_timeout_t, rpa_timeout) - 0usize];
};
#[doc = "LE Read Maximum Data Length return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_max_data_length_return_t {
    pub supported_max_tx_octets: u16,
    pub supported_max_tx_time: u16,
    pub supported_max_rx_octets: u16,
    pub supported_max_rx_time: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_read_max_data_length_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_read_max_data_length_return_t>() - 8usize];
    ["Alignment of sdc_hci_cmd_le_read_max_data_length_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_read_max_data_length_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_read_max_data_length_return_t::supported_max_tx_octets"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_max_data_length_return_t, supported_max_tx_octets) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_read_max_data_length_return_t::supported_max_tx_time"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_max_data_length_return_t, supported_max_tx_time) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_read_max_data_length_return_t::supported_max_rx_octets"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_max_data_length_return_t, supported_max_rx_octets) - 4usize];
    ["Offset of field: sdc_hci_cmd_le_read_max_data_length_return_t::supported_max_rx_time"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_max_data_length_return_t, supported_max_rx_time) - 6usize];
};
#[doc = "LE Read PHY command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_phy_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_read_phy_t"][::core::mem::size_of::<sdc_hci_cmd_le_read_phy_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_read_phy_t"][::core::mem::align_of::<sdc_hci_cmd_le_read_phy_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_read_phy_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_phy_t, conn_handle) - 0usize];
};
#[doc = "LE Read PHY return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_phy_return_t {
    pub conn_handle: u16,
    pub tx_phy: u8,
    pub rx_phy: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_read_phy_return_t"][::core::mem::size_of::<sdc_hci_cmd_le_read_phy_return_t>() - 4usize];
    ["Alignment of sdc_hci_cmd_le_read_phy_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_read_phy_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_read_phy_return_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_phy_return_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_read_phy_return_t::tx_phy"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_phy_return_t, tx_phy) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_read_phy_return_t::rx_phy"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_phy_return_t, rx_phy) - 3usize];
};
#[doc = "LE Set Default PHY command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_default_phy_t {
    pub all_phys: u8,
    pub tx_phys: u8,
    pub rx_phys: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_default_phy_t"][::core::mem::size_of::<sdc_hci_cmd_le_set_default_phy_t>() - 3usize];
    ["Alignment of sdc_hci_cmd_le_set_default_phy_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_default_phy_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_default_phy_t::all_phys"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_default_phy_t, all_phys) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_default_phy_t::tx_phys"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_default_phy_t, tx_phys) - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_default_phy_t::rx_phys"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_default_phy_t, rx_phys) - 2usize];
};
#[doc = "LE Set PHY command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_phy_t {
    pub conn_handle: u16,
    pub all_phys: u8,
    pub tx_phys: u8,
    pub rx_phys: u8,
    pub phy_options: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_phy_t"][::core::mem::size_of::<sdc_hci_cmd_le_set_phy_t>() - 7usize];
    ["Alignment of sdc_hci_cmd_le_set_phy_t"][::core::mem::align_of::<sdc_hci_cmd_le_set_phy_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_phy_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_phy_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_phy_t::all_phys"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_phy_t, all_phys) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_set_phy_t::tx_phys"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_phy_t, tx_phys) - 3usize];
    ["Offset of field: sdc_hci_cmd_le_set_phy_t::rx_phys"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_phy_t, rx_phys) - 4usize];
    ["Offset of field: sdc_hci_cmd_le_set_phy_t::phy_options"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_phy_t, phy_options) - 5usize];
};
#[doc = "LE Set Advertising Set Random Address command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_adv_set_random_address_t {
    pub adv_handle: u8,
    pub random_address: [u8; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_adv_set_random_address_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_adv_set_random_address_t>() - 7usize];
    ["Alignment of sdc_hci_cmd_le_set_adv_set_random_address_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_adv_set_random_address_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_adv_set_random_address_t::adv_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_adv_set_random_address_t, adv_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_adv_set_random_address_t::random_address"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_adv_set_random_address_t, random_address) - 1usize];
};
#[doc = "LE Set Extended Advertising Parameters command parameter(s)."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sdc_hci_cmd_le_set_ext_adv_params_t {
    pub adv_handle: u8,
    pub adv_event_properties: sdc_hci_cmd_le_set_ext_adv_params_t__bindgen_ty_1,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 6usize]>,
    pub primary_adv_channel_map: u8,
    pub own_address_type: u8,
    pub peer_address_type: u8,
    pub peer_address: [u8; 6usize],
    pub adv_filter_policy: u8,
    pub adv_tx_power: i8,
    pub primary_adv_phy: u8,
    pub secondary_adv_max_skip: u8,
    pub secondary_adv_phy: u8,
    pub adv_sid: u8,
    pub scan_request_notification_enable: u8,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union sdc_hci_cmd_le_set_ext_adv_params_t__bindgen_ty_1 {
    pub params: sdc_hci_le_adv_event_properties_params_t,
    pub raw: [u8; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_ext_adv_params_t__bindgen_ty_1"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_ext_adv_params_t__bindgen_ty_1>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_set_ext_adv_params_t__bindgen_ty_1"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_ext_adv_params_t__bindgen_ty_1>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_t__bindgen_ty_1::params"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_t__bindgen_ty_1, params) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_t__bindgen_ty_1::raw"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_t__bindgen_ty_1, raw) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_ext_adv_params_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_ext_adv_params_t>() - 25usize];
    ["Alignment of sdc_hci_cmd_le_set_ext_adv_params_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_ext_adv_params_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_t::adv_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_t, adv_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_t::adv_event_properties"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_t, adv_event_properties) - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_t::primary_adv_channel_map"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_t, primary_adv_channel_map) - 9usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_t::own_address_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_t, own_address_type) - 10usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_t::peer_address_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_t, peer_address_type) - 11usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_t::peer_address"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_t, peer_address) - 12usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_t::adv_filter_policy"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_t, adv_filter_policy) - 18usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_t::adv_tx_power"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_t, adv_tx_power) - 19usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_t::primary_adv_phy"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_t, primary_adv_phy) - 20usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_t::secondary_adv_max_skip"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_t, secondary_adv_max_skip) - 21usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_t::secondary_adv_phy"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_t, secondary_adv_phy) - 22usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_t::adv_sid"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_t, adv_sid) - 23usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_t::scan_request_notification_enable"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_t, scan_request_notification_enable) - 24usize];
};
impl sdc_hci_cmd_le_set_ext_adv_params_t {
    #[inline]
    pub fn primary_adv_interval_min(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_primary_adv_interval_min(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn primary_adv_interval_min_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_primary_adv_interval_min_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn primary_adv_interval_max(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_primary_adv_interval_max(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn primary_adv_interval_max_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_primary_adv_interval_max_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        primary_adv_interval_min: u32,
        primary_adv_interval_max: u32,
    ) -> __BindgenBitfieldUnit<[u8; 6usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 6usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let primary_adv_interval_min: u32 = unsafe { ::core::mem::transmute(primary_adv_interval_min) };
            primary_adv_interval_min as u64
        });
        __bindgen_bitfield_unit.set(24usize, 24u8, {
            let primary_adv_interval_max: u32 = unsafe { ::core::mem::transmute(primary_adv_interval_max) };
            primary_adv_interval_max as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "LE Set Extended Advertising Parameters return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_ext_adv_params_return_t {
    pub selected_tx_power: i8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_ext_adv_params_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_ext_adv_params_return_t>() - 1usize];
    ["Alignment of sdc_hci_cmd_le_set_ext_adv_params_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_ext_adv_params_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_return_t::selected_tx_power"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_return_t, selected_tx_power) - 0usize];
};
#[doc = "LE Set Extended Advertising Data command parameter(s)."]
#[repr(C, packed)]
pub struct sdc_hci_cmd_le_set_ext_adv_data_t {
    pub adv_handle: u8,
    pub operation: u8,
    pub fragment_preference: u8,
    pub adv_data_length: u8,
    pub adv_data: __IncompleteArrayField<u8>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_ext_adv_data_t"][::core::mem::size_of::<sdc_hci_cmd_le_set_ext_adv_data_t>() - 4usize];
    ["Alignment of sdc_hci_cmd_le_set_ext_adv_data_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_ext_adv_data_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_data_t::adv_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_data_t, adv_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_data_t::operation"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_data_t, operation) - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_data_t::fragment_preference"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_data_t, fragment_preference) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_data_t::adv_data_length"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_data_t, adv_data_length) - 3usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_data_t::adv_data"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_data_t, adv_data) - 4usize];
};
#[doc = "LE Set Extended Scan Response Data command parameter(s)."]
#[repr(C, packed)]
pub struct sdc_hci_cmd_le_set_ext_scan_response_data_t {
    pub adv_handle: u8,
    pub operation: u8,
    pub fragment_preference: u8,
    pub scan_response_data_length: u8,
    pub scan_response_data: __IncompleteArrayField<u8>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_ext_scan_response_data_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_ext_scan_response_data_t>() - 4usize];
    ["Alignment of sdc_hci_cmd_le_set_ext_scan_response_data_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_ext_scan_response_data_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_scan_response_data_t::adv_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_scan_response_data_t, adv_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_scan_response_data_t::operation"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_scan_response_data_t, operation) - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_scan_response_data_t::fragment_preference"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_scan_response_data_t, fragment_preference) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_scan_response_data_t::scan_response_data_length"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_scan_response_data_t, scan_response_data_length) - 3usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_scan_response_data_t::scan_response_data"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_scan_response_data_t, scan_response_data) - 4usize];
};
#[doc = "LE Set Extended Advertising Enable command parameter(s)."]
#[repr(C, packed)]
pub struct sdc_hci_cmd_le_set_ext_adv_enable_t {
    pub enable: u8,
    pub num_sets: u8,
    pub array_params: __IncompleteArrayField<sdc_hci_le_set_ext_adv_enable_array_params_t>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_ext_adv_enable_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_ext_adv_enable_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_set_ext_adv_enable_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_ext_adv_enable_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_enable_t::enable"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_enable_t, enable) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_enable_t::num_sets"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_enable_t, num_sets) - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_enable_t::array_params"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_enable_t, array_params) - 2usize];
};
#[doc = "LE Read Maximum Advertising Data Length return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_max_adv_data_length_return_t {
    pub max_adv_data_length: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_read_max_adv_data_length_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_read_max_adv_data_length_return_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_read_max_adv_data_length_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_read_max_adv_data_length_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_read_max_adv_data_length_return_t::max_adv_data_length"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_max_adv_data_length_return_t, max_adv_data_length) - 0usize];
};
#[doc = "LE Read Number of Supported Advertising Sets return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_number_of_supported_adv_sets_return_t {
    pub num_supported_adv_sets: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_read_number_of_supported_adv_sets_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_read_number_of_supported_adv_sets_return_t>() - 1usize];
    ["Alignment of sdc_hci_cmd_le_read_number_of_supported_adv_sets_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_read_number_of_supported_adv_sets_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_read_number_of_supported_adv_sets_return_t::num_supported_adv_sets"][::core::mem::offset_of!(
        sdc_hci_cmd_le_read_number_of_supported_adv_sets_return_t,
        num_supported_adv_sets
    ) - 0usize];
};
#[doc = "LE Remove Advertising Set command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_remove_adv_set_t {
    pub adv_handle: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_remove_adv_set_t"][::core::mem::size_of::<sdc_hci_cmd_le_remove_adv_set_t>() - 1usize];
    ["Alignment of sdc_hci_cmd_le_remove_adv_set_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_remove_adv_set_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_remove_adv_set_t::adv_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_remove_adv_set_t, adv_handle) - 0usize];
};
#[doc = "LE Set Periodic Advertising Parameters command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_periodic_adv_params_t {
    pub adv_handle: u8,
    pub periodic_adv_interval_min: u16,
    pub periodic_adv_interval_max: u16,
    pub periodic_adv_properties: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_periodic_adv_params_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_periodic_adv_params_t>() - 7usize];
    ["Alignment of sdc_hci_cmd_le_set_periodic_adv_params_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_periodic_adv_params_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_params_t::adv_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_params_t, adv_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_params_t::periodic_adv_interval_min"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_params_t, periodic_adv_interval_min) - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_params_t::periodic_adv_interval_max"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_params_t, periodic_adv_interval_max) - 3usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_params_t::periodic_adv_properties"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_params_t, periodic_adv_properties) - 5usize];
};
#[doc = "LE Set Periodic Advertising Data command parameter(s)."]
#[repr(C, packed)]
pub struct sdc_hci_cmd_le_set_periodic_adv_data_t {
    pub adv_handle: u8,
    pub operation: u8,
    pub adv_data_length: u8,
    pub adv_data: __IncompleteArrayField<u8>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_periodic_adv_data_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_periodic_adv_data_t>() - 3usize];
    ["Alignment of sdc_hci_cmd_le_set_periodic_adv_data_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_periodic_adv_data_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_data_t::adv_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_data_t, adv_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_data_t::operation"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_data_t, operation) - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_data_t::adv_data_length"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_data_t, adv_data_length) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_data_t::adv_data"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_data_t, adv_data) - 3usize];
};
#[doc = "LE Set Periodic Advertising Enable command parameter(s)."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sdc_hci_cmd_le_set_periodic_adv_enable_t {
    pub enable: sdc_hci_cmd_le_set_periodic_adv_enable_t__bindgen_ty_1,
    pub adv_handle: u8,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union sdc_hci_cmd_le_set_periodic_adv_enable_t__bindgen_ty_1 {
    pub params: sdc_hci_le_set_periodic_adv_enable_params_t,
    pub raw: [u8; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_periodic_adv_enable_t__bindgen_ty_1"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_periodic_adv_enable_t__bindgen_ty_1>() - 1usize];
    ["Alignment of sdc_hci_cmd_le_set_periodic_adv_enable_t__bindgen_ty_1"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_periodic_adv_enable_t__bindgen_ty_1>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_enable_t__bindgen_ty_1::params"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_enable_t__bindgen_ty_1, params) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_enable_t__bindgen_ty_1::raw"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_enable_t__bindgen_ty_1, raw) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_periodic_adv_enable_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_periodic_adv_enable_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_set_periodic_adv_enable_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_periodic_adv_enable_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_enable_t::enable"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_enable_t, enable) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_enable_t::adv_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_enable_t, adv_handle) - 1usize];
};
#[doc = "LE Set Extended Scan Parameters command parameter(s)."]
#[repr(C, packed)]
pub struct sdc_hci_cmd_le_set_ext_scan_params_t {
    pub own_address_type: u8,
    pub scanning_filter_policy: u8,
    pub scanning_phys: u8,
    pub array_params: __IncompleteArrayField<sdc_hci_le_set_ext_scan_params_array_params_t>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_ext_scan_params_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_ext_scan_params_t>() - 3usize];
    ["Alignment of sdc_hci_cmd_le_set_ext_scan_params_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_ext_scan_params_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_scan_params_t::own_address_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_scan_params_t, own_address_type) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_scan_params_t::scanning_filter_policy"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_scan_params_t, scanning_filter_policy) - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_scan_params_t::scanning_phys"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_scan_params_t, scanning_phys) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_scan_params_t::array_params"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_scan_params_t, array_params) - 3usize];
};
#[doc = "LE Set Extended Scan Enable command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_ext_scan_enable_t {
    pub enable: u8,
    pub filter_duplicates: u8,
    pub duration: u16,
    pub period: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_ext_scan_enable_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_ext_scan_enable_t>() - 6usize];
    ["Alignment of sdc_hci_cmd_le_set_ext_scan_enable_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_ext_scan_enable_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_scan_enable_t::enable"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_scan_enable_t, enable) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_scan_enable_t::filter_duplicates"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_scan_enable_t, filter_duplicates) - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_scan_enable_t::duration"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_scan_enable_t, duration) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_scan_enable_t::period"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_scan_enable_t, period) - 4usize];
};
#[doc = "LE Extended Create Connection command parameter(s)."]
#[repr(C, packed)]
pub struct sdc_hci_cmd_le_ext_create_conn_t {
    pub initiator_filter_policy: u8,
    pub own_address_type: u8,
    pub peer_address_type: u8,
    pub peer_address: [u8; 6usize],
    pub initiating_phys: u8,
    pub array_params: __IncompleteArrayField<sdc_hci_le_ext_create_conn_array_params_t>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_ext_create_conn_t"][::core::mem::size_of::<sdc_hci_cmd_le_ext_create_conn_t>() - 10usize];
    ["Alignment of sdc_hci_cmd_le_ext_create_conn_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_ext_create_conn_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_ext_create_conn_t::initiator_filter_policy"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_ext_create_conn_t, initiator_filter_policy) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_ext_create_conn_t::own_address_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_ext_create_conn_t, own_address_type) - 1usize];
    ["Offset of field: sdc_hci_cmd_le_ext_create_conn_t::peer_address_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_ext_create_conn_t, peer_address_type) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_ext_create_conn_t::peer_address"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_ext_create_conn_t, peer_address) - 3usize];
    ["Offset of field: sdc_hci_cmd_le_ext_create_conn_t::initiating_phys"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_ext_create_conn_t, initiating_phys) - 9usize];
    ["Offset of field: sdc_hci_cmd_le_ext_create_conn_t::array_params"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_ext_create_conn_t, array_params) - 10usize];
};
#[doc = "LE Periodic Advertising Create Sync command parameter(s)."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sdc_hci_cmd_le_periodic_adv_create_sync_t {
    pub options: sdc_hci_cmd_le_periodic_adv_create_sync_t__bindgen_ty_1,
    pub adv_sid: u8,
    pub adv_address_type: u8,
    pub adv_address: [u8; 6usize],
    pub skip: u16,
    pub sync_timeout: u16,
    pub sync_cte_type: u8,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union sdc_hci_cmd_le_periodic_adv_create_sync_t__bindgen_ty_1 {
    pub params: sdc_hci_le_periodic_adv_create_sync_options_params_t,
    pub raw: [u8; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_periodic_adv_create_sync_t__bindgen_ty_1"]
        [::core::mem::size_of::<sdc_hci_cmd_le_periodic_adv_create_sync_t__bindgen_ty_1>() - 1usize];
    ["Alignment of sdc_hci_cmd_le_periodic_adv_create_sync_t__bindgen_ty_1"]
        [::core::mem::align_of::<sdc_hci_cmd_le_periodic_adv_create_sync_t__bindgen_ty_1>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_periodic_adv_create_sync_t__bindgen_ty_1::params"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_periodic_adv_create_sync_t__bindgen_ty_1, params) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_periodic_adv_create_sync_t__bindgen_ty_1::raw"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_periodic_adv_create_sync_t__bindgen_ty_1, raw) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_periodic_adv_create_sync_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_periodic_adv_create_sync_t>() - 14usize];
    ["Alignment of sdc_hci_cmd_le_periodic_adv_create_sync_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_periodic_adv_create_sync_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_periodic_adv_create_sync_t::options"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_periodic_adv_create_sync_t, options) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_periodic_adv_create_sync_t::adv_sid"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_periodic_adv_create_sync_t, adv_sid) - 1usize];
    ["Offset of field: sdc_hci_cmd_le_periodic_adv_create_sync_t::adv_address_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_periodic_adv_create_sync_t, adv_address_type) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_periodic_adv_create_sync_t::adv_address"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_periodic_adv_create_sync_t, adv_address) - 3usize];
    ["Offset of field: sdc_hci_cmd_le_periodic_adv_create_sync_t::skip"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_periodic_adv_create_sync_t, skip) - 9usize];
    ["Offset of field: sdc_hci_cmd_le_periodic_adv_create_sync_t::sync_timeout"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_periodic_adv_create_sync_t, sync_timeout) - 11usize];
    ["Offset of field: sdc_hci_cmd_le_periodic_adv_create_sync_t::sync_cte_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_periodic_adv_create_sync_t, sync_cte_type) - 13usize];
};
#[doc = "LE Periodic Advertising Terminate Sync command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_periodic_adv_terminate_sync_t {
    pub sync_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_periodic_adv_terminate_sync_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_periodic_adv_terminate_sync_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_periodic_adv_terminate_sync_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_periodic_adv_terminate_sync_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_periodic_adv_terminate_sync_t::sync_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_periodic_adv_terminate_sync_t, sync_handle) - 0usize];
};
#[doc = "LE Add Device To Periodic Advertiser List command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_add_device_to_periodic_adv_list_t {
    pub adv_address_type: u8,
    pub adv_address: [u8; 6usize],
    pub adv_sid: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_add_device_to_periodic_adv_list_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_add_device_to_periodic_adv_list_t>() - 8usize];
    ["Alignment of sdc_hci_cmd_le_add_device_to_periodic_adv_list_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_add_device_to_periodic_adv_list_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_add_device_to_periodic_adv_list_t::adv_address_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_add_device_to_periodic_adv_list_t, adv_address_type) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_add_device_to_periodic_adv_list_t::adv_address"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_add_device_to_periodic_adv_list_t, adv_address) - 1usize];
    ["Offset of field: sdc_hci_cmd_le_add_device_to_periodic_adv_list_t::adv_sid"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_add_device_to_periodic_adv_list_t, adv_sid) - 7usize];
};
#[doc = "LE Remove Device From Periodic Advertiser List command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_remove_device_from_periodic_adv_list_t {
    pub adv_address_type: u8,
    pub adv_address: [u8; 6usize],
    pub adv_sid: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_remove_device_from_periodic_adv_list_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_remove_device_from_periodic_adv_list_t>() - 8usize];
    ["Alignment of sdc_hci_cmd_le_remove_device_from_periodic_adv_list_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_remove_device_from_periodic_adv_list_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_remove_device_from_periodic_adv_list_t::adv_address_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_remove_device_from_periodic_adv_list_t, adv_address_type) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_remove_device_from_periodic_adv_list_t::adv_address"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_remove_device_from_periodic_adv_list_t, adv_address) - 1usize];
    ["Offset of field: sdc_hci_cmd_le_remove_device_from_periodic_adv_list_t::adv_sid"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_remove_device_from_periodic_adv_list_t, adv_sid) - 7usize];
};
#[doc = "LE Read Periodic Advertiser List Size return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_periodic_adv_list_size_return_t {
    pub periodic_adv_list_size: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_read_periodic_adv_list_size_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_read_periodic_adv_list_size_return_t>() - 1usize];
    ["Alignment of sdc_hci_cmd_le_read_periodic_adv_list_size_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_read_periodic_adv_list_size_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_read_periodic_adv_list_size_return_t::periodic_adv_list_size"][::core::mem::offset_of!(
        sdc_hci_cmd_le_read_periodic_adv_list_size_return_t,
        periodic_adv_list_size
    ) - 0usize];
};
#[doc = "LE Read Transmit Power return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_transmit_power_return_t {
    pub min_tx_power: i8,
    pub max_tx_power: i8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_read_transmit_power_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_read_transmit_power_return_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_read_transmit_power_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_read_transmit_power_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_read_transmit_power_return_t::min_tx_power"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_transmit_power_return_t, min_tx_power) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_read_transmit_power_return_t::max_tx_power"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_transmit_power_return_t, max_tx_power) - 1usize];
};
#[doc = "LE Read RF Path Compensation return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_rf_path_compensation_return_t {
    pub rf_tx_path_compensation_value: i16,
    pub rf_rx_path_compensation_value: i16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_read_rf_path_compensation_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_read_rf_path_compensation_return_t>() - 4usize];
    ["Alignment of sdc_hci_cmd_le_read_rf_path_compensation_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_read_rf_path_compensation_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_read_rf_path_compensation_return_t::rf_tx_path_compensation_value"][::core::mem::offset_of!(
        sdc_hci_cmd_le_read_rf_path_compensation_return_t,
        rf_tx_path_compensation_value
    ) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_read_rf_path_compensation_return_t::rf_rx_path_compensation_value"][::core::mem::offset_of!(
        sdc_hci_cmd_le_read_rf_path_compensation_return_t,
        rf_rx_path_compensation_value
    ) - 2usize];
};
#[doc = "LE Write RF Path Compensation command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_write_rf_path_compensation_t {
    pub rf_tx_path_compensation_value: i16,
    pub rf_rx_path_compensation_value: i16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_write_rf_path_compensation_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_write_rf_path_compensation_t>() - 4usize];
    ["Alignment of sdc_hci_cmd_le_write_rf_path_compensation_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_write_rf_path_compensation_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_write_rf_path_compensation_t::rf_tx_path_compensation_value"][::core::mem::offset_of!(
        sdc_hci_cmd_le_write_rf_path_compensation_t,
        rf_tx_path_compensation_value
    ) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_write_rf_path_compensation_t::rf_rx_path_compensation_value"][::core::mem::offset_of!(
        sdc_hci_cmd_le_write_rf_path_compensation_t,
        rf_rx_path_compensation_value
    ) - 2usize];
};
#[doc = "LE Set Privacy Mode command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_privacy_mode_t {
    pub peer_identity_address_type: u8,
    pub peer_identity_address: [u8; 6usize],
    pub privacy_mode: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_privacy_mode_t"][::core::mem::size_of::<sdc_hci_cmd_le_set_privacy_mode_t>() - 8usize];
    ["Alignment of sdc_hci_cmd_le_set_privacy_mode_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_privacy_mode_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_privacy_mode_t::peer_identity_address_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_privacy_mode_t, peer_identity_address_type) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_privacy_mode_t::peer_identity_address"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_privacy_mode_t, peer_identity_address) - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_privacy_mode_t::privacy_mode"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_privacy_mode_t, privacy_mode) - 7usize];
};
#[doc = "LE Set Connectionless CTE Transmit Parameters command parameter(s)."]
#[repr(C, packed)]
pub struct sdc_hci_cmd_le_set_connless_cte_transmit_params_t {
    pub adv_handle: u8,
    pub cte_length: u8,
    pub cte_type: u8,
    pub cte_count: u8,
    pub switching_pattern_length: u8,
    pub array_params: __IncompleteArrayField<sdc_hci_le_set_connless_cte_transmit_params_array_params_t>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_connless_cte_transmit_params_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_connless_cte_transmit_params_t>() - 5usize];
    ["Alignment of sdc_hci_cmd_le_set_connless_cte_transmit_params_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_connless_cte_transmit_params_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_connless_cte_transmit_params_t::adv_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_connless_cte_transmit_params_t, adv_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_connless_cte_transmit_params_t::cte_length"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_connless_cte_transmit_params_t, cte_length) - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_connless_cte_transmit_params_t::cte_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_connless_cte_transmit_params_t, cte_type) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_set_connless_cte_transmit_params_t::cte_count"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_connless_cte_transmit_params_t, cte_count) - 3usize];
    ["Offset of field: sdc_hci_cmd_le_set_connless_cte_transmit_params_t::switching_pattern_length"][::core::mem::offset_of!(
        sdc_hci_cmd_le_set_connless_cte_transmit_params_t,
        switching_pattern_length
    ) - 4usize];
    ["Offset of field: sdc_hci_cmd_le_set_connless_cte_transmit_params_t::array_params"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_connless_cte_transmit_params_t, array_params) - 5usize];
};
#[doc = "LE Set Connectionless CTE Transmit Enable command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_connless_cte_transmit_enable_t {
    pub adv_handle: u8,
    pub cte_enable: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_connless_cte_transmit_enable_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_connless_cte_transmit_enable_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_set_connless_cte_transmit_enable_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_connless_cte_transmit_enable_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_connless_cte_transmit_enable_t::adv_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_connless_cte_transmit_enable_t, adv_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_connless_cte_transmit_enable_t::cte_enable"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_connless_cte_transmit_enable_t, cte_enable) - 1usize];
};
#[doc = "LE Set Connection CTE Transmit Parameters command parameter(s)."]
#[repr(C, packed)]
pub struct sdc_hci_cmd_le_set_conn_cte_transmit_params_t {
    pub conn_handle: u16,
    pub cte_types: u8,
    pub switching_pattern_length: u8,
    pub array_params: __IncompleteArrayField<sdc_hci_le_set_conn_cte_transmit_params_array_params_t>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_conn_cte_transmit_params_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_conn_cte_transmit_params_t>() - 4usize];
    ["Alignment of sdc_hci_cmd_le_set_conn_cte_transmit_params_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_conn_cte_transmit_params_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_conn_cte_transmit_params_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_conn_cte_transmit_params_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_conn_cte_transmit_params_t::cte_types"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_conn_cte_transmit_params_t, cte_types) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_set_conn_cte_transmit_params_t::switching_pattern_length"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_conn_cte_transmit_params_t, switching_pattern_length) - 3usize];
    ["Offset of field: sdc_hci_cmd_le_set_conn_cte_transmit_params_t::array_params"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_conn_cte_transmit_params_t, array_params) - 4usize];
};
#[doc = "LE Set Connection CTE Transmit Parameters return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_conn_cte_transmit_params_return_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_conn_cte_transmit_params_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_conn_cte_transmit_params_return_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_set_conn_cte_transmit_params_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_conn_cte_transmit_params_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_conn_cte_transmit_params_return_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_conn_cte_transmit_params_return_t, conn_handle) - 0usize];
};
#[doc = "LE Connection CTE Response Enable command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_conn_cte_response_enable_t {
    pub conn_handle: u16,
    pub enable: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_conn_cte_response_enable_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_conn_cte_response_enable_t>() - 3usize];
    ["Alignment of sdc_hci_cmd_le_conn_cte_response_enable_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_conn_cte_response_enable_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_conn_cte_response_enable_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_conn_cte_response_enable_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_conn_cte_response_enable_t::enable"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_conn_cte_response_enable_t, enable) - 2usize];
};
#[doc = "LE Connection CTE Response Enable return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_conn_cte_response_enable_return_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_conn_cte_response_enable_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_conn_cte_response_enable_return_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_conn_cte_response_enable_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_conn_cte_response_enable_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_conn_cte_response_enable_return_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_conn_cte_response_enable_return_t, conn_handle) - 0usize];
};
#[doc = "LE Read Antenna Information return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_antenna_information_return_t {
    pub supported_switching_sampling_rates: u8,
    pub num_antennae: u8,
    pub max_switching_pattern_length: u8,
    pub max_cte_length: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_read_antenna_information_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_read_antenna_information_return_t>() - 4usize];
    ["Alignment of sdc_hci_cmd_le_read_antenna_information_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_read_antenna_information_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_read_antenna_information_return_t::supported_switching_sampling_rates"][::core::mem::offset_of!(
        sdc_hci_cmd_le_read_antenna_information_return_t,
        supported_switching_sampling_rates
    )
        - 0usize];
    ["Offset of field: sdc_hci_cmd_le_read_antenna_information_return_t::num_antennae"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_antenna_information_return_t, num_antennae) - 1usize];
    ["Offset of field: sdc_hci_cmd_le_read_antenna_information_return_t::max_switching_pattern_length"][::core::mem::offset_of!(
        sdc_hci_cmd_le_read_antenna_information_return_t,
        max_switching_pattern_length
    ) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_read_antenna_information_return_t::max_cte_length"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_antenna_information_return_t, max_cte_length) - 3usize];
};
#[doc = "LE Set Periodic Advertising Receive Enable command parameter(s)."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sdc_hci_cmd_le_set_periodic_adv_receive_enable_t {
    pub sync_handle: u16,
    pub enable: sdc_hci_cmd_le_set_periodic_adv_receive_enable_t__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union sdc_hci_cmd_le_set_periodic_adv_receive_enable_t__bindgen_ty_1 {
    pub params: sdc_hci_le_set_periodic_adv_receive_enable_params_t,
    pub raw: [u8; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_periodic_adv_receive_enable_t__bindgen_ty_1"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_periodic_adv_receive_enable_t__bindgen_ty_1>() - 1usize];
    ["Alignment of sdc_hci_cmd_le_set_periodic_adv_receive_enable_t__bindgen_ty_1"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_periodic_adv_receive_enable_t__bindgen_ty_1>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_receive_enable_t__bindgen_ty_1::params"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_receive_enable_t__bindgen_ty_1, params) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_receive_enable_t__bindgen_ty_1::raw"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_receive_enable_t__bindgen_ty_1, raw) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_periodic_adv_receive_enable_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_periodic_adv_receive_enable_t>() - 3usize];
    ["Alignment of sdc_hci_cmd_le_set_periodic_adv_receive_enable_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_periodic_adv_receive_enable_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_receive_enable_t::sync_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_receive_enable_t, sync_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_receive_enable_t::enable"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_receive_enable_t, enable) - 2usize];
};
#[doc = "LE Periodic Advertising Sync Transfer command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_periodic_adv_sync_transfer_t {
    pub conn_handle: u16,
    pub service_data: u16,
    pub sync_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_periodic_adv_sync_transfer_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_periodic_adv_sync_transfer_t>() - 6usize];
    ["Alignment of sdc_hci_cmd_le_periodic_adv_sync_transfer_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_periodic_adv_sync_transfer_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_periodic_adv_sync_transfer_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_periodic_adv_sync_transfer_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_periodic_adv_sync_transfer_t::service_data"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_periodic_adv_sync_transfer_t, service_data) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_periodic_adv_sync_transfer_t::sync_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_periodic_adv_sync_transfer_t, sync_handle) - 4usize];
};
#[doc = "LE Periodic Advertising Sync Transfer return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_periodic_adv_sync_transfer_return_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_periodic_adv_sync_transfer_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_periodic_adv_sync_transfer_return_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_periodic_adv_sync_transfer_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_periodic_adv_sync_transfer_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_periodic_adv_sync_transfer_return_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_periodic_adv_sync_transfer_return_t, conn_handle) - 0usize];
};
#[doc = "LE Periodic Advertising Set Info Transfer command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_periodic_adv_set_info_transfer_t {
    pub conn_handle: u16,
    pub service_data: u16,
    pub adv_handle: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_periodic_adv_set_info_transfer_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_periodic_adv_set_info_transfer_t>() - 5usize];
    ["Alignment of sdc_hci_cmd_le_periodic_adv_set_info_transfer_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_periodic_adv_set_info_transfer_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_periodic_adv_set_info_transfer_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_periodic_adv_set_info_transfer_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_periodic_adv_set_info_transfer_t::service_data"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_periodic_adv_set_info_transfer_t, service_data) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_periodic_adv_set_info_transfer_t::adv_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_periodic_adv_set_info_transfer_t, adv_handle) - 4usize];
};
#[doc = "LE Periodic Advertising Set Info Transfer return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_periodic_adv_set_info_transfer_return_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_periodic_adv_set_info_transfer_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_periodic_adv_set_info_transfer_return_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_periodic_adv_set_info_transfer_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_periodic_adv_set_info_transfer_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_periodic_adv_set_info_transfer_return_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_periodic_adv_set_info_transfer_return_t, conn_handle) - 0usize];
};
#[doc = "LE Set Periodic Advertising Sync Transfer Parameters command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_t {
    pub conn_handle: u16,
    pub mode: u8,
    pub skip: u16,
    pub sync_timeout: u16,
    pub cte_type: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_t>() - 8usize];
    ["Alignment of sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_t::mode"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_t, mode) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_t::skip"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_t, skip) - 3usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_t::sync_timeout"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_t, sync_timeout) - 5usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_t::cte_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_t, cte_type) - 7usize];
};
#[doc = "LE Set Periodic Advertising Sync Transfer Parameters return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_return_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_return_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_return_t::conn_handle"][::core::mem::offset_of!(
        sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_return_t,
        conn_handle
    ) - 0usize];
};
#[doc = "LE Set Default Periodic Advertising Sync Transfer Parameters command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_default_periodic_adv_sync_transfer_params_t {
    pub mode: u8,
    pub skip: u16,
    pub sync_timeout: u16,
    pub cte_type: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_default_periodic_adv_sync_transfer_params_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_default_periodic_adv_sync_transfer_params_t>() - 6usize];
    ["Alignment of sdc_hci_cmd_le_set_default_periodic_adv_sync_transfer_params_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_default_periodic_adv_sync_transfer_params_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_default_periodic_adv_sync_transfer_params_t::mode"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_default_periodic_adv_sync_transfer_params_t, mode) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_default_periodic_adv_sync_transfer_params_t::skip"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_default_periodic_adv_sync_transfer_params_t, skip) - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_default_periodic_adv_sync_transfer_params_t::sync_timeout"][::core::mem::offset_of!(
        sdc_hci_cmd_le_set_default_periodic_adv_sync_transfer_params_t,
        sync_timeout
    ) - 3usize];
    ["Offset of field: sdc_hci_cmd_le_set_default_periodic_adv_sync_transfer_params_t::cte_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_default_periodic_adv_sync_transfer_params_t, cte_type) - 5usize];
};
#[doc = "LE Read Buffer Size return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_buffer_size_v2_return_t {
    pub le_acl_data_packet_length: u16,
    pub total_num_le_acl_data_packets: u8,
    pub iso_data_packet_length: u16,
    pub total_num_iso_data_packets: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_read_buffer_size_v2_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_read_buffer_size_v2_return_t>() - 6usize];
    ["Alignment of sdc_hci_cmd_le_read_buffer_size_v2_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_read_buffer_size_v2_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_read_buffer_size_v2_return_t::le_acl_data_packet_length"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_buffer_size_v2_return_t, le_acl_data_packet_length) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_read_buffer_size_v2_return_t::total_num_le_acl_data_packets"][::core::mem::offset_of!(
        sdc_hci_cmd_le_read_buffer_size_v2_return_t,
        total_num_le_acl_data_packets
    ) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_read_buffer_size_v2_return_t::iso_data_packet_length"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_buffer_size_v2_return_t, iso_data_packet_length) - 3usize];
    ["Offset of field: sdc_hci_cmd_le_read_buffer_size_v2_return_t::total_num_iso_data_packets"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_buffer_size_v2_return_t, total_num_iso_data_packets) - 5usize];
};
#[doc = "LE Read ISO TX Sync command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_iso_tx_sync_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_read_iso_tx_sync_t"][::core::mem::size_of::<sdc_hci_cmd_le_read_iso_tx_sync_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_read_iso_tx_sync_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_read_iso_tx_sync_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_read_iso_tx_sync_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_iso_tx_sync_t, conn_handle) - 0usize];
};
#[doc = "LE Read ISO TX Sync return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_iso_tx_sync_return_t {
    pub conn_handle: u16,
    pub packet_sequence_number: u16,
    pub tx_time_stamp: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_read_iso_tx_sync_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_read_iso_tx_sync_return_t>() - 11usize];
    ["Alignment of sdc_hci_cmd_le_read_iso_tx_sync_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_read_iso_tx_sync_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_read_iso_tx_sync_return_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_iso_tx_sync_return_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_read_iso_tx_sync_return_t::packet_sequence_number"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_iso_tx_sync_return_t, packet_sequence_number) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_read_iso_tx_sync_return_t::tx_time_stamp"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_iso_tx_sync_return_t, tx_time_stamp) - 4usize];
};
impl sdc_hci_cmd_le_read_iso_tx_sync_return_t {
    #[inline]
    pub fn time_offset(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_time_offset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn time_offset_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_time_offset_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(time_offset: u32) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let time_offset: u32 = unsafe { ::core::mem::transmute(time_offset) };
            time_offset as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "LE Set CIG Parameters command parameter(s)."]
#[repr(C, packed)]
pub struct sdc_hci_cmd_le_set_cig_params_t {
    pub cig_id: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 6usize]>,
    pub worst_case_sca: u8,
    pub packing: u8,
    pub framing: u8,
    pub max_transport_latency_c_to_p: u16,
    pub max_transport_latency_p_to_c: u16,
    pub cis_count: u8,
    pub array_params: __IncompleteArrayField<sdc_hci_le_set_cig_params_array_params_t>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_cig_params_t"][::core::mem::size_of::<sdc_hci_cmd_le_set_cig_params_t>() - 15usize];
    ["Alignment of sdc_hci_cmd_le_set_cig_params_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_cig_params_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_cig_params_t::cig_id"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_cig_params_t, cig_id) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_cig_params_t::worst_case_sca"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_cig_params_t, worst_case_sca) - 7usize];
    ["Offset of field: sdc_hci_cmd_le_set_cig_params_t::packing"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_cig_params_t, packing) - 8usize];
    ["Offset of field: sdc_hci_cmd_le_set_cig_params_t::framing"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_cig_params_t, framing) - 9usize];
    ["Offset of field: sdc_hci_cmd_le_set_cig_params_t::max_transport_latency_c_to_p"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_cig_params_t, max_transport_latency_c_to_p) - 10usize];
    ["Offset of field: sdc_hci_cmd_le_set_cig_params_t::max_transport_latency_p_to_c"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_cig_params_t, max_transport_latency_p_to_c) - 12usize];
    ["Offset of field: sdc_hci_cmd_le_set_cig_params_t::cis_count"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_cig_params_t, cis_count) - 14usize];
    ["Offset of field: sdc_hci_cmd_le_set_cig_params_t::array_params"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_cig_params_t, array_params) - 15usize];
};
impl sdc_hci_cmd_le_set_cig_params_t {
    #[inline]
    pub fn sdu_interval_c_to_p(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_sdu_interval_c_to_p(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sdu_interval_c_to_p_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sdu_interval_c_to_p_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sdu_interval_p_to_c(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_sdu_interval_p_to_c(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sdu_interval_p_to_c_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sdu_interval_p_to_c_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(sdu_interval_c_to_p: u32, sdu_interval_p_to_c: u32) -> __BindgenBitfieldUnit<[u8; 6usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 6usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let sdu_interval_c_to_p: u32 = unsafe { ::core::mem::transmute(sdu_interval_c_to_p) };
            sdu_interval_c_to_p as u64
        });
        __bindgen_bitfield_unit.set(24usize, 24u8, {
            let sdu_interval_p_to_c: u32 = unsafe { ::core::mem::transmute(sdu_interval_p_to_c) };
            sdu_interval_p_to_c as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "LE Set CIG Parameters return parameter(s)."]
#[repr(C, packed)]
pub struct sdc_hci_cmd_le_set_cig_params_return_t {
    pub cig_id: u8,
    pub cis_count: u8,
    pub array_params: __IncompleteArrayField<sdc_hci_le_set_cig_params_output_array_params_t>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_cig_params_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_cig_params_return_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_set_cig_params_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_cig_params_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_cig_params_return_t::cig_id"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_cig_params_return_t, cig_id) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_cig_params_return_t::cis_count"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_cig_params_return_t, cis_count) - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_cig_params_return_t::array_params"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_cig_params_return_t, array_params) - 2usize];
};
#[doc = "LE Set CIG Parameters Test command parameter(s)."]
#[repr(C, packed)]
pub struct sdc_hci_cmd_le_set_cig_params_test_t {
    pub cig_id: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 6usize]>,
    pub ft_c_to_p: u8,
    pub ft_p_to_c: u8,
    pub iso_interval: u16,
    pub worst_case_sca: u8,
    pub packing: u8,
    pub framing: u8,
    pub cis_count: u8,
    pub array_params: __IncompleteArrayField<sdc_hci_le_set_cig_params_test_array_params_t>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_cig_params_test_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_cig_params_test_t>() - 15usize];
    ["Alignment of sdc_hci_cmd_le_set_cig_params_test_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_cig_params_test_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_cig_params_test_t::cig_id"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_cig_params_test_t, cig_id) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_cig_params_test_t::ft_c_to_p"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_cig_params_test_t, ft_c_to_p) - 7usize];
    ["Offset of field: sdc_hci_cmd_le_set_cig_params_test_t::ft_p_to_c"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_cig_params_test_t, ft_p_to_c) - 8usize];
    ["Offset of field: sdc_hci_cmd_le_set_cig_params_test_t::iso_interval"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_cig_params_test_t, iso_interval) - 9usize];
    ["Offset of field: sdc_hci_cmd_le_set_cig_params_test_t::worst_case_sca"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_cig_params_test_t, worst_case_sca) - 11usize];
    ["Offset of field: sdc_hci_cmd_le_set_cig_params_test_t::packing"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_cig_params_test_t, packing) - 12usize];
    ["Offset of field: sdc_hci_cmd_le_set_cig_params_test_t::framing"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_cig_params_test_t, framing) - 13usize];
    ["Offset of field: sdc_hci_cmd_le_set_cig_params_test_t::cis_count"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_cig_params_test_t, cis_count) - 14usize];
    ["Offset of field: sdc_hci_cmd_le_set_cig_params_test_t::array_params"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_cig_params_test_t, array_params) - 15usize];
};
impl sdc_hci_cmd_le_set_cig_params_test_t {
    #[inline]
    pub fn sdu_interval_c_to_p(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_sdu_interval_c_to_p(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sdu_interval_c_to_p_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sdu_interval_c_to_p_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sdu_interval_p_to_c(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_sdu_interval_p_to_c(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sdu_interval_p_to_c_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sdu_interval_p_to_c_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(sdu_interval_c_to_p: u32, sdu_interval_p_to_c: u32) -> __BindgenBitfieldUnit<[u8; 6usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 6usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let sdu_interval_c_to_p: u32 = unsafe { ::core::mem::transmute(sdu_interval_c_to_p) };
            sdu_interval_c_to_p as u64
        });
        __bindgen_bitfield_unit.set(24usize, 24u8, {
            let sdu_interval_p_to_c: u32 = unsafe { ::core::mem::transmute(sdu_interval_p_to_c) };
            sdu_interval_p_to_c as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "LE Set CIG Parameters Test return parameter(s)."]
#[repr(C, packed)]
pub struct sdc_hci_cmd_le_set_cig_params_test_return_t {
    pub cig_id: u8,
    pub cis_count: u8,
    pub array_params: __IncompleteArrayField<sdc_hci_le_set_cig_params_test_output_array_params_t>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_cig_params_test_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_cig_params_test_return_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_set_cig_params_test_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_cig_params_test_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_cig_params_test_return_t::cig_id"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_cig_params_test_return_t, cig_id) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_cig_params_test_return_t::cis_count"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_cig_params_test_return_t, cis_count) - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_cig_params_test_return_t::array_params"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_cig_params_test_return_t, array_params) - 2usize];
};
#[doc = "LE Create CIS command parameter(s)."]
#[repr(C, packed)]
pub struct sdc_hci_cmd_le_create_cis_t {
    pub cis_count: u8,
    pub array_params: __IncompleteArrayField<sdc_hci_le_create_cis_array_params_t>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_create_cis_t"][::core::mem::size_of::<sdc_hci_cmd_le_create_cis_t>() - 1usize];
    ["Alignment of sdc_hci_cmd_le_create_cis_t"][::core::mem::align_of::<sdc_hci_cmd_le_create_cis_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_create_cis_t::cis_count"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_cis_t, cis_count) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_create_cis_t::array_params"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_cis_t, array_params) - 1usize];
};
#[doc = "LE Remove CIG command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_remove_cig_t {
    pub cig_id: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_remove_cig_t"][::core::mem::size_of::<sdc_hci_cmd_le_remove_cig_t>() - 1usize];
    ["Alignment of sdc_hci_cmd_le_remove_cig_t"][::core::mem::align_of::<sdc_hci_cmd_le_remove_cig_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_remove_cig_t::cig_id"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_remove_cig_t, cig_id) - 0usize];
};
#[doc = "LE Remove CIG return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_remove_cig_return_t {
    pub cig_id: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_remove_cig_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_remove_cig_return_t>() - 1usize];
    ["Alignment of sdc_hci_cmd_le_remove_cig_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_remove_cig_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_remove_cig_return_t::cig_id"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_remove_cig_return_t, cig_id) - 0usize];
};
#[doc = "LE Accept CIS Request command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_accept_cis_request_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_accept_cis_request_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_accept_cis_request_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_accept_cis_request_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_accept_cis_request_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_accept_cis_request_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_accept_cis_request_t, conn_handle) - 0usize];
};
#[doc = "LE Reject CIS Request command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_reject_cis_request_t {
    pub conn_handle: u16,
    pub reason: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_reject_cis_request_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_reject_cis_request_t>() - 3usize];
    ["Alignment of sdc_hci_cmd_le_reject_cis_request_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_reject_cis_request_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_reject_cis_request_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_reject_cis_request_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_reject_cis_request_t::reason"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_reject_cis_request_t, reason) - 2usize];
};
#[doc = "LE Reject CIS Request return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_reject_cis_request_return_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_reject_cis_request_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_reject_cis_request_return_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_reject_cis_request_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_reject_cis_request_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_reject_cis_request_return_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_reject_cis_request_return_t, conn_handle) - 0usize];
};
#[doc = "LE Create BIG command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_create_big_t {
    pub big_handle: u8,
    pub adv_handle: u8,
    pub num_bis: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub max_sdu: u16,
    pub max_transport_latency: u16,
    pub rtn: u8,
    pub phy: u8,
    pub packing: u8,
    pub framing: u8,
    pub encryption: u8,
    pub broadcast_code: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_create_big_t"][::core::mem::size_of::<sdc_hci_cmd_le_create_big_t>() - 31usize];
    ["Alignment of sdc_hci_cmd_le_create_big_t"][::core::mem::align_of::<sdc_hci_cmd_le_create_big_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_create_big_t::big_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_big_t, big_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_create_big_t::adv_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_big_t, adv_handle) - 1usize];
    ["Offset of field: sdc_hci_cmd_le_create_big_t::num_bis"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_big_t, num_bis) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_create_big_t::max_sdu"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_big_t, max_sdu) - 6usize];
    ["Offset of field: sdc_hci_cmd_le_create_big_t::max_transport_latency"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_big_t, max_transport_latency) - 8usize];
    ["Offset of field: sdc_hci_cmd_le_create_big_t::rtn"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_big_t, rtn) - 10usize];
    ["Offset of field: sdc_hci_cmd_le_create_big_t::phy"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_big_t, phy) - 11usize];
    ["Offset of field: sdc_hci_cmd_le_create_big_t::packing"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_big_t, packing) - 12usize];
    ["Offset of field: sdc_hci_cmd_le_create_big_t::framing"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_big_t, framing) - 13usize];
    ["Offset of field: sdc_hci_cmd_le_create_big_t::encryption"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_big_t, encryption) - 14usize];
    ["Offset of field: sdc_hci_cmd_le_create_big_t::broadcast_code"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_big_t, broadcast_code) - 15usize];
};
impl sdc_hci_cmd_le_create_big_t {
    #[inline]
    pub fn sdu_interval(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_sdu_interval(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sdu_interval_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sdu_interval_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(sdu_interval: u32) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let sdu_interval: u32 = unsafe { ::core::mem::transmute(sdu_interval) };
            sdu_interval as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "LE Create BIG Test command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_create_big_test_t {
    pub big_handle: u8,
    pub adv_handle: u8,
    pub num_bis: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub iso_interval: u16,
    pub nse: u8,
    pub max_sdu: u16,
    pub max_pdu: u16,
    pub phy: u8,
    pub packing: u8,
    pub framing: u8,
    pub bn: u8,
    pub irc: u8,
    pub pto: u8,
    pub encryption: u8,
    pub broadcast_code: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_create_big_test_t"][::core::mem::size_of::<sdc_hci_cmd_le_create_big_test_t>() - 36usize];
    ["Alignment of sdc_hci_cmd_le_create_big_test_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_create_big_test_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_create_big_test_t::big_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_big_test_t, big_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_create_big_test_t::adv_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_big_test_t, adv_handle) - 1usize];
    ["Offset of field: sdc_hci_cmd_le_create_big_test_t::num_bis"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_big_test_t, num_bis) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_create_big_test_t::iso_interval"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_big_test_t, iso_interval) - 6usize];
    ["Offset of field: sdc_hci_cmd_le_create_big_test_t::nse"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_big_test_t, nse) - 8usize];
    ["Offset of field: sdc_hci_cmd_le_create_big_test_t::max_sdu"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_big_test_t, max_sdu) - 9usize];
    ["Offset of field: sdc_hci_cmd_le_create_big_test_t::max_pdu"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_big_test_t, max_pdu) - 11usize];
    ["Offset of field: sdc_hci_cmd_le_create_big_test_t::phy"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_big_test_t, phy) - 13usize];
    ["Offset of field: sdc_hci_cmd_le_create_big_test_t::packing"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_big_test_t, packing) - 14usize];
    ["Offset of field: sdc_hci_cmd_le_create_big_test_t::framing"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_big_test_t, framing) - 15usize];
    ["Offset of field: sdc_hci_cmd_le_create_big_test_t::bn"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_big_test_t, bn) - 16usize];
    ["Offset of field: sdc_hci_cmd_le_create_big_test_t::irc"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_big_test_t, irc) - 17usize];
    ["Offset of field: sdc_hci_cmd_le_create_big_test_t::pto"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_big_test_t, pto) - 18usize];
    ["Offset of field: sdc_hci_cmd_le_create_big_test_t::encryption"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_big_test_t, encryption) - 19usize];
    ["Offset of field: sdc_hci_cmd_le_create_big_test_t::broadcast_code"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_create_big_test_t, broadcast_code) - 20usize];
};
impl sdc_hci_cmd_le_create_big_test_t {
    #[inline]
    pub fn sdu_interval(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_sdu_interval(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sdu_interval_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sdu_interval_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(sdu_interval: u32) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let sdu_interval: u32 = unsafe { ::core::mem::transmute(sdu_interval) };
            sdu_interval as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "LE Terminate BIG command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_terminate_big_t {
    pub big_handle: u8,
    pub reason: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_terminate_big_t"][::core::mem::size_of::<sdc_hci_cmd_le_terminate_big_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_terminate_big_t"][::core::mem::align_of::<sdc_hci_cmd_le_terminate_big_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_terminate_big_t::big_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_terminate_big_t, big_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_terminate_big_t::reason"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_terminate_big_t, reason) - 1usize];
};
#[doc = "LE BIG Create Sync command parameter(s)."]
#[repr(C, packed)]
pub struct sdc_hci_cmd_le_big_create_sync_t {
    pub big_handle: u8,
    pub sync_handle: u16,
    pub encryption: u8,
    pub broadcast_code: [u8; 16usize],
    pub mse: u8,
    pub big_sync_timeout: u16,
    pub num_bis: u8,
    pub array_params: __IncompleteArrayField<sdc_hci_le_big_create_sync_array_params_t>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_big_create_sync_t"][::core::mem::size_of::<sdc_hci_cmd_le_big_create_sync_t>() - 24usize];
    ["Alignment of sdc_hci_cmd_le_big_create_sync_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_big_create_sync_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_big_create_sync_t::big_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_big_create_sync_t, big_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_big_create_sync_t::sync_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_big_create_sync_t, sync_handle) - 1usize];
    ["Offset of field: sdc_hci_cmd_le_big_create_sync_t::encryption"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_big_create_sync_t, encryption) - 3usize];
    ["Offset of field: sdc_hci_cmd_le_big_create_sync_t::broadcast_code"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_big_create_sync_t, broadcast_code) - 4usize];
    ["Offset of field: sdc_hci_cmd_le_big_create_sync_t::mse"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_big_create_sync_t, mse) - 20usize];
    ["Offset of field: sdc_hci_cmd_le_big_create_sync_t::big_sync_timeout"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_big_create_sync_t, big_sync_timeout) - 21usize];
    ["Offset of field: sdc_hci_cmd_le_big_create_sync_t::num_bis"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_big_create_sync_t, num_bis) - 23usize];
    ["Offset of field: sdc_hci_cmd_le_big_create_sync_t::array_params"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_big_create_sync_t, array_params) - 24usize];
};
#[doc = "LE BIG Terminate Sync command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_big_terminate_sync_t {
    pub big_handle: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_big_terminate_sync_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_big_terminate_sync_t>() - 1usize];
    ["Alignment of sdc_hci_cmd_le_big_terminate_sync_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_big_terminate_sync_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_big_terminate_sync_t::big_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_big_terminate_sync_t, big_handle) - 0usize];
};
#[doc = "LE BIG Terminate Sync return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_big_terminate_sync_return_t {
    pub big_handle: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_big_terminate_sync_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_big_terminate_sync_return_t>() - 1usize];
    ["Alignment of sdc_hci_cmd_le_big_terminate_sync_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_big_terminate_sync_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_big_terminate_sync_return_t::big_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_big_terminate_sync_return_t, big_handle) - 0usize];
};
#[doc = "LE Request Peer SCA command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_request_peer_sca_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_request_peer_sca_t"][::core::mem::size_of::<sdc_hci_cmd_le_request_peer_sca_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_request_peer_sca_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_request_peer_sca_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_request_peer_sca_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_request_peer_sca_t, conn_handle) - 0usize];
};
#[doc = "LE Setup ISO Data Path command parameter(s)."]
#[repr(C, packed)]
pub struct sdc_hci_cmd_le_setup_iso_data_path_t {
    pub conn_handle: u16,
    pub data_path_direction: u8,
    pub data_path_id: u8,
    pub codec_id: [u8; 5usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub codec_config_length: u8,
    pub codec_config: __IncompleteArrayField<u8>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_setup_iso_data_path_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_setup_iso_data_path_t>() - 13usize];
    ["Alignment of sdc_hci_cmd_le_setup_iso_data_path_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_setup_iso_data_path_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_setup_iso_data_path_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_setup_iso_data_path_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_setup_iso_data_path_t::data_path_direction"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_setup_iso_data_path_t, data_path_direction) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_setup_iso_data_path_t::data_path_id"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_setup_iso_data_path_t, data_path_id) - 3usize];
    ["Offset of field: sdc_hci_cmd_le_setup_iso_data_path_t::codec_id"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_setup_iso_data_path_t, codec_id) - 4usize];
    ["Offset of field: sdc_hci_cmd_le_setup_iso_data_path_t::codec_config_length"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_setup_iso_data_path_t, codec_config_length) - 12usize];
    ["Offset of field: sdc_hci_cmd_le_setup_iso_data_path_t::codec_config"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_setup_iso_data_path_t, codec_config) - 13usize];
};
impl sdc_hci_cmd_le_setup_iso_data_path_t {
    #[inline]
    pub fn controller_delay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_controller_delay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn controller_delay_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_controller_delay_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(controller_delay: u32) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let controller_delay: u32 = unsafe { ::core::mem::transmute(controller_delay) };
            controller_delay as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "LE Setup ISO Data Path return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_setup_iso_data_path_return_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_setup_iso_data_path_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_setup_iso_data_path_return_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_setup_iso_data_path_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_setup_iso_data_path_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_setup_iso_data_path_return_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_setup_iso_data_path_return_t, conn_handle) - 0usize];
};
#[doc = "LE Remove ISO Data Path command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_remove_iso_data_path_t {
    pub conn_handle: u16,
    pub data_path_direction: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_remove_iso_data_path_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_remove_iso_data_path_t>() - 3usize];
    ["Alignment of sdc_hci_cmd_le_remove_iso_data_path_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_remove_iso_data_path_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_remove_iso_data_path_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_remove_iso_data_path_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_remove_iso_data_path_t::data_path_direction"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_remove_iso_data_path_t, data_path_direction) - 2usize];
};
#[doc = "LE Remove ISO Data Path return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_remove_iso_data_path_return_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_remove_iso_data_path_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_remove_iso_data_path_return_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_remove_iso_data_path_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_remove_iso_data_path_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_remove_iso_data_path_return_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_remove_iso_data_path_return_t, conn_handle) - 0usize];
};
#[doc = "LE ISO Transmit Test command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_iso_transmit_test_t {
    pub conn_handle: u16,
    pub payload_type: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_iso_transmit_test_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_iso_transmit_test_t>() - 3usize];
    ["Alignment of sdc_hci_cmd_le_iso_transmit_test_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_iso_transmit_test_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_iso_transmit_test_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_iso_transmit_test_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_iso_transmit_test_t::payload_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_iso_transmit_test_t, payload_type) - 2usize];
};
#[doc = "LE ISO Transmit Test return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_iso_transmit_test_return_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_iso_transmit_test_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_iso_transmit_test_return_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_iso_transmit_test_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_iso_transmit_test_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_iso_transmit_test_return_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_iso_transmit_test_return_t, conn_handle) - 0usize];
};
#[doc = "LE ISO Receive Test command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_iso_receive_test_t {
    pub conn_handle: u16,
    pub payload_type: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_iso_receive_test_t"][::core::mem::size_of::<sdc_hci_cmd_le_iso_receive_test_t>() - 3usize];
    ["Alignment of sdc_hci_cmd_le_iso_receive_test_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_iso_receive_test_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_iso_receive_test_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_iso_receive_test_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_iso_receive_test_t::payload_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_iso_receive_test_t, payload_type) - 2usize];
};
#[doc = "LE ISO Receive Test return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_iso_receive_test_return_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_iso_receive_test_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_iso_receive_test_return_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_iso_receive_test_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_iso_receive_test_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_iso_receive_test_return_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_iso_receive_test_return_t, conn_handle) - 0usize];
};
#[doc = "LE ISO Read Test Counters command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_iso_read_test_counters_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_iso_read_test_counters_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_iso_read_test_counters_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_iso_read_test_counters_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_iso_read_test_counters_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_iso_read_test_counters_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_iso_read_test_counters_t, conn_handle) - 0usize];
};
#[doc = "LE ISO Read Test Counters return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_iso_read_test_counters_return_t {
    pub conn_handle: u16,
    pub received_sdu_count: u32,
    pub missed_sdu_count: u32,
    pub failed_sdu_count: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_iso_read_test_counters_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_iso_read_test_counters_return_t>() - 14usize];
    ["Alignment of sdc_hci_cmd_le_iso_read_test_counters_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_iso_read_test_counters_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_iso_read_test_counters_return_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_iso_read_test_counters_return_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_iso_read_test_counters_return_t::received_sdu_count"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_iso_read_test_counters_return_t, received_sdu_count) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_iso_read_test_counters_return_t::missed_sdu_count"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_iso_read_test_counters_return_t, missed_sdu_count) - 6usize];
    ["Offset of field: sdc_hci_cmd_le_iso_read_test_counters_return_t::failed_sdu_count"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_iso_read_test_counters_return_t, failed_sdu_count) - 10usize];
};
#[doc = "LE ISO Test End command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_iso_test_end_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_iso_test_end_t"][::core::mem::size_of::<sdc_hci_cmd_le_iso_test_end_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_iso_test_end_t"][::core::mem::align_of::<sdc_hci_cmd_le_iso_test_end_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_iso_test_end_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_iso_test_end_t, conn_handle) - 0usize];
};
#[doc = "LE ISO Test End return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_iso_test_end_return_t {
    pub conn_handle: u16,
    pub received_sdu_count: u32,
    pub missed_sdu_count: u32,
    pub failed_sdu_count: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_iso_test_end_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_iso_test_end_return_t>() - 14usize];
    ["Alignment of sdc_hci_cmd_le_iso_test_end_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_iso_test_end_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_iso_test_end_return_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_iso_test_end_return_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_iso_test_end_return_t::received_sdu_count"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_iso_test_end_return_t, received_sdu_count) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_iso_test_end_return_t::missed_sdu_count"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_iso_test_end_return_t, missed_sdu_count) - 6usize];
    ["Offset of field: sdc_hci_cmd_le_iso_test_end_return_t::failed_sdu_count"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_iso_test_end_return_t, failed_sdu_count) - 10usize];
};
#[doc = "LE Set Host Feature command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_host_feature_t {
    pub bit_number: u8,
    pub bit_value: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_host_feature_t"][::core::mem::size_of::<sdc_hci_cmd_le_set_host_feature_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_set_host_feature_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_host_feature_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_host_feature_t::bit_number"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_host_feature_t, bit_number) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_host_feature_t::bit_value"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_host_feature_t, bit_value) - 1usize];
};
#[doc = "LE Read ISO Link Quality command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_iso_link_quality_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_read_iso_link_quality_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_read_iso_link_quality_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_read_iso_link_quality_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_read_iso_link_quality_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_read_iso_link_quality_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_iso_link_quality_t, conn_handle) - 0usize];
};
#[doc = "LE Read ISO Link Quality return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_iso_link_quality_return_t {
    pub conn_handle: u16,
    pub tx_unacked_packets: u32,
    pub tx_flushed_packets: u32,
    pub tx_last_subevent_packets: u32,
    pub retransmitted_packets: u32,
    pub crc_error_packets: u32,
    pub rx_unreceived_packets: u32,
    pub duplicate_packets: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_read_iso_link_quality_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_read_iso_link_quality_return_t>() - 30usize];
    ["Alignment of sdc_hci_cmd_le_read_iso_link_quality_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_read_iso_link_quality_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_read_iso_link_quality_return_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_iso_link_quality_return_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_read_iso_link_quality_return_t::tx_unacked_packets"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_iso_link_quality_return_t, tx_unacked_packets) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_read_iso_link_quality_return_t::tx_flushed_packets"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_iso_link_quality_return_t, tx_flushed_packets) - 6usize];
    ["Offset of field: sdc_hci_cmd_le_read_iso_link_quality_return_t::tx_last_subevent_packets"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_iso_link_quality_return_t, tx_last_subevent_packets) - 10usize];
    ["Offset of field: sdc_hci_cmd_le_read_iso_link_quality_return_t::retransmitted_packets"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_iso_link_quality_return_t, retransmitted_packets) - 14usize];
    ["Offset of field: sdc_hci_cmd_le_read_iso_link_quality_return_t::crc_error_packets"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_iso_link_quality_return_t, crc_error_packets) - 18usize];
    ["Offset of field: sdc_hci_cmd_le_read_iso_link_quality_return_t::rx_unreceived_packets"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_iso_link_quality_return_t, rx_unreceived_packets) - 22usize];
    ["Offset of field: sdc_hci_cmd_le_read_iso_link_quality_return_t::duplicate_packets"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_iso_link_quality_return_t, duplicate_packets) - 26usize];
};
#[doc = "LE Enhanced Read Transmit Power Level command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_enhanced_read_transmit_power_level_t {
    pub conn_handle: u16,
    pub phy: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_enhanced_read_transmit_power_level_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_enhanced_read_transmit_power_level_t>() - 3usize];
    ["Alignment of sdc_hci_cmd_le_enhanced_read_transmit_power_level_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_enhanced_read_transmit_power_level_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_enhanced_read_transmit_power_level_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_enhanced_read_transmit_power_level_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_enhanced_read_transmit_power_level_t::phy"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_enhanced_read_transmit_power_level_t, phy) - 2usize];
};
#[doc = "LE Enhanced Read Transmit Power Level return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_enhanced_read_transmit_power_level_return_t {
    pub conn_handle: u16,
    pub phy: u8,
    pub current_tx_power_level: i8,
    pub max_tx_power_level: i8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_enhanced_read_transmit_power_level_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_enhanced_read_transmit_power_level_return_t>() - 5usize];
    ["Alignment of sdc_hci_cmd_le_enhanced_read_transmit_power_level_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_enhanced_read_transmit_power_level_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_enhanced_read_transmit_power_level_return_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_enhanced_read_transmit_power_level_return_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_enhanced_read_transmit_power_level_return_t::phy"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_enhanced_read_transmit_power_level_return_t, phy) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_enhanced_read_transmit_power_level_return_t::current_tx_power_level"][::core::mem::offset_of!(
        sdc_hci_cmd_le_enhanced_read_transmit_power_level_return_t,
        current_tx_power_level
    ) - 3usize];
    ["Offset of field: sdc_hci_cmd_le_enhanced_read_transmit_power_level_return_t::max_tx_power_level"][::core::mem::offset_of!(
        sdc_hci_cmd_le_enhanced_read_transmit_power_level_return_t,
        max_tx_power_level
    ) - 4usize];
};
#[doc = "LE Read Remote Transmit Power Level command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_remote_transmit_power_level_t {
    pub conn_handle: u16,
    pub phy: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_read_remote_transmit_power_level_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_read_remote_transmit_power_level_t>() - 3usize];
    ["Alignment of sdc_hci_cmd_le_read_remote_transmit_power_level_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_read_remote_transmit_power_level_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_read_remote_transmit_power_level_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_remote_transmit_power_level_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_read_remote_transmit_power_level_t::phy"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_read_remote_transmit_power_level_t, phy) - 2usize];
};
#[doc = "LE Set Path Loss Reporting Parameters command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_path_loss_reporting_params_t {
    pub conn_handle: u16,
    pub high_threshold: u8,
    pub high_hysteresis: u8,
    pub low_threshold: u8,
    pub low_hysteresis: u8,
    pub min_time_spent: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_path_loss_reporting_params_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_path_loss_reporting_params_t>() - 8usize];
    ["Alignment of sdc_hci_cmd_le_set_path_loss_reporting_params_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_path_loss_reporting_params_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_path_loss_reporting_params_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_path_loss_reporting_params_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_path_loss_reporting_params_t::high_threshold"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_path_loss_reporting_params_t, high_threshold) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_set_path_loss_reporting_params_t::high_hysteresis"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_path_loss_reporting_params_t, high_hysteresis) - 3usize];
    ["Offset of field: sdc_hci_cmd_le_set_path_loss_reporting_params_t::low_threshold"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_path_loss_reporting_params_t, low_threshold) - 4usize];
    ["Offset of field: sdc_hci_cmd_le_set_path_loss_reporting_params_t::low_hysteresis"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_path_loss_reporting_params_t, low_hysteresis) - 5usize];
    ["Offset of field: sdc_hci_cmd_le_set_path_loss_reporting_params_t::min_time_spent"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_path_loss_reporting_params_t, min_time_spent) - 6usize];
};
#[doc = "LE Set Path Loss Reporting Parameters return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_path_loss_reporting_params_return_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_path_loss_reporting_params_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_path_loss_reporting_params_return_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_set_path_loss_reporting_params_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_path_loss_reporting_params_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_path_loss_reporting_params_return_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_path_loss_reporting_params_return_t, conn_handle) - 0usize];
};
#[doc = "LE Set Path Loss Reporting Enable command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_path_loss_reporting_enable_t {
    pub conn_handle: u16,
    pub enable: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_path_loss_reporting_enable_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_path_loss_reporting_enable_t>() - 3usize];
    ["Alignment of sdc_hci_cmd_le_set_path_loss_reporting_enable_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_path_loss_reporting_enable_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_path_loss_reporting_enable_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_path_loss_reporting_enable_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_path_loss_reporting_enable_t::enable"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_path_loss_reporting_enable_t, enable) - 2usize];
};
#[doc = "LE Set Path Loss Reporting Enable return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_path_loss_reporting_enable_return_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_path_loss_reporting_enable_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_path_loss_reporting_enable_return_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_set_path_loss_reporting_enable_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_path_loss_reporting_enable_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_path_loss_reporting_enable_return_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_path_loss_reporting_enable_return_t, conn_handle) - 0usize];
};
#[doc = "LE Set Transmit Power Reporting Enable command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_transmit_power_reporting_enable_t {
    pub conn_handle: u16,
    pub local_enable: u8,
    pub remote_enable: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_transmit_power_reporting_enable_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_transmit_power_reporting_enable_t>() - 4usize];
    ["Alignment of sdc_hci_cmd_le_set_transmit_power_reporting_enable_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_transmit_power_reporting_enable_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_transmit_power_reporting_enable_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_transmit_power_reporting_enable_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_transmit_power_reporting_enable_t::local_enable"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_transmit_power_reporting_enable_t, local_enable) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_set_transmit_power_reporting_enable_t::remote_enable"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_transmit_power_reporting_enable_t, remote_enable) - 3usize];
};
#[doc = "LE Set Transmit Power Reporting Enable return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_transmit_power_reporting_enable_return_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_transmit_power_reporting_enable_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_transmit_power_reporting_enable_return_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_set_transmit_power_reporting_enable_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_transmit_power_reporting_enable_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_transmit_power_reporting_enable_return_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_transmit_power_reporting_enable_return_t, conn_handle) - 0usize];
};
#[doc = "LE Set Data Related Address Changes command parameter(s)."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sdc_hci_cmd_le_set_data_related_address_changes_t {
    pub adv_handle: u8,
    pub change_reasons: sdc_hci_cmd_le_set_data_related_address_changes_t__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union sdc_hci_cmd_le_set_data_related_address_changes_t__bindgen_ty_1 {
    pub params: sdc_hci_le_set_data_related_address_changes_reasons_params_t,
    pub raw: [u8; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_data_related_address_changes_t__bindgen_ty_1"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_data_related_address_changes_t__bindgen_ty_1>() - 1usize];
    ["Alignment of sdc_hci_cmd_le_set_data_related_address_changes_t__bindgen_ty_1"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_data_related_address_changes_t__bindgen_ty_1>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_data_related_address_changes_t__bindgen_ty_1::params"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_data_related_address_changes_t__bindgen_ty_1, params) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_data_related_address_changes_t__bindgen_ty_1::raw"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_data_related_address_changes_t__bindgen_ty_1, raw) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_data_related_address_changes_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_data_related_address_changes_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_set_data_related_address_changes_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_data_related_address_changes_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_data_related_address_changes_t::adv_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_data_related_address_changes_t, adv_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_data_related_address_changes_t::change_reasons"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_data_related_address_changes_t, change_reasons) - 1usize];
};
#[doc = "LE Set Default Subrate command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_default_subrate_t {
    pub subrate_min: u16,
    pub subrate_max: u16,
    pub max_latency: u16,
    pub continuation_number: u16,
    pub supervision_timeout: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_default_subrate_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_default_subrate_t>() - 10usize];
    ["Alignment of sdc_hci_cmd_le_set_default_subrate_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_default_subrate_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_default_subrate_t::subrate_min"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_default_subrate_t, subrate_min) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_default_subrate_t::subrate_max"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_default_subrate_t, subrate_max) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_set_default_subrate_t::max_latency"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_default_subrate_t, max_latency) - 4usize];
    ["Offset of field: sdc_hci_cmd_le_set_default_subrate_t::continuation_number"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_default_subrate_t, continuation_number) - 6usize];
    ["Offset of field: sdc_hci_cmd_le_set_default_subrate_t::supervision_timeout"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_default_subrate_t, supervision_timeout) - 8usize];
};
#[doc = "LE Subrate Request command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_subrate_request_t {
    pub conn_handle: u16,
    pub subrate_min: u16,
    pub subrate_max: u16,
    pub max_latency: u16,
    pub continuation_number: u16,
    pub supervision_timeout: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_subrate_request_t"][::core::mem::size_of::<sdc_hci_cmd_le_subrate_request_t>() - 12usize];
    ["Alignment of sdc_hci_cmd_le_subrate_request_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_subrate_request_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_subrate_request_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_subrate_request_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_subrate_request_t::subrate_min"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_subrate_request_t, subrate_min) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_subrate_request_t::subrate_max"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_subrate_request_t, subrate_max) - 4usize];
    ["Offset of field: sdc_hci_cmd_le_subrate_request_t::max_latency"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_subrate_request_t, max_latency) - 6usize];
    ["Offset of field: sdc_hci_cmd_le_subrate_request_t::continuation_number"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_subrate_request_t, continuation_number) - 8usize];
    ["Offset of field: sdc_hci_cmd_le_subrate_request_t::supervision_timeout"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_subrate_request_t, supervision_timeout) - 10usize];
};
#[doc = "LE Set Extended Advertising Parameters command parameter(s)."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sdc_hci_cmd_le_set_ext_adv_params_v2_t {
    pub adv_handle: u8,
    pub adv_event_properties: sdc_hci_cmd_le_set_ext_adv_params_v2_t__bindgen_ty_1,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 6usize]>,
    pub primary_adv_channel_map: u8,
    pub own_address_type: u8,
    pub peer_address_type: u8,
    pub peer_address: [u8; 6usize],
    pub adv_filter_policy: u8,
    pub adv_tx_power: i8,
    pub primary_adv_phy: u8,
    pub secondary_adv_max_skip: u8,
    pub secondary_adv_phy: u8,
    pub adv_sid: u8,
    pub scan_request_notification_enable: u8,
    pub primary_adv_phy_options: u8,
    pub secondary_adv_phy_options: u8,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union sdc_hci_cmd_le_set_ext_adv_params_v2_t__bindgen_ty_1 {
    pub params: sdc_hci_le_adv_event_properties_params_t,
    pub raw: [u8; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_ext_adv_params_v2_t__bindgen_ty_1"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_ext_adv_params_v2_t__bindgen_ty_1>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_set_ext_adv_params_v2_t__bindgen_ty_1"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_ext_adv_params_v2_t__bindgen_ty_1>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_v2_t__bindgen_ty_1::params"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_v2_t__bindgen_ty_1, params) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_v2_t__bindgen_ty_1::raw"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_v2_t__bindgen_ty_1, raw) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_ext_adv_params_v2_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_ext_adv_params_v2_t>() - 27usize];
    ["Alignment of sdc_hci_cmd_le_set_ext_adv_params_v2_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_ext_adv_params_v2_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_v2_t::adv_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_v2_t, adv_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_v2_t::adv_event_properties"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_v2_t, adv_event_properties) - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_v2_t::primary_adv_channel_map"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_v2_t, primary_adv_channel_map) - 9usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_v2_t::own_address_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_v2_t, own_address_type) - 10usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_v2_t::peer_address_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_v2_t, peer_address_type) - 11usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_v2_t::peer_address"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_v2_t, peer_address) - 12usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_v2_t::adv_filter_policy"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_v2_t, adv_filter_policy) - 18usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_v2_t::adv_tx_power"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_v2_t, adv_tx_power) - 19usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_v2_t::primary_adv_phy"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_v2_t, primary_adv_phy) - 20usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_v2_t::secondary_adv_max_skip"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_v2_t, secondary_adv_max_skip) - 21usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_v2_t::secondary_adv_phy"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_v2_t, secondary_adv_phy) - 22usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_v2_t::adv_sid"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_v2_t, adv_sid) - 23usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_v2_t::scan_request_notification_enable"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_v2_t, scan_request_notification_enable) - 24usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_v2_t::primary_adv_phy_options"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_v2_t, primary_adv_phy_options) - 25usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_v2_t::secondary_adv_phy_options"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_v2_t, secondary_adv_phy_options) - 26usize];
};
impl sdc_hci_cmd_le_set_ext_adv_params_v2_t {
    #[inline]
    pub fn primary_adv_interval_min(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_primary_adv_interval_min(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn primary_adv_interval_min_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_primary_adv_interval_min_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn primary_adv_interval_max(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_primary_adv_interval_max(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn primary_adv_interval_max_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_primary_adv_interval_max_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        primary_adv_interval_min: u32,
        primary_adv_interval_max: u32,
    ) -> __BindgenBitfieldUnit<[u8; 6usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 6usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let primary_adv_interval_min: u32 = unsafe { ::core::mem::transmute(primary_adv_interval_min) };
            primary_adv_interval_min as u64
        });
        __bindgen_bitfield_unit.set(24usize, 24u8, {
            let primary_adv_interval_max: u32 = unsafe { ::core::mem::transmute(primary_adv_interval_max) };
            primary_adv_interval_max as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "LE Set Extended Advertising Parameters return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_ext_adv_params_v2_return_t {
    pub selected_tx_power: i8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_ext_adv_params_v2_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_ext_adv_params_v2_return_t>() - 1usize];
    ["Alignment of sdc_hci_cmd_le_set_ext_adv_params_v2_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_ext_adv_params_v2_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_ext_adv_params_v2_return_t::selected_tx_power"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_ext_adv_params_v2_return_t, selected_tx_power) - 0usize];
};
#[doc = "LE Set Periodic Advertising Subevent Data command parameter(s)."]
#[repr(C, packed)]
pub struct sdc_hci_cmd_le_set_periodic_adv_subevent_data_t {
    pub adv_handle: u8,
    pub num_subevents: u8,
    #[doc = "C does not allow array of variable sized arrays, otherwise it should be sdc_hci_le_set_periodic_adv_subevent_data_array_params_t array_params"]
    pub array_params: __IncompleteArrayField<u8>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_periodic_adv_subevent_data_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_periodic_adv_subevent_data_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_set_periodic_adv_subevent_data_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_periodic_adv_subevent_data_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_subevent_data_t::adv_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_subevent_data_t, adv_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_subevent_data_t::num_subevents"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_subevent_data_t, num_subevents) - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_subevent_data_t::array_params"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_subevent_data_t, array_params) - 2usize];
};
#[doc = "LE Set Periodic Advertising Subevent Data return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_periodic_adv_subevent_data_return_t {
    pub adv_handle: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_periodic_adv_subevent_data_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_periodic_adv_subevent_data_return_t>() - 1usize];
    ["Alignment of sdc_hci_cmd_le_set_periodic_adv_subevent_data_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_periodic_adv_subevent_data_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_subevent_data_return_t::adv_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_subevent_data_return_t, adv_handle) - 0usize];
};
#[doc = "LE Set Periodic Advertising Response Data command parameter(s)."]
#[repr(C, packed)]
pub struct sdc_hci_cmd_le_set_periodic_adv_response_data_t {
    pub sync_handle: u16,
    pub request_event: u16,
    pub request_subevent: u8,
    pub response_subevent: u8,
    pub response_slot: u8,
    pub response_data_length: u8,
    pub response_data: __IncompleteArrayField<u8>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_periodic_adv_response_data_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_periodic_adv_response_data_t>() - 8usize];
    ["Alignment of sdc_hci_cmd_le_set_periodic_adv_response_data_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_periodic_adv_response_data_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_response_data_t::sync_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_response_data_t, sync_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_response_data_t::request_event"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_response_data_t, request_event) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_response_data_t::request_subevent"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_response_data_t, request_subevent) - 4usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_response_data_t::response_subevent"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_response_data_t, response_subevent) - 5usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_response_data_t::response_slot"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_response_data_t, response_slot) - 6usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_response_data_t::response_data_length"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_response_data_t, response_data_length) - 7usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_response_data_t::response_data"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_response_data_t, response_data) - 8usize];
};
#[doc = "LE Set Periodic Advertising Response Data return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_periodic_adv_response_data_return_t {
    pub sync_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_periodic_adv_response_data_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_periodic_adv_response_data_return_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_set_periodic_adv_response_data_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_periodic_adv_response_data_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_response_data_return_t::sync_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_response_data_return_t, sync_handle) - 0usize];
};
#[doc = "LE Set Periodic Sync Subevent command parameter(s)."]
#[repr(C, packed)]
pub struct sdc_hci_cmd_le_set_periodic_sync_subevent_t {
    pub sync_handle: u16,
    pub periodic_adv_properties: u16,
    pub num_subevents: u8,
    pub subevents: __IncompleteArrayField<u8>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_periodic_sync_subevent_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_periodic_sync_subevent_t>() - 5usize];
    ["Alignment of sdc_hci_cmd_le_set_periodic_sync_subevent_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_periodic_sync_subevent_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_sync_subevent_t::sync_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_sync_subevent_t, sync_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_sync_subevent_t::periodic_adv_properties"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_sync_subevent_t, periodic_adv_properties) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_sync_subevent_t::num_subevents"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_sync_subevent_t, num_subevents) - 4usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_sync_subevent_t::subevents"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_sync_subevent_t, subevents) - 5usize];
};
#[doc = "LE Set Periodic Sync Subevent return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_periodic_sync_subevent_return_t {
    pub sync_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_periodic_sync_subevent_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_periodic_sync_subevent_return_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_set_periodic_sync_subevent_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_periodic_sync_subevent_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_sync_subevent_return_t::sync_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_sync_subevent_return_t, sync_handle) - 0usize];
};
#[doc = "LE Extended Create Connection command parameter(s)."]
#[repr(C, packed)]
pub struct sdc_hci_cmd_le_ext_create_conn_v2_t {
    pub adv_handle: u8,
    pub subevent: u8,
    pub initiator_filter_policy: u8,
    pub own_address_type: u8,
    pub peer_address_type: u8,
    pub peer_address: [u8; 6usize],
    pub initiating_phys: u8,
    pub array_params: __IncompleteArrayField<sdc_hci_le_ext_create_conn_v2_array_params_t>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_ext_create_conn_v2_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_ext_create_conn_v2_t>() - 12usize];
    ["Alignment of sdc_hci_cmd_le_ext_create_conn_v2_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_ext_create_conn_v2_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_ext_create_conn_v2_t::adv_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_ext_create_conn_v2_t, adv_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_ext_create_conn_v2_t::subevent"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_ext_create_conn_v2_t, subevent) - 1usize];
    ["Offset of field: sdc_hci_cmd_le_ext_create_conn_v2_t::initiator_filter_policy"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_ext_create_conn_v2_t, initiator_filter_policy) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_ext_create_conn_v2_t::own_address_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_ext_create_conn_v2_t, own_address_type) - 3usize];
    ["Offset of field: sdc_hci_cmd_le_ext_create_conn_v2_t::peer_address_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_ext_create_conn_v2_t, peer_address_type) - 4usize];
    ["Offset of field: sdc_hci_cmd_le_ext_create_conn_v2_t::peer_address"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_ext_create_conn_v2_t, peer_address) - 5usize];
    ["Offset of field: sdc_hci_cmd_le_ext_create_conn_v2_t::initiating_phys"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_ext_create_conn_v2_t, initiating_phys) - 11usize];
    ["Offset of field: sdc_hci_cmd_le_ext_create_conn_v2_t::array_params"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_ext_create_conn_v2_t, array_params) - 12usize];
};
#[doc = "LE Set Periodic Advertising Parameters command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_periodic_adv_params_v2_t {
    pub adv_handle: u8,
    pub periodic_adv_interval_min: u16,
    pub periodic_adv_interval_max: u16,
    pub periodic_adv_properties: u16,
    pub num_subevents: u8,
    pub subevent_interval: u8,
    pub response_slot_delay: u8,
    pub response_slot_spacing: u8,
    pub num_response_slots: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_periodic_adv_params_v2_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_periodic_adv_params_v2_t>() - 12usize];
    ["Alignment of sdc_hci_cmd_le_set_periodic_adv_params_v2_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_periodic_adv_params_v2_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_params_v2_t::adv_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_params_v2_t, adv_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_params_v2_t::periodic_adv_interval_min"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_params_v2_t, periodic_adv_interval_min) - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_params_v2_t::periodic_adv_interval_max"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_params_v2_t, periodic_adv_interval_max) - 3usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_params_v2_t::periodic_adv_properties"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_params_v2_t, periodic_adv_properties) - 5usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_params_v2_t::num_subevents"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_params_v2_t, num_subevents) - 7usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_params_v2_t::subevent_interval"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_params_v2_t, subevent_interval) - 8usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_params_v2_t::response_slot_delay"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_params_v2_t, response_slot_delay) - 9usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_params_v2_t::response_slot_spacing"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_params_v2_t, response_slot_spacing) - 10usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_params_v2_t::num_response_slots"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_params_v2_t, num_response_slots) - 11usize];
};
#[doc = "LE Set Periodic Advertising Parameters return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_periodic_adv_params_v2_return_t {
    pub adv_handle: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_periodic_adv_params_v2_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_periodic_adv_params_v2_return_t>() - 1usize];
    ["Alignment of sdc_hci_cmd_le_set_periodic_adv_params_v2_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_periodic_adv_params_v2_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_periodic_adv_params_v2_return_t::adv_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_periodic_adv_params_v2_return_t, adv_handle) - 0usize];
};
#[doc = "LE CS Read Local Supported Capabilities return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t {
    pub num_config_supported: u8,
    pub max_consecutive_procedures_supported: u16,
    pub num_antennas_supported: u8,
    pub max_antenna_paths_supported: u8,
    pub roles_supported: u8,
    pub modes_supported: u8,
    pub rtt_capability: u8,
    pub rtt_aa_only_n: u8,
    pub rtt_sounding_n: u8,
    pub rtt_random_payload_n: u8,
    pub nadm_sounding_capability: u16,
    pub nadm_random_capability: u16,
    pub cs_sync_phys_supported: u8,
    pub subfeatures_supported: u16,
    pub t_ip1_times_supported: u16,
    pub t_ip2_times_supported: u16,
    pub t_fcs_times_supported: u16,
    pub t_pm_times_supported: u16,
    pub t_sw_time_supported: u8,
    pub tx_snr_capability: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t>() - 28usize];
    ["Alignment of sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t::num_config_supported"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t,
        num_config_supported
    ) - 0usize];
    [
        "Offset of field: sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t::max_consecutive_procedures_supported",
    ][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t,
        max_consecutive_procedures_supported
    ) - 1usize];
    ["Offset of field: sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t::num_antennas_supported"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t,
        num_antennas_supported
    )
        - 3usize];
    ["Offset of field: sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t::max_antenna_paths_supported"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t,
        max_antenna_paths_supported
    )
        - 4usize];
    ["Offset of field: sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t::roles_supported"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t,
        roles_supported
    ) - 5usize];
    ["Offset of field: sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t::modes_supported"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t,
        modes_supported
    ) - 6usize];
    ["Offset of field: sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t::rtt_capability"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t,
        rtt_capability
    ) - 7usize];
    ["Offset of field: sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t::rtt_aa_only_n"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t,
        rtt_aa_only_n
    ) - 8usize];
    ["Offset of field: sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t::rtt_sounding_n"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t,
        rtt_sounding_n
    ) - 9usize];
    ["Offset of field: sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t::rtt_random_payload_n"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t,
        rtt_random_payload_n
    )
        - 10usize];
    ["Offset of field: sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t::nadm_sounding_capability"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t,
        nadm_sounding_capability
    )
        - 11usize];
    ["Offset of field: sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t::nadm_random_capability"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t,
        nadm_random_capability
    )
        - 13usize];
    ["Offset of field: sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t::cs_sync_phys_supported"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t,
        cs_sync_phys_supported
    )
        - 15usize];
    ["Offset of field: sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t::subfeatures_supported"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t,
        subfeatures_supported
    )
        - 16usize];
    ["Offset of field: sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t::t_ip1_times_supported"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t,
        t_ip1_times_supported
    )
        - 18usize];
    ["Offset of field: sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t::t_ip2_times_supported"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t,
        t_ip2_times_supported
    )
        - 20usize];
    ["Offset of field: sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t::t_fcs_times_supported"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t,
        t_fcs_times_supported
    )
        - 22usize];
    ["Offset of field: sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t::t_pm_times_supported"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t,
        t_pm_times_supported
    )
        - 24usize];
    ["Offset of field: sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t::t_sw_time_supported"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t,
        t_sw_time_supported
    ) - 26usize];
    ["Offset of field: sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t::tx_snr_capability"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t,
        tx_snr_capability
    ) - 27usize];
};
#[doc = "LE CS Read Remote Supported Capabilities command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_cs_read_remote_supported_capabilities_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_cs_read_remote_supported_capabilities_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_cs_read_remote_supported_capabilities_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_cs_read_remote_supported_capabilities_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_cs_read_remote_supported_capabilities_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_cs_read_remote_supported_capabilities_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_read_remote_supported_capabilities_t, conn_handle) - 0usize];
};
#[doc = "LE CS Write Cached Remote Supported Capabilities command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t {
    pub conn_handle: u16,
    pub num_config_supported: u8,
    pub max_consecutive_procedures_supported: u16,
    pub num_antennas_supported: u8,
    pub max_antenna_paths_supported: u8,
    pub roles_supported: u8,
    pub modes_supported: u8,
    pub rtt_capability: u8,
    pub rtt_aa_only_n: u8,
    pub rtt_sounding_n: u8,
    pub rtt_random_payload_n: u8,
    pub nadm_sounding_capability: u16,
    pub nadm_random_capability: u16,
    pub cs_sync_phys_supported: u8,
    pub subfeatures_supported: u16,
    pub t_ip1_times_supported: u16,
    pub t_ip2_times_supported: u16,
    pub t_fcs_times_supported: u16,
    pub t_pm_times_supported: u16,
    pub t_sw_time_supported: u8,
    pub tx_snr_capability: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t>() - 30usize];
    ["Alignment of sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t::conn_handle"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t,
        conn_handle
    ) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t::num_config_supported"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t,
        num_config_supported
    )
        - 2usize];
    [
        "Offset of field: sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t::max_consecutive_procedures_supported",
    ][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t,
        max_consecutive_procedures_supported
    ) - 3usize];
    ["Offset of field: sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t::num_antennas_supported"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t,
        num_antennas_supported
    )
        - 5usize];
    ["Offset of field: sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t::max_antenna_paths_supported"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t,
        max_antenna_paths_supported
    )
        - 6usize];
    ["Offset of field: sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t::roles_supported"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t,
        roles_supported
    ) - 7usize];
    ["Offset of field: sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t::modes_supported"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t,
        modes_supported
    ) - 8usize];
    ["Offset of field: sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t::rtt_capability"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t,
        rtt_capability
    ) - 9usize];
    ["Offset of field: sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t::rtt_aa_only_n"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t,
        rtt_aa_only_n
    ) - 10usize];
    ["Offset of field: sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t::rtt_sounding_n"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t,
        rtt_sounding_n
    ) - 11usize];
    ["Offset of field: sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t::rtt_random_payload_n"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t,
        rtt_random_payload_n
    )
        - 12usize];
    ["Offset of field: sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t::nadm_sounding_capability"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t,
        nadm_sounding_capability
    )
        - 13usize];
    ["Offset of field: sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t::nadm_random_capability"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t,
        nadm_random_capability
    )
        - 15usize];
    ["Offset of field: sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t::cs_sync_phys_supported"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t,
        cs_sync_phys_supported
    )
        - 17usize];
    ["Offset of field: sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t::subfeatures_supported"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t,
        subfeatures_supported
    )
        - 18usize];
    ["Offset of field: sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t::t_ip1_times_supported"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t,
        t_ip1_times_supported
    )
        - 20usize];
    ["Offset of field: sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t::t_ip2_times_supported"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t,
        t_ip2_times_supported
    )
        - 22usize];
    ["Offset of field: sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t::t_fcs_times_supported"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t,
        t_fcs_times_supported
    )
        - 24usize];
    ["Offset of field: sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t::t_pm_times_supported"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t,
        t_pm_times_supported
    )
        - 26usize];
    ["Offset of field: sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t::t_sw_time_supported"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t,
        t_sw_time_supported
    )
        - 28usize];
    ["Offset of field: sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t::tx_snr_capability"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t,
        tx_snr_capability
    ) - 29usize];
};
#[doc = "LE CS Write Cached Remote Supported Capabilities return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_return_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_return_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_return_t::conn_handle"][::core::mem::offset_of!(
        sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_return_t,
        conn_handle
    ) - 0usize];
};
#[doc = "LE CS Security Enable command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_cs_security_enable_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_cs_security_enable_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_cs_security_enable_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_cs_security_enable_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_cs_security_enable_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_cs_security_enable_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_security_enable_t, conn_handle) - 0usize];
};
#[doc = "LE CS Set Default Settings command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_cs_set_default_settings_t {
    pub conn_handle: u16,
    pub role_enable: u8,
    pub cs_sync_antenna_selection: u8,
    pub max_tx_power: i8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_cs_set_default_settings_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_cs_set_default_settings_t>() - 5usize];
    ["Alignment of sdc_hci_cmd_le_cs_set_default_settings_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_cs_set_default_settings_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_cs_set_default_settings_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_set_default_settings_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_cs_set_default_settings_t::role_enable"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_set_default_settings_t, role_enable) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_cs_set_default_settings_t::cs_sync_antenna_selection"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_set_default_settings_t, cs_sync_antenna_selection) - 3usize];
    ["Offset of field: sdc_hci_cmd_le_cs_set_default_settings_t::max_tx_power"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_set_default_settings_t, max_tx_power) - 4usize];
};
#[doc = "LE CS Set Default Settings return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_cs_set_default_settings_return_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_cs_set_default_settings_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_cs_set_default_settings_return_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_cs_set_default_settings_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_cs_set_default_settings_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_cs_set_default_settings_return_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_set_default_settings_return_t, conn_handle) - 0usize];
};
#[doc = "LE CS Read Remote FAE Table command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_cs_read_remote_fae_table_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_cs_read_remote_fae_table_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_cs_read_remote_fae_table_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_cs_read_remote_fae_table_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_cs_read_remote_fae_table_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_cs_read_remote_fae_table_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_read_remote_fae_table_t, conn_handle) - 0usize];
};
#[doc = "LE CS Write Cached Remote FAE Table command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_cs_write_cached_remote_fae_table_t {
    pub conn_handle: u16,
    pub remote_fae_table: [u8; 72usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_cs_write_cached_remote_fae_table_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_cs_write_cached_remote_fae_table_t>() - 74usize];
    ["Alignment of sdc_hci_cmd_le_cs_write_cached_remote_fae_table_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_cs_write_cached_remote_fae_table_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_cs_write_cached_remote_fae_table_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_write_cached_remote_fae_table_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_cs_write_cached_remote_fae_table_t::remote_fae_table"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_write_cached_remote_fae_table_t, remote_fae_table) - 2usize];
};
#[doc = "LE CS Write Cached Remote FAE Table return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_cs_write_cached_remote_fae_table_return_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_cs_write_cached_remote_fae_table_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_cs_write_cached_remote_fae_table_return_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_cs_write_cached_remote_fae_table_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_cs_write_cached_remote_fae_table_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_cs_write_cached_remote_fae_table_return_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_write_cached_remote_fae_table_return_t, conn_handle) - 0usize];
};
#[doc = "LE CS Create Config command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_cs_create_config_t {
    pub conn_handle: u16,
    pub config_id: u8,
    pub create_context: u8,
    pub main_mode_type: u8,
    pub sub_mode_type: u8,
    pub min_main_mode_steps: u8,
    pub max_main_mode_steps: u8,
    pub main_mode_repetition: u8,
    pub mode_0_steps: u8,
    pub role: u8,
    pub rtt_type: u8,
    pub cs_sync_phy: u8,
    pub channel_map: [u8; 10usize],
    pub channel_map_repetition: u8,
    pub channel_selection_type: u8,
    pub ch3c_shape: u8,
    pub ch3c_jump: u8,
    pub reserved: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_cs_create_config_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_cs_create_config_t>() - 28usize];
    ["Alignment of sdc_hci_cmd_le_cs_create_config_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_cs_create_config_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_cs_create_config_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_create_config_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_cs_create_config_t::config_id"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_create_config_t, config_id) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_cs_create_config_t::create_context"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_create_config_t, create_context) - 3usize];
    ["Offset of field: sdc_hci_cmd_le_cs_create_config_t::main_mode_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_create_config_t, main_mode_type) - 4usize];
    ["Offset of field: sdc_hci_cmd_le_cs_create_config_t::sub_mode_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_create_config_t, sub_mode_type) - 5usize];
    ["Offset of field: sdc_hci_cmd_le_cs_create_config_t::min_main_mode_steps"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_create_config_t, min_main_mode_steps) - 6usize];
    ["Offset of field: sdc_hci_cmd_le_cs_create_config_t::max_main_mode_steps"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_create_config_t, max_main_mode_steps) - 7usize];
    ["Offset of field: sdc_hci_cmd_le_cs_create_config_t::main_mode_repetition"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_create_config_t, main_mode_repetition) - 8usize];
    ["Offset of field: sdc_hci_cmd_le_cs_create_config_t::mode_0_steps"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_create_config_t, mode_0_steps) - 9usize];
    ["Offset of field: sdc_hci_cmd_le_cs_create_config_t::role"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_create_config_t, role) - 10usize];
    ["Offset of field: sdc_hci_cmd_le_cs_create_config_t::rtt_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_create_config_t, rtt_type) - 11usize];
    ["Offset of field: sdc_hci_cmd_le_cs_create_config_t::cs_sync_phy"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_create_config_t, cs_sync_phy) - 12usize];
    ["Offset of field: sdc_hci_cmd_le_cs_create_config_t::channel_map"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_create_config_t, channel_map) - 13usize];
    ["Offset of field: sdc_hci_cmd_le_cs_create_config_t::channel_map_repetition"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_create_config_t, channel_map_repetition) - 23usize];
    ["Offset of field: sdc_hci_cmd_le_cs_create_config_t::channel_selection_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_create_config_t, channel_selection_type) - 24usize];
    ["Offset of field: sdc_hci_cmd_le_cs_create_config_t::ch3c_shape"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_create_config_t, ch3c_shape) - 25usize];
    ["Offset of field: sdc_hci_cmd_le_cs_create_config_t::ch3c_jump"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_create_config_t, ch3c_jump) - 26usize];
    ["Offset of field: sdc_hci_cmd_le_cs_create_config_t::reserved"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_create_config_t, reserved) - 27usize];
};
#[doc = "LE CS Remove Config command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_cs_remove_config_t {
    pub conn_handle: u16,
    pub config_id: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_cs_remove_config_t"][::core::mem::size_of::<sdc_hci_cmd_le_cs_remove_config_t>() - 3usize];
    ["Alignment of sdc_hci_cmd_le_cs_remove_config_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_cs_remove_config_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_cs_remove_config_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_remove_config_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_cs_remove_config_t::config_id"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_remove_config_t, config_id) - 2usize];
};
#[doc = "LE CS Set Channel Classification command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_cs_set_channel_classification_t {
    pub channel_classification: [u8; 10usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_cs_set_channel_classification_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_cs_set_channel_classification_t>() - 10usize];
    ["Alignment of sdc_hci_cmd_le_cs_set_channel_classification_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_cs_set_channel_classification_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_cs_set_channel_classification_t::channel_classification"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_set_channel_classification_t, channel_classification) - 0usize];
};
#[doc = "LE CS Set Procedure Parameters command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_cs_set_procedure_params_t {
    pub conn_handle: u16,
    pub config_id: u8,
    pub max_procedure_len: u16,
    pub min_procedure_interval: u16,
    pub max_procedure_interval: u16,
    pub max_procedure_count: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 6usize]>,
    pub tone_antenna_config_selection: u8,
    pub phy: u8,
    pub tx_power_delta: i8,
    pub preferred_peer_antenna: u8,
    pub snr_control_initiator: u8,
    pub snr_control_reflector: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_cs_set_procedure_params_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_cs_set_procedure_params_t>() - 23usize];
    ["Alignment of sdc_hci_cmd_le_cs_set_procedure_params_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_cs_set_procedure_params_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_cs_set_procedure_params_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_set_procedure_params_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_cs_set_procedure_params_t::config_id"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_set_procedure_params_t, config_id) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_cs_set_procedure_params_t::max_procedure_len"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_set_procedure_params_t, max_procedure_len) - 3usize];
    ["Offset of field: sdc_hci_cmd_le_cs_set_procedure_params_t::min_procedure_interval"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_set_procedure_params_t, min_procedure_interval) - 5usize];
    ["Offset of field: sdc_hci_cmd_le_cs_set_procedure_params_t::max_procedure_interval"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_set_procedure_params_t, max_procedure_interval) - 7usize];
    ["Offset of field: sdc_hci_cmd_le_cs_set_procedure_params_t::max_procedure_count"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_set_procedure_params_t, max_procedure_count) - 9usize];
    ["Offset of field: sdc_hci_cmd_le_cs_set_procedure_params_t::tone_antenna_config_selection"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_set_procedure_params_t, tone_antenna_config_selection) - 17usize];
    ["Offset of field: sdc_hci_cmd_le_cs_set_procedure_params_t::phy"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_set_procedure_params_t, phy) - 18usize];
    ["Offset of field: sdc_hci_cmd_le_cs_set_procedure_params_t::tx_power_delta"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_set_procedure_params_t, tx_power_delta) - 19usize];
    ["Offset of field: sdc_hci_cmd_le_cs_set_procedure_params_t::preferred_peer_antenna"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_set_procedure_params_t, preferred_peer_antenna) - 20usize];
    ["Offset of field: sdc_hci_cmd_le_cs_set_procedure_params_t::snr_control_initiator"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_set_procedure_params_t, snr_control_initiator) - 21usize];
    ["Offset of field: sdc_hci_cmd_le_cs_set_procedure_params_t::snr_control_reflector"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_set_procedure_params_t, snr_control_reflector) - 22usize];
};
impl sdc_hci_cmd_le_cs_set_procedure_params_t {
    #[inline]
    pub fn min_subevent_len(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_min_subevent_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn min_subevent_len_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_min_subevent_len_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn max_subevent_len(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_max_subevent_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn max_subevent_len_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_max_subevent_len_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(min_subevent_len: u32, max_subevent_len: u32) -> __BindgenBitfieldUnit<[u8; 6usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 6usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let min_subevent_len: u32 = unsafe { ::core::mem::transmute(min_subevent_len) };
            min_subevent_len as u64
        });
        __bindgen_bitfield_unit.set(24usize, 24u8, {
            let max_subevent_len: u32 = unsafe { ::core::mem::transmute(max_subevent_len) };
            max_subevent_len as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "LE CS Set Procedure Parameters return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_cs_set_procedure_params_return_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_cs_set_procedure_params_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_cs_set_procedure_params_return_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_le_cs_set_procedure_params_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_cs_set_procedure_params_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_cs_set_procedure_params_return_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_set_procedure_params_return_t, conn_handle) - 0usize];
};
#[doc = "LE CS Procedure Enable command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_cs_procedure_enable_t {
    pub conn_handle: u16,
    pub config_id: u8,
    pub enable: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_cs_procedure_enable_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_cs_procedure_enable_t>() - 4usize];
    ["Alignment of sdc_hci_cmd_le_cs_procedure_enable_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_cs_procedure_enable_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_cs_procedure_enable_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_procedure_enable_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_cs_procedure_enable_t::config_id"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_procedure_enable_t, config_id) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_cs_procedure_enable_t::enable"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_procedure_enable_t, enable) - 3usize];
};
#[doc = "LE CS Test command parameter(s)."]
#[repr(C, packed)]
pub struct sdc_hci_cmd_le_cs_test_t {
    pub main_mode_type: u8,
    pub sub_mode_type: u8,
    pub main_mode_repetition: u8,
    pub mode_0_steps: u8,
    pub role: u8,
    pub rtt_type: u8,
    pub cs_sync_phy: u8,
    pub cs_sync_antenna_selection: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub subevent_interval: u16,
    pub max_num_subevents: u8,
    pub transmit_power_level: i8,
    pub t_ip1_time: u8,
    pub t_ip2_time: u8,
    pub t_fcs_time: u8,
    pub t_pm_time: u8,
    pub t_sw_time: u8,
    pub tone_antenna_config_selection: u8,
    pub reserved: u8,
    pub snr_control_initiator: u8,
    pub snr_control_reflector: u8,
    pub drbg_nonce: u16,
    pub channel_map_repetition: u8,
    pub override_config: u16,
    pub override_params_length: u8,
    pub override_params_data: __IncompleteArrayField<u8>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_cs_test_t"][::core::mem::size_of::<sdc_hci_cmd_le_cs_test_t>() - 30usize];
    ["Alignment of sdc_hci_cmd_le_cs_test_t"][::core::mem::align_of::<sdc_hci_cmd_le_cs_test_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_cs_test_t::main_mode_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_test_t, main_mode_type) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_cs_test_t::sub_mode_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_test_t, sub_mode_type) - 1usize];
    ["Offset of field: sdc_hci_cmd_le_cs_test_t::main_mode_repetition"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_test_t, main_mode_repetition) - 2usize];
    ["Offset of field: sdc_hci_cmd_le_cs_test_t::mode_0_steps"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_test_t, mode_0_steps) - 3usize];
    ["Offset of field: sdc_hci_cmd_le_cs_test_t::role"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_test_t, role) - 4usize];
    ["Offset of field: sdc_hci_cmd_le_cs_test_t::rtt_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_test_t, rtt_type) - 5usize];
    ["Offset of field: sdc_hci_cmd_le_cs_test_t::cs_sync_phy"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_test_t, cs_sync_phy) - 6usize];
    ["Offset of field: sdc_hci_cmd_le_cs_test_t::cs_sync_antenna_selection"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_test_t, cs_sync_antenna_selection) - 7usize];
    ["Offset of field: sdc_hci_cmd_le_cs_test_t::subevent_interval"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_test_t, subevent_interval) - 11usize];
    ["Offset of field: sdc_hci_cmd_le_cs_test_t::max_num_subevents"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_test_t, max_num_subevents) - 13usize];
    ["Offset of field: sdc_hci_cmd_le_cs_test_t::transmit_power_level"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_test_t, transmit_power_level) - 14usize];
    ["Offset of field: sdc_hci_cmd_le_cs_test_t::t_ip1_time"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_test_t, t_ip1_time) - 15usize];
    ["Offset of field: sdc_hci_cmd_le_cs_test_t::t_ip2_time"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_test_t, t_ip2_time) - 16usize];
    ["Offset of field: sdc_hci_cmd_le_cs_test_t::t_fcs_time"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_test_t, t_fcs_time) - 17usize];
    ["Offset of field: sdc_hci_cmd_le_cs_test_t::t_pm_time"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_test_t, t_pm_time) - 18usize];
    ["Offset of field: sdc_hci_cmd_le_cs_test_t::t_sw_time"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_test_t, t_sw_time) - 19usize];
    ["Offset of field: sdc_hci_cmd_le_cs_test_t::tone_antenna_config_selection"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_test_t, tone_antenna_config_selection) - 20usize];
    ["Offset of field: sdc_hci_cmd_le_cs_test_t::reserved"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_test_t, reserved) - 21usize];
    ["Offset of field: sdc_hci_cmd_le_cs_test_t::snr_control_initiator"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_test_t, snr_control_initiator) - 22usize];
    ["Offset of field: sdc_hci_cmd_le_cs_test_t::snr_control_reflector"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_test_t, snr_control_reflector) - 23usize];
    ["Offset of field: sdc_hci_cmd_le_cs_test_t::drbg_nonce"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_test_t, drbg_nonce) - 24usize];
    ["Offset of field: sdc_hci_cmd_le_cs_test_t::channel_map_repetition"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_test_t, channel_map_repetition) - 26usize];
    ["Offset of field: sdc_hci_cmd_le_cs_test_t::override_config"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_test_t, override_config) - 27usize];
    ["Offset of field: sdc_hci_cmd_le_cs_test_t::override_params_length"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_test_t, override_params_length) - 29usize];
    ["Offset of field: sdc_hci_cmd_le_cs_test_t::override_params_data"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_cs_test_t, override_params_data) - 30usize];
};
impl sdc_hci_cmd_le_cs_test_t {
    #[inline]
    pub fn subevent_len(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_subevent_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn subevent_len_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_subevent_len_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(subevent_len: u32) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let subevent_len: u32 = unsafe { ::core::mem::transmute(subevent_len) };
            subevent_len as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "LE Set Host Feature command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_host_feature_v2_t {
    pub bit_number: u16,
    pub bit_value: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_le_set_host_feature_v2_t"]
        [::core::mem::size_of::<sdc_hci_cmd_le_set_host_feature_v2_t>() - 3usize];
    ["Alignment of sdc_hci_cmd_le_set_host_feature_v2_t"]
        [::core::mem::align_of::<sdc_hci_cmd_le_set_host_feature_v2_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_le_set_host_feature_v2_t::bit_number"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_host_feature_v2_t, bit_number) - 0usize];
    ["Offset of field: sdc_hci_cmd_le_set_host_feature_v2_t::bit_value"]
        [::core::mem::offset_of!(sdc_hci_cmd_le_set_host_feature_v2_t, bit_value) - 2usize];
};
unsafe extern "C" {
    #[doc = "HCI_VS_API API\n # /\n/* LE Set Event Mask.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.1\n\n The HCI_LE_Set_Event_Mask command is used to control which LE events are\n generated by the HCI for the Host. If the bit in the LE_Event_Mask is set to a one,\n then the event associated with that bit will be enabled. The event mask allows the Host\n to control which events will interrupt it.\n\n The Controller shall ignore those bits which are reserved for future use or represent\n events which it does not support. If the Host sets any of these bits to 1, the Controller\n shall act as if they were set to 0.\n\n For LE events to be generated, the LE Meta event bit in the Event_Mask shall also be\n set. If that bit is not set, then LE events shall not be generated, regardless of how the\n LE_Event_Mask is set.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Event_Mask command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_event_mask(p_params: *const sdc_hci_cmd_le_set_event_mask_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Read Buffer Size The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.2\n\n This command is used to read the maximum size of the data portion of ACL data\n packets and isochronous data packets sent from the Host to the Controller. The Host\n shall fragment the data transmitted to the Controller according to these values so that\n the HCI ACL Data packets and HCI ISO Data packets will contain data up to this size\n (data includes optional fields in the HCI ISO Data packet, such as ISO_SDU_Length).\n The HCI_LE_Read_Buffer_Size command also returns the total number of HCI LE ACL\n Data packets and isochronous data packets that can be stored in the data buffers of the\n Controller. The HCI_LE_Read_Buffer_Size command shall be issued by the Host before\n it sends any data to an LE Controller (see Section 4.1.1). If the Controller supports HCI\n ISO Data packets, it shall return non-zero values for the ISO_Data_Packet_Length and\n Total_Num_ISO_Data_Packets parameters.\n\n If the Controller returns a length value of zero for ACL data packets, the Host shall use\n the HCI_Read_Buffer_Size command to determine the size of the data buffers (shared\n between BR/EDR and LE transports).\n\n Note: Both the HCI_Read_Buffer_Size command and the HCI_LE_Read_Buffer_Size\n command may return buffer length and number of packets parameter values that are\n nonzero. This allows a Controller to offer different buffers and number of buffers for\n BR/EDR data packets and LE data packets.\n\n The LE_ACL_Data_Packet_Length parameter shall be used to determine the maximum\n size of the L2CAP PDU fragments that are contained in ACL data packets, and which\n are transferred from the Host to the Controller to be broken up into packets by the Link\n Layer. The Total_Num_LE_ACL_Data_Packets parameter contains the total number of\n HCI ACL Data packets that can be stored in the data buffers of the Controller. The Host\n determines how to divide the buffers between different connection handles.\n\n The ISO_Data_Packet_Length parameter shall be used to determine the maximum\n size of the SDU fragments that are contained in isochronous data packets, and which\n are transferred from the Host to the Controller. The Total_Num_ISO_Data_Packets\n parameter contains the total number of isochronous data packets that can be stored\n in the data buffers of the Controller. The Host determines how to divide the buffers\n between different connection handle(s).\n\n Note: The LE_ACL_Data_Packet_Length and ISO_Data_Packet_Length return\n parameters do not include the length of the HCI ACL Data packet header or the HCI\n ISO Data packet header respectively.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_Buffer_Size command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_buffer_size(p_return: *mut sdc_hci_cmd_le_read_buffer_size_return_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Read Local Supported Features Page 0.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.3\n\n This command requests page 0 of the list of the supported LE features for the\n Controller.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_Local_Supported_Features_Page_0 command has\n completed, an HCI_Command_Complete event shall be generated.\n\n This command was formerly called LE Read Local Supported Features.\n\n # Arguments\n\n* `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_local_supported_features(
        p_return: *mut sdc_hci_cmd_le_read_local_supported_features_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Random Address.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.4\n\n The HCI_LE_Set_Random_Address command is used by the Host to set the LE\n Random Device Address in the Controller (see 6] Part B, Section 1.3).\n\n If this command is used to change the address, the new random address shall take\n effect for advertising no later than the next successful HCI_LE_Set_Advertising_Enable\n command, for scanning no later than the next successful HCI_LE_Set_Scan_Enable\n command or HCI_LE_Set_Extended_Scan_Enable command, and for initiating\n no later than the next successful HCI_LE_Create_Connection command or\n HCI_LE_Extended_Create_Connection command.\n\n Note: If the extended advertising commands are in use, this command only affects the\n address used for scanning and initiating. The addresses used for advertising are set by\n the HCI_LE_Set_Advertising_Set_Random_Address command (see Section 7.8.52).\n\n If the Host issues this command when any of advertising (created using legacy\n advertising commands), scanning, or initiating are enabled, the Controller shall return\n the error code Command Disallowed (0x0C).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Random_Address command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_random_address(p_params: *const sdc_hci_cmd_le_set_random_address_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Advertising Parameters.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.5\n\n The HCI_LE_Set_Advertising_Parameters command is used by the Host to set the\n advertising parameters.\n\n The Advertising_Interval_Min shall be less than or equal to the\n Advertising_Interval_Max. The Advertising_Interval_Min and Advertising_Interval_Max\n should not be the same value to enable the Controller to determine the best advertising\n interval given other activities.\n\n For high duty cycle directed advertising, i.e. when Advertising_Type is\n 0x01 (ADV_DIRECT_IND, high duty cycle), the Advertising_Interval_Min and\n Advertising_Interval_Max parameters are not used and shall be ignored.\n\n The Advertising_Type is used to determine the packet type that is used for advertising\n when advertising is enabled.\n\n Own_Address_Type parameter indicates the type of address being used in the\n advertising packets.\n\n If Own_Address_Type equals 0x02 or 0x03, the Peer_Address parameter contains\n the peers Identity Address and the Peer_Address_Type parameter contains the\n Peers Identity Type (i.e. 0x00 or 0x01). These parameters are used to locate the\n corresponding local IRK in the resolving list; this IRK is used to generate the own\n address used in the advertisement.\n\n If directed advertising is performed, i.e. when Advertising_Type is set to 0x01\n (ADV_DIRECT_IND, high duty cycle) or 0x04 (ADV_DIRECT_IND, low duty cycle\n mode), then the Peer_Address_Type and Peer_Address shall be valid.\n\n If Own_Address_Type equals 0x02 or 0x03, the Controller generates the peers\n Resolvable Private Address using the peers IRK corresponding to the peers Identity\n Address contained in the Peer_Address parameter and peers Identity Address Type\n (i.e. 0x00 or 0x01) contained in the Peer_Address_Type parameter.\n\n The Advertising_Channel_Map is a bit field that indicates the advertising channel\n indices that shall be used when transmitting advertising packets. At least one channel\n bit shall be set in the Advertising_Channel_Map parameter.\n\n The Advertising_Filter_Policy parameter shall be ignored when directed advertising is\n enabled.\n\n The Host shall not issue this command when advertising is enabled in the Controller; if it\n is the Command Disallowed error code shall be used.\n\n If the advertising interval range provided by the Host (Advertising_Interval_Min,\n Advertising_Interval_Max) does not overlap with the advertising interval range\n supported by the Controller, then the Controller shall return the Unsupported Feature\n or Parameter Value (0x11) error code.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Advertising_Parameters command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_adv_params(p_params: *const sdc_hci_cmd_le_set_adv_params_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Read Advertising Physical Channel Tx Power.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.6\n\n The HCI_LE_Read_Advertising_Physical_Channel_Tx_Power command is used by the\n Host to read the transmit power level used for LE advertising physical channel packets.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_Advertising_Physical_Channel_Tx_Power command has\n completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_adv_physical_channel_tx_power(
        p_return: *mut sdc_hci_cmd_le_read_adv_physical_channel_tx_power_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Advertising Data.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.7\n\n The HCI_LE_Set_Advertising_Data command is used to set the data used in\n advertising packets that have a data field.\n\n Only the significant part of the Advertising_Data should be transmitted in the advertising\n packets, as defined in 3] Part C, Section 11.\n\n If advertising is currently enabled, the Controller shall use the new data in subsequent\n advertising events. If an advertising event is in progress when this command is issued,\n the Controller may use the old or new data for that event. If advertising is currently\n disabled, the data shall be kept by the Controller and used once advertising is enabled.\n\n The default Advertising_Data_Length shall be zero and the default Advertising_Data\n shall be 31 all-zero octets.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Advertising_Data command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_adv_data(p_params: *const sdc_hci_cmd_le_set_adv_data_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Scan Response Data.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.8\n\n This command is used to provide data used in Scanning Packets that have a data field.\n\n Only the significant part of the Scan_Response_Data should be transmitted in the\n Scanning Packets, as defined in 3] Part C, Section 11.\n\n If advertising is currently enabled, the Controller shall use the new data in subsequent\n advertising events. If an advertising event is in progress when this command is issued,\n the Controller may use the old or new data for that event. If advertising is currently\n disabled, the data shall be kept by the Controller and used once advertising is enabled.\n\n The default Scan_Response_Data_Length shall be zero and the default\n Scan_Response_Data shall be 31 all-zero octets.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Scan_Response_Data command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_scan_response_data(p_params: *const sdc_hci_cmd_le_set_scan_response_data_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Advertising Enable.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.9\n\n The HCI_LE_Set_Advertising_Enable command is used to request the Controller\n to start or stop advertising. The Controller manages the timing of advertisements\n as per the advertising parameters given in the HCI_LE_Set_Advertising_Parameters\n command.\n\n The Controller shall continue advertising until the Host issues an\n HCI_LE_Set_Advertising_Enable command with Advertising_Enable set to 0x00\n (Advertising is disabled). a connection is created using the advertising, or the\n Advertising is timed out due to high duty cycle Directed Advertising. In these cases,\n advertising is then disabled.\n\n If Advertising_Enable is set to 0x01, the advertising parameters' Own_Address_Type\n parameter is set to 0x00, and the device does not have a public address, the Controller\n should return an error code which should be Invalid HCI Command Parameters (0x12).\n\n If Advertising_Enable is set to 0x01, the advertising parameters' Own_Address_Type\n parameter is set to 0x01, and the random address for the device has not been initialized\n using the HCI_LE_Set_Random_Address command, the Controller shall return the error\n code Invalid HCI Command Parameters (0x12).\n\n If Advertising_Enable is set to 0x01, the advertising parameters' Own_Address_Type\n parameter is set to 0x02, the Controller's resolving list did not contain a matching entry,\n and the device does not have a public address, the Controller should return an error\n code which should be Invalid HCI Command Parameters (0x12).\n\n If Advertising_Enable is set to 0x01, the advertising parameters' Own_Address_Type\n parameter is set to 0x03, the Controller's resolving list did not contain a matching\n entry, and the random address for the device has not been initialized using the\n HCI_LE_Set_Random_Address command, the Controller shall return the error code\n Invalid HCI Command Parameters.(0x12).\n\n Enabling advertising when it is already enabled can cause the random address to\n change. Disabling advertising when it is already disabled has no effect.\n\n\n 1This command was formerly called LE Set Advertise Enable.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Advertising_Enable command has completed, an\n HCI_Command_Complete event shall be generated.\n\n If the Advertising_Type parameter is 0x01 (ADV_DIRECT_IND, high duty cycle) and\n the directed advertising fails to create a connection, an HCI_LE_Connection_Complete\n or HCI_LE_Enhanced_Connection_Complete event shall be generated with the Status\n code set to Advertising Timeout (0x3C).\n\n If the Advertising_Type parameter is 0x00 (ADV_IND), 0x01 (ADV_DIRECT_IND, high\n duty cycle), or 0x04 (ADV_DIRECT_IND, low duty cycle) and a connection is created,\n an HCI_LE_Connection_Complete or HCI_LE_Enhanced_Connection_Complete event\n shall be generated.\n\n Note: There is a possible race condition if the Advertising_Enable parameter is set\n to 0x00 (Disable) and the Advertising_Type parameter is 0x00, 0x01, or 0x04. The\n advertisements might not be stopped before a connection is created, and therefore\n both the HCI_Command_Complete event and either an HCI_LE_Connection_Complete\n event or an HCI_LE_Enhanced_Connection_Complete event could be generated. This\n can also occur when high duty cycle directed advertising is timed out and this command\n disables advertising.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_adv_enable(p_params: *const sdc_hci_cmd_le_set_adv_enable_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Scan Parameters.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.10\n\n The HCI_LE_Set_Scan_Parameters command is used to set the scan parameters.\n\n The LE_Scan_Type parameter controls the type of scan to perform.\n\n The LE_Scan_Interval and LE_Scan_Window parameters are recommendations from\n the Host on how long (LE_Scan_Window) and how frequently (LE_Scan_Interval) the\n Controller should scan (See 6] Part B, Section 4.4.3). The LE_Scan_Window\n parameter shall always be set to a value smaller or equal to the value set for the\n LE_Scan_Interval parameter. If they are set to the same value scanning should be run\n continuously.\n\n Own_Address_Type parameter indicates the type of address being used in the scan\n request packets.\n\n The Host shall not issue this command when scanning is enabled in the Controller; if it\n is the Command Disallowed error code shall be used.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Scan_Parameters command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_scan_params(p_params: *const sdc_hci_cmd_le_set_scan_params_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Scan Enable.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.11\n\n The HCI_LE_Set_Scan_Enable command is used to start and stop scanning for legacy\n PDUs (but not extended PDUs, even if the device supports extended advertising).\n Scanning is used to discover advertising devices nearby.\n\n The Filter_Duplicates parameter controls whether the Link Layer should filter out\n duplicate advertising reports (Filtering_Enabled) to the Host, or if the Link Layer should\n generate advertising reports for each packet received (Filtering_Disabled). See 6]\n Part B, Section 4.4.3.5. If LE_Scan_Enable is set to 0x00 then Filter_Duplicates shall be\n ignored.\n\n If LE_Scan_Enable is set to 0x01, the scanning parameters' Own_Address_Type\n parameter is set to 0x00 or 0x02, and the device does not have a public address,\n the Controller should return an error code which should be Invalid HCI Command\n Parameters (0x12).\n\n If LE_Scan_Enable is set to 0x01, the scanning parameters' Own_Address_Type\n parameter is set to 0x01 or 0x03, and the random address for the device has not\n been initialized using the HCI_LE_Set_Random_Address command, the Controller shall\n return the error code Invalid HCI Command Parameters (0x12).\n\n If the LE_Scan_Enable parameter is set to 0x01 and scanning is already enabled, any\n change to the Filter_Duplicates setting shall take effect.\n\n Disabling scanning when it is disabled has no effect.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Scan_Enable command has completed, an\n HCI_Command_Complete event shall be generated.\n\n Zero or more HCI_LE_Advertising_Report events are generated by the Controller based\n on legacy advertising packets received and the duplicate filtering. More than one\n advertising packet may be reported in each HCI_LE_Advertising_Report event. No\n report shall be issued for extended advertising PDUs.\n\n When the Scanning_Filter_Policy is set to 0x02 or 0x03 (see Section 7.8.10)\n and a directed advertisement was received where the advertiser used a\n resolvable private address which the Controller is unable to resolve, an\n HCI_LE_Directed_Advertising_Report event shall be generated instead of an\n HCI_LE_Advertising_Report event.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_scan_enable(p_params: *const sdc_hci_cmd_le_set_scan_enable_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Create Connection.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.12\n\n The HCI_LE_Create_Connection command is used to create an ACL connection, with\n the local device in the Central role, to a connectable advertiser.\n\n If a connection is created with the local device in the Peripheral role while this command\n is pending, then this command remains pending.\n\n The LE_Scan_Interval and LE_Scan_Window parameters are recommendations from\n the Host on how long (LE_Scan_Window) and how frequently (LE_Scan_Interval) the\n Controller should scan. The LE_Scan_Window parameter shall be set to a value smaller\n or equal to the value set for the LE_Scan_Interval parameter. If both are set to the same\n value, scanning should run continuously.\n\n The Initiator_Filter_Policy is used to determine whether the Filter Accept List is used.\n If the Filter Accept List is not used, the Peer_Address_Type and the Peer_Address\n parameters specify the address type and address of the advertising device to connect\n to.\n\n Peer_Address_Type parameter indicates the type of address used in the connectable\n advertisement sent by the peer. The Host shall not set Peer_Address_Type\n to either 0x02 or 0x03 if both the Host and the Controller support\n the HCI_LE_Set_Privacy_Mode command. If a Controller that supports the\n HCI_LE_Set_Privacy_Mode command receives the HCI_LE_Create_Connection\n command with Peer_Address_Type set to either 0x02 or 0x03, it may use either device\n privacy mode or network privacy mode for that peer device.\n Peer_Address parameter indicates the Peers Public Device Address, Random (static)\n Device Address, Non-Resolvable Private Address or Resolvable Private Address\n depending on the Peer_Address_Type parameter.\n\n Own_Address_Type parameter indicates the type of address being used in the\n connection request packets.\n\n The Connection_Interval_Min and Connection_Interval_Max parameters define the\n minimum and maximum allowed connection interval. The Connection_Interval_Min\n parameter shall not be greater than the Connection_Interval_Max parameter.\n\n The Max_Latency parameter defines the maximum allowed Peripheral latency (see 6] Part B, Section 4.5.1).\n\n The Supervision_Timeout parameter defines the link supervision timeout for the\n connection. The Supervision_Timeout in milliseconds shall be larger than (1 +\n Max_Latency)  Connection_Interval_Max  2, where Connection_Interval_Max is\n given in milliseconds. (See 6] Part B, Section 4.5.2).\n\n The Min_CE_Length and Max_CE_Length parameters provide the Controller with the\n expected minimum and maximum length of the connection events. The Min_CE_Length\n parameter shall be less than or equal to the Max_CE_Length parameter. The Controller\n is not required to use these values.\n\n If the Host issues this command when another HCI_LE_Create_Connection command\n is pending in the Controller, the Controller shall return the error code Command\n Disallowed (0x0C).\n\n If the local device is already connected to the same device address as the advertiser\n (including two different Resolvable Private Addresses that resolve to the same IRK),\n then the Controller shall return an error which should use the error code Connection\n Already Exists (0x0B).\n\n If the Own_Address_Type parameter is set to 0x00 and the device does not have a\n public address, the Controller should return an error code which should be Invalid HCI\n Command Parameters (0x12).\n\n If the Own_Address_Type parameter is set to 0x01 and the random address for the\n device has not been initialized using the HCI_LE_Set_Random_Address command, the\n Controller shall return the error code Invalid HCI Command Parameters (0x12).\n\n If the Own_Address_Type parameter is set to 0x02, the Initiator_Filter_Policy parameter\n is set to 0x00, the Controller's resolving list did not contain a matching entry, and the\n device does not have a public address, the Controller should return an error code which\n should be Invalid HCI Command Parameters (0x12).\n If the Own_Address_Type parameter is set to 0x02, the Initiator_Filter_Policy parameter\n is set to 0x01, and the device does not have a public address, the Controller should\n return an error code which should be Invalid HCI Command Parameters (0x12).\n\n If the Own_Address_Type parameter is set to 0x03, the Initiator_Filter_Policy\n parameter is set to 0x00, the Controller's resolving list did not contain a matching\n entry, and the random address for the device has not been initialized using the\n HCI_LE_Set_Random_Address command, the Controller shall return the error code\n Invalid HCI Command Parameters (0x12).\n\n If the Own_Address_Type parameter is set to 0x03, the Initiator_Filter_Policy parameter\n is set to 0x01, and the random address for the device has not been initialized using\n the HCI_LE_Set_Random_Address command, the Controller shall return the error code\n Invalid HCI Command Parameters (0x12).\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_LE_Create_Connection command, the Controller\n sends the HCI_Command_Status event to the Host. An HCI_LE_Connection_Complete\n or HCI_LE_Enhanced_Connection_Complete event shall be generated when a\n connection is created because of this command or the connection creation procedure\n is cancelled; until one of these events is generated, the command is considered\n pending. If a connection is created and the Controller supports the LE Channel\n Selection Algorithm #2 feature, this event shall be immediately followed by an\n HCI_LE_Channel_Selection_Algorithm event.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_create_conn(p_params: *const sdc_hci_cmd_le_create_conn_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Create Connection Cancel.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.13\n\n The HCI_LE_Create_Connection_Cancel command is used to cancel the\n HCI_LE_Create_Connection or HCI_LE_Extended_Create_Connection commands.\n\n If no HCI_LE_Create_Connection or HCI_LE_Extended_Create_Connection command\n is pending, then the Controller shall return the error code Command Disallowed (0x0C).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Create_Connection_Cancel command has completed, an\n HCI_Command_Complete event shall be generated.\n\n If the cancellation was successful then, after the HCI_Command_Complete\n event for the HCI_LE_Create_Connection_Cancel command, either an\n HCI_LE_Connection_Complete or an HCI_LE_Enhanced_Connection_Complete event\n shall be generated. In either case, the event shall be sent with the error code Unknown\n Connection Identifier (0x02).\n\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_create_conn_cancel() -> u8;
}
unsafe extern "C" {
    #[doc = "LE Read Filter Accept List Size.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.14\n\n The HCI_LE_Read_Filter_Accept_List_Size command is used to read the total number\n of Filter Accept List entries that can be stored in the Controller.\n\n Note: The number of entries that can be stored is not fixed and the Controller can\n change it at any time (e.g. because the memory used to store the Filter Accept List can\n also be used for other purposes).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_Filter_Accept_List_Size command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_filter_accept_list_size(
        p_return: *mut sdc_hci_cmd_le_read_filter_accept_list_size_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Clear Filter Accept List.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.15\n\n The HCI_LE_Clear_Filter_Accept_List command is used to clear the Filter Accept List\n stored in the Controller.\n\n This command shall not be used when:\n\n  any advertising filter policy uses the Filter Accept List and advertising is enabled,\n  the scanning filter policy uses the Filter Accept List and scanning is enabled, or\n  the initiator filter policy uses the Filter Accept List and an HCI_LE_Create_Connection\n or HCI_LE_Extended_Create_Connection command is pending.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Clear_Filter_Accept_List command has completed, an\n HCI_Command_Complete event shall be generated.\n\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_clear_filter_accept_list() -> u8;
}
unsafe extern "C" {
    #[doc = "LE Add Device To Filter Accept List.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.16\n\n The HCI_LE_Add_Device_To_Filter_Accept_List command is used to add a single\n device to the Filter Accept List stored in the Controller.\n\n This command shall not be used when:\n\n  any advertising filter policy uses the Filter Accept List and advertising is enabled,\n  the scanning filter policy uses the Filter Accept List and scanning is enabled, or\n  the initiator filter policy uses the Filter Accept List and an HCI_LE_Create_Connection\n or HCI_LE_Extended_Create_Connection command is pending.\n\n When a Controller cannot add a device to the Filter Accept List because there is no\n space available, it shall return the error code Memory Capacity Exceeded (0x07).\n\n If the device is already in the Filter Accept List, the Controller should not add the device\n to the Filter Accept List again and should return success.\n\n Address shall be ignored when Address_Type is set to 0xFF.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Add_Device_To_Filter_Accept_List command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_add_device_to_filter_accept_list(
        p_params: *const sdc_hci_cmd_le_add_device_to_filter_accept_list_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Remove Device From Filter Accept List.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.17\n\n The HCI_LE_Remove_Device_From_Filter_Accept_List command is used to remove a\n single device from the Filter Accept List stored in the Controller.\n\n This command shall not be used when:\n\n  any advertising filter policy uses the Filter Accept List and advertising is enabled,\n  the scanning filter policy uses the Filter Accept List and scanning is enabled, or\n  the initiator filter policy uses the Filter Accept List and an HCI_LE_Create_Connection\n or HCI_LE_Extended_Create_Connection command is pending.\n\n Address shall be ignored when Address_Type is set to 0xFF.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Remove_Device_From_Filter_Accept_List command has\n completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_remove_device_from_filter_accept_list(
        p_params: *const sdc_hci_cmd_le_remove_device_from_filter_accept_list_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Connection Update.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.18\n\n The HCI_LE_Connection_Update command is used to change the ACL connection\n parameters. This command may be issued on both the Central and Peripheral.\n\n The Connection_Interval_Min and Connection_Interval_Max parameters are\n used to define the minimum and maximum allowed connection interval.\n The Connection_Interval_Min parameter shall not be greater than the\n Connection_Interval_Max parameter.\n\n The Max_Latency parameter shall define the maximum allowed Peripheral latency.\n\n The Supervision_Timeout parameter shall define the link supervision timeout for the LE\n link. The Supervision_Timeout in milliseconds shall be larger than (1 + Max_Latency)\n  Subrate_Factor  Connection_Interval_Max  2, where Connection_Interval_Max is\n given in milliseconds and Subrate_Factor is the current subrate factor of the connection.\n\n The Min_CE_Length and Max_CE_Length are information parameters providing\n the Controller with a hint about the expected minimum and maximum length of\n the connection events. The Min_CE_Length shall be less than or equal to the\n Max_CE_Length.\n\n The actual parameter values selected by the Link Layer may be different from the\n parameter values provided by the Host through this command.\n\n If this command completes successfully and the connection interval has changed,\n then the subrating factor shall be set to 1 and the continuation number to 0. In this\n case, Max_Latency must be interpreted in underlying connection events. Otherwise the\n subrating factor and continuation number shall be unchanged and Max_Latency must\n be interpreted in subrated events.\n If the Host issues this command when one or more CS procedures have been enabled\n using the HCI_LE_CS_Procedure_Enable command, then the Controller shall return the\n error code Command Disallowed (0x0C).\n\n If the Host issues this command on a Connection_Handle where the Controller is the\n Peripheral and either the local or peer Controller does not support the Connection\n Parameters Request procedure (see 6] Part B, Section 5.1.7), then the Controller\n shall return an error which should use the error code Unsupported Feature or\n Parameter Value (0x11) if the local Controller does not support that procedure and\n Unsupported Remote Feature (0x1A) if the local Controller supports that procedure but\n the peer Controller does not.\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_LE_Connection_Update command,\n the Controller sends the HCI_Command_Status event to the Host. The\n HCI_LE_Connection_Update_Complete event shall be generated after the connection\n parameters have been applied by the Controller or if the command subsequently fails.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_conn_update(p_params: *const sdc_hci_cmd_le_conn_update_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Host Channel Classification.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.19\n\n The HCI_LE_Set_Host_Channel_Classification command allows the Host to specify a\n channel classification for the data, secondary advertising, periodic, and isochronous\n physical channels based on its local information. This classification persists until\n overwritten with a subsequent HCI_LE_Set_Host_Channel_Classification command\n or until the Controller is reset using the HCI_Reset command (see 6] Part B,\n Section 4.5.8.1).\n\n If this command is used, the Host should send it within 10 seconds of knowing that the\n channel classification has changed. The interval between two successive commands\n sent shall be at least one second.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Host_Channel_Classification command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_host_channel_classification(
        p_params: *const sdc_hci_cmd_le_set_host_channel_classification_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Read Channel Map.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.20\n\n The HCI_LE_Read_Channel_Map command returns the current Channel_Map for\n the specified Connection_Handle. The returned value indicates the state of\n the Channel_Map specified by the last transmitted or received Channel_Map\n (in a CONNECT_IND or LL_CHANNEL_MAP_IND message) for the specified\n Connection_Handle, regardless of whether the Central has received an\n acknowledgment. If the connection handle does not identify an ACL connection,\n the Controller shall reject the command and should return the error code Unknown\n Connection Identifier (0x02).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_Channel_Map command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_channel_map(
        p_params: *const sdc_hci_cmd_le_read_channel_map_t,
        p_return: *mut sdc_hci_cmd_le_read_channel_map_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Read Remote Features.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.21\n\n This command requests, from the remote device identified by the Connection_Handle,\n page 0 of the features used on the connection and the features supported by the remote\n device. For details see 6] Part B, Section 4.6.\n\n This command may be issued on both the Central and Peripheral.\n\n If a connection already exists between the two devices and page 0 of the features have\n already been fetched on that connection, the Controller may use a cached copy of page\n 0 of the features.\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_LE_Read_Remote_Features_Page_0 command,\n the Controller shall send the HCI_Command_Status event to the Host. When the\n Controller has completed the procedure to determine the remote features or has\n determined that it will be using a cached copy, the Controller shall send an\n HCI_LE_Read_Remote_Features_Page_0_Complete event to the Host.\n\n The HCI_LE_Read_Remote_Features_Page_0_Complete event contains the status of\n this command and the parameter describing page 0 of the features used on the\n connection and the features supported by the remote device.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_remote_features(p_params: *const sdc_hci_cmd_le_read_remote_features_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Encrypt.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.22\n\n The HCI_LE_Encrypt command is used to request the Controller to encrypt the\n Plaintext_Data in the command using the Key given in the command and returns\n the Encrypted_Data to the Host. The AES-128 bit block cypher is defined in NIST\n Publication FIPS-197 (http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Encrypt command has completed, an HCI_Command_Complete\n event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_encrypt(
        p_params: *const sdc_hci_cmd_le_encrypt_t,
        p_return: *mut sdc_hci_cmd_le_encrypt_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Rand.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.23\n\n The HCI_LE_Rand command is used to request the Controller to generate 8 octets of\n random data to be sent to the Host. The Random_Number shall be generated according\n to 2] Part H, Section 2.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Rand command has completed, an HCI_Command_Complete event\n shall be generated.\n\n # Arguments\n\n* `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_rand(p_return: *mut sdc_hci_cmd_le_rand_return_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Enable Encryption.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.24\n\n The HCI_LE_Enable_Encryption command is used to authenticate the given encryption\n key associated with the remote device specified by the Connection_Handle, and once\n authenticated will encrypt the connection. The parameters are as defined in 3] Part\n H, Section 2.4.4.\n\n If the connection is already encrypted then the Controller shall pause connection\n encryption before attempting to authenticate the given encryption key, and then re-\n encrypt the connection. While encryption is paused no user data shall be transmitted.\n\n If the Connection_Handle parameter identifies an ACL with an associated CIS that has\n been created, the Controller shall return the error code Command Disallowed (0x0C).\n\n On an authentication failure, the connection shall be automatically disconnected by the\n Link Layer. If this command succeeds, then the connection shall be encrypted.\n\n This command shall only be used when the local devices role is Central.\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_LE_Enable_Encryption command it shall send\n the HCI_Command_Status event to the Host. If the connection is not encrypted\n when this command is issued, an HCI_Encryption_Change event shall occur when\n encryption has been started for the connection. If the connection is encrypted when\n this command is issued, an HCI_Encryption_Key_Refresh_Complete event shall occur\n when encryption has been resumed.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_enable_encryption(p_params: *const sdc_hci_cmd_le_enable_encryption_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Long Term Key Request Reply.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.25\n\n The HCI_LE_Long_Term_Key_Request_Reply command is used to reply to an\n HCI_LE_Long_Term_Key_Request event from the Controller, and specifies the\n Long_Term_Key parameter that shall be used for this Connection_Handle. The\n Long_Term_Key is used as defined in 6] Part B, Section 5.1.3.\n\n This command shall only be used when the local devices role is Peripheral.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Long_Term_Key_Request_Reply command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_long_term_key_request_reply(
        p_params: *const sdc_hci_cmd_le_long_term_key_request_reply_t,
        p_return: *mut sdc_hci_cmd_le_long_term_key_request_reply_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Long Term Key Request Negative Reply.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.26\n\n The HCI_LE_Long_Term_Key_Request_Negative_Reply command is used to reply to\n an HCI_LE_Long_Term_Key_Request event from the Controller if the Host cannot\n provide a Long Term Key for this Connection_Handle.\n\n This command shall only be used when the local devices role is Peripheral.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Long_Term_Key_Request_Negative_Reply command has\n completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_long_term_key_request_negative_reply(
        p_params: *const sdc_hci_cmd_le_long_term_key_request_negative_reply_t,
        p_return: *mut sdc_hci_cmd_le_long_term_key_request_negative_reply_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Read Supported States.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.27\n\n The HCI_LE_Read_Supported_States command reads the states, roles, and\n combinations of states and roles that the Link Layer supports. See 6] Part B,\n Section 1.1.1.\n\n The LE_States parameter is a bit field. If a bit is set to 1 then this state, role, or\n combination is supported by the Controller; each combination consists of the states\n indicated by 'X' in the associated row of the table and excludes those states with an\n empty cell in that row. Multiple bits in LE_States may be set to 1 to indicate support for\n multiple combinations.\n\n Note: This command only provides information about the supported states and roles\n that can be used with legacy advertising. It does not provide information about those\n that can only be used with the extended advertising commands (see Section 3.1.1).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_Supported_States command has completed, an\n HCI_Command_Complete event will be generated.\n\n # Arguments\n\n* `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_supported_states(p_return: *mut sdc_hci_cmd_le_read_supported_states_return_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Data Length.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.33\n\n The HCI_LE_Set_Data_Length command allows the Host to suggest the maximum\n transmission payload size and maximum packet transmission time (connMaxTxOctets\n and connMaxTxTime - see 6] Part B, Section 4.5.10) to be used for LL Data PDUs\n on a given connection. The Controller may use smaller or larger values based on local\n information.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Data_Length command has completed, an\n HCI_Command_Complete event shall be generated.\n\n If the command causes the maximum transmission packet size or maximum packet\n transmission time to change, an HCI_LE_Data_Length_Change event shall be\n generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_data_length(
        p_params: *const sdc_hci_cmd_le_set_data_length_t,
        p_return: *mut sdc_hci_cmd_le_set_data_length_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Read Suggested Default Data Length.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.34\n\n The HCI_LE_Read_Suggested_Default_Data_Length command allows the Host\n to read the Host's suggested values (Suggested_Max_TX_Octets and\n Suggested_Max_TX_Time) for the Controller's maximum transmitted number of payload\n octets and maximum packet transmission time for packets containing LL Data PDUs to\n be used for new connections (see 6] Part B, Section 4.5.10).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_Suggested_Default_Data_Length command has completed,\n an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_suggested_default_data_length(
        p_return: *mut sdc_hci_cmd_le_read_suggested_default_data_length_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Write Suggested Default Data Length.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.35\n\n The HCI_LE_Write_Suggested_Default_Data_Length command allows the Host to\n specify its suggested values for the Controller's maximum transmission number of\n payload octets and maximum packet transmission time for packets containing LL Data\n PDUs to be used for new connections. The Controller may use smaller or larger values\n for connInitialMaxTxOctets and connInitialMaxTxTime based on local information. (See\n 6] Part B, Section 4.5.10).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Write_Suggested_Default_Data_Length command has completed,\n an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_write_suggested_default_data_length(
        p_params: *const sdc_hci_cmd_le_write_suggested_default_data_length_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Add Device To Resolving List.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.38\n\n The HCI_LE_Add_Device_To_Resolving_List command is used to add one device to\n the resolving list used to generate and resolve Resolvable Private Addresses in the\n Controller.\n\n This command shall not be used when address resolution is enabled in the Controller\n and:\n\n  Advertising (other than periodic advertising) is enabled,\n  Scanning is enabled, or\n  an HCI_LE_Create_Connection, HCI_LE_Extended_Create_Connection, or\n HCI_LE_Periodic_Advertising_Create_Sync command is pending.\n\n This command may be used at any time when address resolution is disabled in the\n Controller.\n\n The added device shall be set to Network Privacy mode.\n\n If Peer_Identity_Address_Type is 0x01 and Peer_Identity_Address is not a static\n address, then the Controller should return the error code Invalid HCI Command\n Parameters (0x12).\n\n When a Controller cannot add a device to the list because there is no space available, it\n shall return the error code Memory Capacity Exceeded (0x07).\n\n If an entry already exists in the resolving list with the same four parameter values, the\n Controller shall either reject the command or not add the device to the resolving list\n again and return success. If the command is rejected then the error code Invalid HCI\n Command Parameters (0x12) should be used.\n\n If there is an existing entry in the resolving list with the same Peer_Identity_Address\n and Peer_Identity_Address_Type, or with the same non-zero Peer_IRK, the Controller\n should return the error code Invalid HCI Command Parameters (0x12).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Add_Device_To_Resolving_List command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_add_device_to_resolving_list(
        p_params: *const sdc_hci_cmd_le_add_device_to_resolving_list_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Remove Device From Resolving List.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.39\n\n The HCI_LE_Remove_Device_From_Resolving_List command is used to remove one\n device from the resolving list used to resolve Resolvable Private Addresses in the\n Controller.\n\n This command shall not be used when address resolution is enabled in the Controller\n and:\n\n  Advertising (other than periodic advertising) is enabled,\n  Scanning is enabled, or\n  an HCI_LE_Create_Connection, HCI_LE_Extended_Create_Connection, or\n HCI_LE_Periodic_Advertising_Create_Sync command is pending.\n\n This command may be used at any time when address resolution is disabled in the\n Controller.\n\n When a Controller cannot remove a device from the resolving list because it is not\n found, it shall return the error code Unknown Connection Identifier (0x02).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Remove_Device_From_Resolving_List command has completed,\n an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_remove_device_from_resolving_list(
        p_params: *const sdc_hci_cmd_le_remove_device_from_resolving_list_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Clear Resolving List.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.40\n\n The HCI_LE_Clear_Resolving_List command is used to remove all devices from the\n resolving list used to resolve Resolvable Private Addresses in the Controller.\n\n This command shall not be used when address resolution is enabled in the Controller\n and:\n\n  Advertising (other than periodic advertising) is enabled,\n  Scanning is enabled, or\n  an HCI_LE_Create_Connection, HCI_LE_Extended_Create_Connection, or\n HCI_LE_Periodic_Advertising_Create_Sync command is pending.\n\n This command may be used at any time when address resolution is disabled in the\n Controller.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Clear_Resolving_List command has completed, an\n HCI_Command_Complete event shall be generated.\n\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_clear_resolving_list() -> u8;
}
unsafe extern "C" {
    #[doc = "LE Read Resolving List Size.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.41\n\n The HCI_LE_Read_Resolving_List_Size command is used to read the total number of\n entries in the resolving list that can be stored in the Controller.\n\n Note: The number of entries that can be stored is not fixed and the Controller can\n change it at any time (e.g. because the memory used to store the list can also be used\n for other purposes).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_Resolving_List_Size command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_resolving_list_size(
        p_return: *mut sdc_hci_cmd_le_read_resolving_list_size_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Address Resolution Enable.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.44\n\n The HCI_LE_Set_Address_Resolution_Enable command is used to enable resolution\n of Resolvable Private Addresses in the Controller. This causes the Controller to use\n the resolving list whenever the Controller receives a local or peer Resolvable Private\n Address.\n\n This command shall not be used when:\n\n  Advertising (other than periodic advertising) is enabled,\n  Scanning is enabled, or\n  an HCI_LE_Create_Connection, HCI_LE_Extended_Create_Connection, or\n HCI_LE_Periodic_Advertising_Create_Sync command is pending.\n\n Enabling address resolution when it is already enabled, or disabling it when it is already\n disabled, has no effect.\n\n The requirements in 6] Part B, Section 6 related to the generation of Resolvable\n Private Addresses and the privacy of the device are independent of this command.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Address_Resolution_Enable command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_address_resolution_enable(
        p_params: *const sdc_hci_cmd_le_set_address_resolution_enable_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Resolvable Private Address Timeout.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.45\n\n The HCI_LE_Set_Resolvable_Private_Address_Timeout command set the length of\n time the Controller uses a Resolvable Private Address before a new resolvable private\n address is generated and starts being used.\n\n This timeout applies to all resolvable private addresses generated by the Controller.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Resolvable_Private_Address_Timeout command has\n completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_resolvable_private_address_timeout(
        p_params: *const sdc_hci_cmd_le_set_resolvable_private_address_timeout_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Read Maximum Data Length.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.46\n\n The HCI_LE_Read_Maximum_Data_Length command allows the Host to read the\n Controllers maximum supported payload octets and packet duration times for\n transmission and reception (Supported_Max_TX_Octets, Supported_Max_TX_Time,\n Supported_Max_RX_Octets, and Supported_Max_RX_Time, see 6] Part B,\n Section 4.5.10).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_Maximum_Data_Length command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_max_data_length(p_return: *mut sdc_hci_cmd_le_read_max_data_length_return_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Read PHY.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.47\n\n The HCI_LE_Read_PHY command is used to read the current transmitter PHY and\n receiver PHY on the connection identified by the Connection_Handle.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_PHY command has completed, an HCI_Command_Complete\n event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_phy(
        p_params: *const sdc_hci_cmd_le_read_phy_t,
        p_return: *mut sdc_hci_cmd_le_read_phy_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Default PHY.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.48\n\n The HCI_LE_Set_Default_PHY command allows the Host to specify its preferred values\n for the transmitter PHY and receiver PHY to be used for all subsequent connections\n over the LE transport.\n\n The All_PHYs parameter is a bit field that allows the Host to specify, for each direction,\n whether it has no preference among the PHYs that the Controller supports in a given\n direction or whether it has specified particular PHYs that it prefers in the TX_PHYs or\n RX_PHYs parameter.\n\n The TX_PHYs parameter is a bit field that indicates the transmitter PHYs that the Host\n prefers the Controller to use. If the All_PHYs parameter specifies that the Host has no\n preference, the TX_PHYs parameter shall be ignored; otherwise at least one bit shall be\n set to 1.\n\n The RX_PHYs parameter is a bit field that indicates the receiver PHYs that the Host\n prefers the Controller to use. If the All_PHYs parameter specifies that the Host has no\n preference, the RX_PHYs parameter shall be ignored; otherwise at least one bit shall\n be set to 1.\n\n If the Host sets, in the TX_PHYs or RX_PHYs parameter, a bit for a PHY that the\n Controller does not support, including a bit that is reserved for future use, the Controller\n shall return the error code Unsupported Feature or Parameter Value (0x11).\n\n If the Controller does not support asymmetric connections (see 6] Part B,\n Section 4.6.9.1) and the Host sets All_PHYs to 0x00 and TX_PHYs to a different\n value than RX_PHYs, the Controller shall return the error code Unsupported Feature or\n Parameter Value (0x11).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Default_PHY command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_default_phy(p_params: *const sdc_hci_cmd_le_set_default_phy_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set PHY.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.49\n\n The HCI_LE_Set_PHY command is used to set the PHY preferences for the connection\n identified by the Connection_Handle. The Controller might not be able to make the\n change (e.g. because the peer does not support the requested PHY) or may decide that\n the current PHY is preferable (e.g., because it could not schedule other activities if the\n requested PHY was used or because it requires a PHY that supports Constant Tone\n Extensions).\n\n The All_PHYs parameter is a bit field that allows the Host to specify, for each direction,\n whether it has no preference among the PHYs that the Controller supports in a given\n direction or whether it has specified particular PHYs that it prefers in the TX_PHYs or\n RX_PHYs parameter.\n\n The TX_PHYs parameter is a bit field that indicates the transmitter PHYs that the Host\n prefers the Controller to use. If the All_PHYs parameter specifies that the Host has no\n preference, the TX_PHYs parameter shall be ignored; otherwise at least one bit shall be\n set to 1.\n\n The RX_PHYs parameter is a bit field that indicates the receiver PHYs that the Host\n prefers the Controller to use. If the All_PHYs parameter specifies that the Host has no\n preference, the RX_PHYs parameter shall be ignored; otherwise at least one bit shall\n be set to 1.\n\n The Controller shall request a change unless it determines that this is unnecessary or\n that the current PHY is preferable, in which case it may, but need not, request a change.\n\n The PHY preferences provided by the HCI_LE_Set_PHY command override those\n provided via the HCI_LE_Set_Default_PHY command (Section 7.8.48) or any\n preferences previously set using the HCI_LE_Set_PHY command on the same\n connection.\n\n The PHY_Options parameter is a bit field that allows the Host to specify options for\n PHYs. The default value for a new connection shall be all zero bits. The Controller may\n override any preferred coding for transmitting on the LE Coded PHY.\n The Host may specify a preferred coding even if it prefers not to use the LE Coded\n transmitter PHY since the Controller may override the PHY preference.\n\n If the Host sets, in the TX_PHYs or RX_PHYs parameter, a bit for a PHY that the\n Controller does not support, including a bit that is reserved for future use, the Controller\n shall return the error code Unsupported Feature or Parameter Value (0x11).\n\n If the Controller does not support asymmetric connections (see 6] Part B,\n Section 4.6.9.1) and the Host sets All_PHYs to 0x00 and TX_PHYs to a different\n value than RX_PHYs, the Controller shall return the error code Unsupported Feature or\n Parameter Value (0x11).\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_LE_Set_PHY command, the\n Controller shall send the HCI_Command_Status event to the Host. The\n HCI_LE_PHY_Update_Complete event shall be generated either when one or both\n PHY changes or when the Controller determines that neither PHY will change\n immediately.\n\n Note: If the peer negotiation resulted in no change to either PHY, this is not an error and\n the HCI_LE_PHY_Update_Complete event will contain a status indicating success.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_phy(p_params: *const sdc_hci_cmd_le_set_phy_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Advertising Set Random Address.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.52\n\n The HCI_LE_Set_Advertising_Set_Random_Address command is used by the Host\n to set the random device address specified by the Random_Address parameter. This\n address is used in the Controller (see 6] Part B, Section 1.3.2 ) for the advertiser's\n address contained in the advertising PDUs for the advertising set specified by the\n Advertising_Handle parameter.\n\n This command may be issued at any time after an advertising set\n identified by the Advertising_Handle parameter has been created using the\n HCI_LE_Set_Extended_Advertising_Parameters command (see Section 7.8.53).\n However, if the Host issues this command while the advertising set identified by the\n Advertising_Handle parameter is using connectable advertising and is enabled, the\n Controller shall return the error code Command Disallowed (0x0C).\n\n If this command is used to change the address, the new random\n address shall take effect for advertising no later than the next successful\n HCI_LE_Set_Extended_Advertising_Enable command and for periodic advertising no\n later than the next successful HCI_LE_Periodic_Advertising_Enable command.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Advertising_Set_Random_Address command has completed,\n an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_adv_set_random_address(
        p_params: *const sdc_hci_cmd_le_set_adv_set_random_address_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Extended Advertising Parameters The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.53\n\n The HCI_LE_Set_Extended_Advertising_Parameters command is used by the Host to\n set the advertising parameters.\n The Advertising_Handle parameter identifies the advertising set whose parameters are\n being configured.\n\n The Advertising_Event_Properties parameter describes the type of advertising event\n that is being configured and its basic properties. The type shall be one supported by the\n Controller. In particular, the following restrictions apply to this parameter:\n\n  If legacy advertising PDU types are being used, then the parameter value shall be\n one of those specified in Table 7.3. If the advertising set already contains data, the\n type shall be one that supports advertising data and the amount of data shall not\n exceed 31 octets.\n\n Advertising\n Event Advertising\n Event Type PDU Type Properties Data\n\n Connectable and scannable ADV_IND 0b00010011 Supported\n undirected\n\n Connectable directed ADV_DIRECT_IND 0b00010101 Not allowed\n (low duty cycle)\n\n Connectable directed ADV_DIRECT_IND 0b00011101 Not allowed\n (high duty cycle)\n\n Scannable undirected ADV_SCAN_IND 0b00010010 Supported\n\n Non-connectable and non- ADV_NONCONN_IND 0b00010000 Supported\n scannable undirected\n\n Table 7.3: Advertising_Event_Properties values for legacy PDUs\n\n  If extended advertising PDU types are being used (bit 4 = 0), then the advertisement\n shall not be both connectable and scannable (bits 0 and 1 must not both be set to 1)\n and high duty cycle directed connectable advertising ( 3.75 ms advertising interval)\n shall not be used (bit 3 = 0).\n\n If the Advertising_Event_Properties parameter does not describe an event type\n supported by the Controller, contains an invalid bit combination, or specifies a type\n that does not support advertising data when the advertising set already contains some,\n the Controller shall return the error code Invalid HCI Command Parameters (0x12).\n\n The Own_Address_Type parameter shall be ignored for undirected anonymous\n advertising (bit 2 = 0 and bit 5 = 1).\n\n If Directed advertising is selected, the Peer_Address_Type and Peer_Address shall be\n valid and the Advertising_Filter_Policy parameter shall be ignored.\n\n The Primary_Advertising_Interval_Min parameter shall be less than or equal to the\n Primary_Advertising_Interval_Max parameter. The Primary_Advertising_Interval_Min\n and Primary_Advertising_Interval_Max parameters should not be the same value so\n that the Controller can choose the best advertising interval given other activities.\n\n For high duty cycle connectable directed advertising event type (ADV_DIRECT_IND),\n the Primary_Advertising_Interval_Min and Primary_Advertising_Interval_Max\n parameters are not used and shall be ignored.\n\n If the primary advertising interval range provided by the Host\n (Primary_Advertising_Interval_Min, Primary_Advertising_Interval_Max) does not\n overlap with the advertising interval range supported by the Controller, then the\n Controller shall return the error code Unsupported Feature or Parameter Value (0x11).\n\n The Primary_Advertising_Channel_Map is a bit field that indicates the advertising\n channel indices that shall be used when transmitting advertising packets. At least one\n channel bit shall be set in the Primary_Advertising_Channel_Map parameter.\n\n The Own_Address_Type parameter specifies the type of address being used in\n the advertising packets. For random addresses, the address is specified by the\n HCI_LE_Set_Advertising_Set_Random_Address command.\n\n If Own_Address_Type equals 0x02 or 0x03, the Peer_Address parameter contains\n the peers Identity Address and the Peer_Address_Type parameter contains the\n peers Identity Type (i.e., 0x00 or 0x01). These parameters are used to locate the\n corresponding local IRK in the resolving list; this IRK is used to generate their own\n address used in the advertisement.\n\n The Advertising_TX_Power parameter indicates the maximum power level at which the\n advertising packets are to be transmitted on the advertising physical channels. The\n Controller shall choose a power level lower than or equal to the one specified by the\n Host.\n\n The Primary_Advertising_PHY parameter indicates the PHY on which the advertising\n packets are transmitted on the primary advertising physical channel. If legacy\n advertising PDUs are being used, the Primary_Advertising_PHY shall indicate the LE\n 1M PHY. The Secondary_Advertising_PHY parameter indicates the PHY on which the\n advertising packets are be transmitted on the secondary advertising physical channel.\n If the Host specifies a PHY that is not supported by the Controller, including a value\n that is reserved for future use, it should return the error code Unsupported Feature or\n Parameter Value (0x11). If Constant Tone Extensions are enabled for the advertising set\n and Secondary_Advertising_PHY specifies a PHY that does not allow Constant Tone\n Extensions, the Controller shall return the error code Command Disallowed (0x0C).\n\n If the Primary_Advertising_PHY indicates the LE Coded PHY, then the\n Primary_Advertising_PHY_Options shall indicate the Host's preference or requirement\n concerning coding scheme. Otherwise, Primary_Advertising_PHY_Options shall\n be ignored. If the Secondary_Advertising_PHY indicates the LE Coded PHY,\n then the Secondary_Advertising_PHY_Options shall indicate the Host's preference\n or requirement concerning coding scheme (including for periodic advertising).\n Otherwise, Secondary_Advertising_PHY_Options shall be ignored. If the Host\n specifies that it requires a specific coding (i.e., value 0x03 or 0x04) in the\n Primary_Advertising_PHY_Options or Secondary_Advertising_PHY_Options and the\n Controller supports the LE Feature (Advertising Coding Selection) but is currently\n unable to provide all the required settings, then the Controller shall return the error\n code Command Disallowed (0x0C).\n\n The Secondary_Advertising_Max_Skip parameter is the maximum number of\n advertising events that can be skipped before the AUX_ADV_IND can be sent.\n\n The Advertising_SID parameter specifies the value to be transmitted in the Advertising\n SID subfield of the ADI field of the Extended Header of those advertising physical\n channel PDUs that have an ADI field. If the advertising set only uses PDUs that do not\n contain an ADI field, Advertising_SID shall be ignored.\n\n The Scan_Request_Notification_Enable parameter indicates whether the Controller\n shall send notifications upon the receipt of a scan request PDU that is in response\n to an advertisement from the specified advertising set that contains its device address\n and is from a scanner that is allowed by the advertising filter policy.\n\n The Controller shall set the Selected_TX_Power parameter to the transmit power that\n it will use for transmitting the advertising packets for the specified advertising set. The\n Controller shall only change this value if requested by the Host. If the radiated power\n level will vary between packets (e.g., because of frequency-dependent properties of the\n transmitter) then the value should be the best estimate of the maximum power used.\n\n If the Host issues this command when advertising is enabled for the specified\n advertising set, the Controller shall return the error code Command Disallowed (0x0C).\n\n If the Host issues this command when periodic advertising is enabled for the specified\n advertising set and connectable, scannable, legacy, or anonymous advertising is\n specified, the Controller shall return the error code Invalid HCI Command Parameters\n (0x12).\n\n If periodic advertising is enabled for the advertising set and the\n Secondary_Advertising_PHY parameter does not specify the PHY currently being\n used for the periodic advertising, the Controller shall return the error code Command\n Disallowed (0x0C).\n\n If the Advertising_Handle does not identify an existing advertising set and the Controller\n is unable to support a new advertising set at present, the Controller shall return the error\n code Memory Capacity Exceeded (0x07).\n\n If the advertising set already contains advertising data or scan response data, extended\n advertising is being used, and the length of the data is greater than the maximum that\n the Controller can transmit within the longest possible auxiliary advertising segment\n consistent with the parameters, the Controller shall return the error code Packet Too\n Long (0x45). If advertising on the LE Coded PHY, the S=8 coding shall be assumed\n unless the current advertising parameters require the use of S=2 for an advertising\n physical channel, in which case the S=2 coding shall be assumed for that advertising\n physical channel.\n\n If the Controller does not support the LE Feature (Advertising Coding\n Selection) and the Host does not set both Primary_Advertising_PHY_Options and\n Secondary_Advertising_PHY_Options to zero, the Controller shall return the error code\n Unsupported Feature or Parameter Value (0x11).\n\n Missing parameters:\n\n When a version of this command is issued that does not include all the\n parameters, the following values shall be used:\n\n Parameter Value\n\n Primary_Advertising_PHY_Options 0x00\n\n Secondary_Advertising_PHY_Options 0x00\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Extended_Advertising_Parameters command has\n completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_ext_adv_params(
        p_params: *const sdc_hci_cmd_le_set_ext_adv_params_t,
        p_return: *mut sdc_hci_cmd_le_set_ext_adv_params_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Extended Advertising Data.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.54\n\n The HCI_LE_Set_Extended_Advertising_Data command is used to set the data used\n in advertising PDUs that have a data field. This command may be issued at any\n time after an advertising set identified by the Advertising_Handle parameter has\n been created using the HCI_LE_Set_Extended_Advertising_Parameters command (see\n Section 7.8.53), regardless of whether advertising in that set is enabled or disabled.\n\n If advertising is currently enabled for the specified advertising set, the Controller shall\n use the new data in subsequent extended advertising events for this advertising set.\n If an extended advertising event is in progress when this command is issued, the\n Controller may use the old or new data for that event.\n\n If advertising is currently disabled for the specified advertising set, the data shall be kept\n by the Controller and used once advertising is enabled for that set. The data shall be\n discarded when the advertising set is removed.\n\n Only the significant part of the advertising data should be transmitted in the advertising\n packets as defined in 3] Part C, Section 11.\n\n The Host may set the advertising data in one or more operations using the Operation\n parameter in the command. If the combined length of the data exceeds the capacity of\n the advertising set identified by the Advertising_Handle parameter (see Section 7.8.57\n LE Read Maximum Advertising Data Length command) or the amount of memory\n currently available, all the data shall be discarded and the Controller shall return the\n error code Memory Capacity Exceeded (0x07).\n\n If the advertising set uses extended advertising and the combined length of the data is\n greater than the maximum that the Controller can transmit within the longest possible\n auxiliary advertising segment consistent with the current parameters of the advertising\n set (using the current advertising interval if advertising is enabled), all the data shall\n be discarded and the Controller shall return the error code Packet Too Long (0x45). If\n advertising on the LE Coded PHY, the S=8 coding shall be assumed unless the current\n advertising parameters require the use of S=2 for an advertising physical channel, in\n which case the S=2 coding shall be assumed for that advertising physical channel.\n If Operation indicates the start of new data (values 0x01 or 0x03), then any existing\n partial or complete advertising data shall be discarded.\n\n If the advertising data is discarded by the command or the combined length of the data\n after the command completes is zero, the advertising set will have no advertising data.\n\n If Operation is 0x04, the behavior is the same as if the current advertising data had\n been sent again; this can be used to cause the Advertising DID value to be updated\n (see 6] Part B, Section 4.4.2.11).\n\n The Fragment_Preference parameter provides a hint to the Controller as to whether\n advertising data should be fragmented.\n\n If the advertising set specifies a type that does not support advertising data, the\n Controller shall return the error code Invalid HCI Command Parameters (0x12).\n\n If the advertising set uses legacy advertising PDUs that support advertising data and\n either Operation is not 0x03 or the Advertising_Data_Length parameter exceeds 31\n octets, the Controller shall return the error code Invalid HCI Command Parameters\n (0x12).\n\n If Operation is 0x04 and:\n\n  advertising is currently disabled for the advertising set;\n  the advertising set contains no data;\n  the advertising set uses legacy PDUs; or\n  Advertising_Data_Length is not zero;\n\n then the Controller shall return the error code Invalid HCI Command Parameters (0x12).\n\n If Operation is not 0x03 or 0x04 and Advertising_Data_Length is zero, the Controller\n shall return the error code Invalid HCI Command Parameters (0x12).\n\n If advertising is currently enabled for the specified advertising set and Operation does\n not have the value 0x03 or 0x04, the Controller shall return the error code Command\n Disallowed (0x0C).\n\n If the advertising set corresponding to the Advertising_Handle parameter does not exist,\n then the Controller shall return the error code Unknown Advertising Identifier (0x42).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Extended_Advertising_Data command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_ext_adv_data(p_params: *const sdc_hci_cmd_le_set_ext_adv_data_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Extended Scan Response Data.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.55\n\n The HCI_LE_Set_Extended_Scan_Response_Data command is used to provide scan\n response data used in scanning response PDUs. This command may be issued at\n any time after the advertising set identified by the Advertising_Handle parameter has\n been created using the HCI_LE_Set_Extended_Advertising_Parameters command (see\n Section 7.8.53) regardless of whether advertising in that set is enabled or disabled.\n\n If advertising is currently enabled for the specified advertising set, the Controller shall\n use the new data in subsequent extended advertising events for this advertising set.\n If an extended advertising event is in progress when this command is issued, the\n Controller may use the old or new data for that event.\n\n If advertising is currently disabled for the specified advertising set, the data shall be kept\n by the Controller and used once advertising is enabled for that set. The data shall be\n discarded when the advertising set is removed.\n\n Only the significant part of the scan response data should be transmitted in the\n advertising packets as defined in 3] Part C, Section 11.\n\n The Host may set the scan response data in one or more operations using the\n Operation parameter in the command. If the combined length of the data exceeds\n the capacity of the advertising set identified by the Advertising_Handle parameter (see\n Section 7.8.57 LE Read Maximum Advertising Data Length command) or the amount\n of memory currently available, all the data shall be discarded and the Controller shall\n return the error code Memory Capacity Exceeded (0x07).\n\n If Operation indicates the start of new data (values 0x01 or 0x03), then any existing\n partial or complete scan response data shall be discarded.\n\n If the scan response data is discarded by the command or the combined length of\n the data after the command completes is zero, the advertising set will have no scan\n response data.\n\n The Fragment_Preference parameter provides a hint to the Controller as to whether\n advertising data should be fragmented.\n If the advertising set is non-scannable and the Host uses this command other than to\n discard existing data, the Controller shall return the error code Invalid HCI Command\n Parameters (0x12). If the advertising set uses scannable legacy advertising PDUs and\n either Operation is not 0x03 or the Scan_Response_Data_Length parameter exceeds\n 31 octets, the Controller shall return the error code Invalid HCI Command Parameters\n (0x12).\n\n If Operation is not 0x03 and Scan_Response_Data_Length is zero, the Controller shall\n return the error code Invalid HCI Command Parameters (0x12).\n\n If advertising is currently enabled for the specified advertising set and Operation does\n not have the value 0x03, the Controller shall return the error code Command Disallowed\n (0x0C).\n\n If the advertising set uses extended advertising and the combined length of the data is\n greater than the maximum that the Controller can transmit within the longest possible\n auxiliary advertising segment consistent with the current parameters of the advertising\n set (using the current advertising interval if advertising is enabled), all the data shall\n be discarded and the Controller shall return the error code Packet Too Long (0x45). If\n advertising on the LE Coded PHY, the S=8 coding shall be assumed unless the current\n advertising parameters require the use of S=2 for an advertising physical channel, in\n which case the S=2 coding shall be assumed for that advertising physical channel.\n\n If the advertising set uses scannable extended advertising PDUs, advertising is\n currently enabled for the specified advertising set, and Scan_Response_Data_Length\n is zero, the Controller shall return the error code Command Disallowed (0x0C).\n\n If the advertising set corresponding to the Advertising_Handle parameter does not exist,\n then the Controller shall return the error code Unknown Advertising Identifier (0x42).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Extended_Scan_Response_Data command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_ext_scan_response_data(
        p_params: *const sdc_hci_cmd_le_set_ext_scan_response_data_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Extended Advertising Enable.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.56\n\n The HCI_LE_Set_Extended_Advertising_Enable command is used to request the\n Controller to enable or disable one or more advertising sets using the advertising\n sets identified by the Advertising_Handleparameter. The Controller manages the\n timing of advertisements in accordance with the advertising parameters given in the\n HCI_LE_Set_Extended_Advertising_Parameters command. The Num_Sets parameter\n is the number of advertising sets contained in the parameter arrays. If Enable and\n Num_Sets are both set to 0x00, then all advertising sets are disabled.\n\n The Controller shall only start an advertising event when the corresponding\n advertising set is enabled. The Controller shall continue advertising until all advertising\n sets have been disabled. An advertising set shall be disabled when the Host\n issues an HCI_LE_Set_Extended_Advertising_Enable command with the Enable\n parameter set to 0x00 (Advertising is disabled), a connection is created using\n that advertising set, the duration specified in the Durationparameter expires, or\n the number of extended advertising events transmitted for the set exceeds the\n Max_Extended_Advertising_Eventsparameter.\n\n The Durationparameter indicates the duration for which that advertising set is\n enabled. The duration begins at the start of the first advertising event of this advertising\n set. The Controller should not start an extended advertising event that it cannot\n complete within the duration.\n\n If the advertising is high duty cycle connectable directed advertising, then Durationshall be less than or equal to 1.28 seconds and shall not be equal to 0.\n\n The Max_Extended_Advertising_Eventsparameter, if non-zero, indicates the\n maximum number of extended advertising events that shall be sent prior to disabling\n the extended advertising set even if the Durationparameter has not expired.\n\n Durationand Max_Extended_Advertising_Eventsshall be ignored when Enable is\n set to 0x00.\n If the HCI_LE_Set_Extended_Advertising_Enable command is sent again for an\n advertising set while that set is enabled, the timer used for the duration and the number\n of events counter are reset and any change to the random address shall take effect.\n\n Disabling the advertising set identified by the Advertising_Handleparameter does not\n disable any periodic advertising associated with that set.\n\n Disabling an advertising set that is already disabled has no effect.\n\n If the same advertising set is identified by more than one entry in the\n Advertising_Handlearrayed parameter, then the Controller shall return the error code\n Invalid HCI Command Parameters (0x12).\n\n If the advertising set corresponding to the Advertising_Handleparameter does not\n exist, then the Controller shall return the error code Unknown Advertising Identifier\n (0x42).\n\n The remainder of this section only applies if Enable is set to 0x01.\n\n If Num_Sets is set to 0x00, the Controller shall return the error code Invalid HCI\n Command Parameters (0x12).\n\n If the advertising set contains partial advertising data or partial scan response data, the\n Controller shall return the error code Command Disallowed (0x0C).\n\n If the advertising set uses scannable extended advertising PDUs and no scan response\n data is currently provided, the Controller shall return the error code Command\n Disallowed (0x0C).\n\n If the advertising set uses connectable extended advertising PDUs and the advertising\n data in the advertising set will not fit in the AUX_ADV_IND PDU, the Controller shall\n return the error code Invalid HCI Command Parameters (0x12).\n\n Note: The maximum amount of data that will fit in the PDU depends on which options\n are selected and on the maximum length of PDU that the Controller is able to transmit.\n\n If extended advertising is being used and the length of any advertising data or of\n any scan response data is greater than the maximum that the Controller can transmit\n within the longest possible auxiliary advertising segment consistent with the chosen\n advertising interval, the Controller shall return the error code Packet Too Long (0x45). If\n advertising on the LE Coded PHY, the S=8 coding shall be assumed unless the current\n advertising parameters require the use of S=2 for an advertising physical channel, in\n which case the S=2 coding shall be assumed for that advertising physical channel.\n If the advertising set's Own_Address_Type parameter is set to 0x00 and the device\n does not have a public address, the Controller should return an error code which should\n be Invalid HCI Command Parameters (0x12).\n\n If the advertising set's Own_Address_Type parameter is set to 0x01 and the\n random address for the advertising set has not been initialized using the\n HCI_LE_Set_Advertising_Set_Random_Address command, the Controller shall return\n the error code Invalid HCI Command Parameters (0x12).\n\n If the advertising set's Own_Address_Type parameter is set to 0x02, the Controller's\n resolving list did not contain a matching entry, and the device does not have a public\n address, the Controller should return an error code which should be Invalid HCI\n Command Parameters (0x12).\n\n If the advertising set's Own_Address_Type parameter is set to 0x03,\n the Controller's resolving list did not contain a matching entry, and the\n random address for the advertising set has not been initialized using the\n HCI_LE_Set_Advertising_Set_Random_Address command, the Controller shall return\n the error code Invalid HCI Command Parameters (0x12).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Extended_Advertising_Enable command has completed, an\n HCI_Command_Complete event shall be generated.\n\n If the Durationparameter is set to a value other than 0x0000, an\n HCI_LE_Advertising_Set_Terminated event shall be generated when the duration\n specified in the Durationparameter expires. However, if the advertising set\n is for high duty cycle connectable directed advertising and no connection\n is created before the duration expires, an HCI_LE_Connection_Complete or\n HCI_LE_Enhanced_Connection_Complete event with the Status parameter set to the\n error code Advertising Timeout (0x3C) may be generated instead of or in addition to\n the HCI_LE_Advertising_Set_Terminated event. If the Controller generates both events,\n they may be in either order.\n\n If the Max_Extended_Advertising_Eventsparameter is set to a value other than 0x00,\n an HCI_LE_Advertising_Set_Terminated event shall be generated when the maximum\n number of extended advertising events has been transmitted by the Controller.\n If the advertising set is connectable and a connection gets created, an\n HCI_LE_Connection_Complete or HCI_LE_Enhanced_Connection_Complete event\n shall be generated followed by an HCI_LE_Advertising_Set_Terminated event with\n the Status parameter set to 0x00. The Controller should not send any other events\n in between these two events. If the Controller supports the LE Channel Selection\n Algorithm #2 feature, then the HCI_LE_Advertising_Set_Terminated event may be\n immediately preceded or followed by an HCI_LE_Channel_Selection_Algorithm event.\n\n Note: If this command is used to disable advertising at about the same time that\n a connection is established or the advertising duration expires, there is a possible\n race condition in that it is possible to receive both an HCI_LE_Connection_Complete,\n HCI_LE_Enhanced_Connection_Complete, or HCI_LE_Advertising_Set_Terminated\n event and the HCI_Command_Complete event for this command.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_ext_adv_enable(p_params: *const sdc_hci_cmd_le_set_ext_adv_enable_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Read Maximum Advertising Data Length.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.57\n\n The HCI_LE_Read_Maximum_Advertising_Data_Length command is used to read the\n maximum length of data supported by the Controller for use as advertisement data or\n scan response data in an advertising event or as periodic advertisement data.\n\n Note: The maximum amount may be fragmented across multiple PDUs (see 6] Part\n B, Section 2.3.4.9).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_Maximum_Advertising_Data_Length command has\n completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_max_adv_data_length(
        p_return: *mut sdc_hci_cmd_le_read_max_adv_data_length_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Read Number of Supported Advertising Sets.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.58\n\n The HCI_LE_Read_Number_of_Supported_Advertising_Sets command is used to read\n the maximum number of advertising sets supported by the advertising Controller at the\n same time.\n\n Note: The number of advertising sets that can be supported is not fixed and the\n Controller can change it at any time because the memory used to store advertising\n sets can also be used for other purposes.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_Number_of_Supported_Advertising_Sets command has\n completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_number_of_supported_adv_sets(
        p_return: *mut sdc_hci_cmd_le_read_number_of_supported_adv_sets_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Remove Advertising Set.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.59\n\n The HCI_LE_Remove_Advertising_Set command is used to remove an advertising set\n from the Controller.\n\n If the advertising set corresponding to the Advertising_Handle parameter does not exist,\n then the Controller shall return the error code Unknown Advertising Identifier (0x42). If\n advertising or periodic advertising on the advertising set is enabled, then the Controller\n shall return the error code Command Disallowed (0x0C).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Remove_Advertising_Set command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_remove_adv_set(p_params: *const sdc_hci_cmd_le_remove_adv_set_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Clear Advertising Sets.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.60\n\n The HCI_LE_Clear_Advertising_Sets command is used to remove all existing\n advertising sets from the Controller.\n\n If advertising or periodic advertising is enabled on any advertising set, then the\n Controller shall return the error code Command Disallowed (0x0C).\n\n Note: All advertising sets are cleared on HCI reset.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Clear_Advertising_Sets command has completed, an\n HCI_Command_Complete event shall be generated.\n\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_clear_adv_sets() -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Periodic Advertising Parameters The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.61\n\n The HCI_LE_Set_Periodic_Advertising_Parameters command is used by the Host to\n set the parameters for periodic advertising.\n\n The Advertising_Handle parameter identifies the advertising set whose periodic\n advertising parameters are being configured. If the corresponding advertising set does\n not already exist, then the Controller shall return the error code Unknown Advertising\n Identifier (0x42).\n\n The Periodic_Advertising_Interval_Min parameter shall be less than or equal to the\n Periodic_Advertising_Interval_Max parameter. The Periodic_Advertising_Interval_Min\n and Periodic_Advertising_Interval_Max parameters should not be the same value to\n enable the Controller to determine the best advertising interval given other activities.\n\n If the periodic advertising interval range provided by the Host (Periodic_Advertising_-\n Interval_Min, Periodic_Advertising_Interval_Max) does not overlap with the periodic\n advertising interval range supported by the Controller, then the Controller shall return\n an error which should use the error code Unsupported Feature or Parameter Value\n (0x11).\n\n The Periodic_Advertising_Properties parameter indicates which fields should be\n included in the advertising packet.\n\n The Num_Subevents parameter identifies the number of subevents that shall be\n transmitted for each periodic advertising event. If the Num_Subevents parameter value\n is 0x00, then the Periodic Advertising does not have responses and the Controller\n shall ignore the Subevent_Interval, Response_Slot_Delay, Response_Slot_Spacing,\n and Num_Response_Slots parameters. If Num_Subevents is greater than 0, then the\n Periodic Advertising is PAwR.\n\n The Subevent_Interval parameter identifies the time between the subevents\n of PAwR. The Subevent_Interval shall be less than or equal to the\n Periodic_Advertising_Interval_Min divided by the Num_Subevents of the advertising\n set. If Num_Subevents is set to 1, then the Controller shall ignore Subevent_Interval\n and uses of Subevent_Interval in the next two paragraphs shall be replaced by\n Periodic_Advertising_Interval_Max.\n\n The Response_Slot_Delay parameter identifies the time between the start of the\n advertising packet at the start of a subevent and the start of the first response slot.\n The Response_Slot_Delay shall be less than the Subevent_Interval.\n\n The Response_Slot_Spacing parameter identifies the time between the start of two\n consecutive response slots. The Response_Slot_Spacing shall be less than or equal\n to 10  (Subevent_Interval  Response_Slot_Delay)  Num_Response_Slots. If the\n Num_Response_Slots parameter is set to 1, then the Controller shall ignore the\n Response_Slot_Spacing parameter.\n\n The Num_Response_Slots parameter identifies the number of response slots in a\n subevent.\n\n If the advertising set identified by the Advertising_Handle specified scannable,\n connectable, legacy, or anonymous advertising, the Controller shall return the error\n code Invalid HCI Command Parameters (0x12).\n\n If the Host issues this command when periodic advertising is enabled for the specified\n advertising set, the Controller shall return the error code Command Disallowed (0x0C).\n\n If the Advertising_Handle does not identify an advertising set that is already configured\n for periodic advertising and the Controller is unable to support more periodic advertising\n at present, the Controller shall return the error code Memory Capacity Exceeded (0x07).\n\n If the advertising set already contains periodic advertising data and the length of the\n data is greater than the maximum that the Controller can transmit within a periodic\n advertising interval of Periodic_Advertising_Interval_Max, the Controller shall return the\n error code Packet Too Long (0x45). If advertising on the LE Coded PHY, the S=8 coding\n shall be assumed unless the current advertising parameters require the use of S=2 for\n an advertising physical channel, in which case the S=2 coding shall be assumed for that\n advertising physical channel.\n\n Missing parameters:\n When a version of this command is issued that does not include all the parameters, the\n following values shall be used for any missing parameters:\n Parameter Value\n Num_Subevents 0\n Subevent_Interval ignored\n Response_Slot_Delay ignored\n Response_Slot_Spacing ignored\n Num_Response_Slots ignored\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Periodic_Advertising_Parameters command has\n completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_periodic_adv_params(p_params: *const sdc_hci_cmd_le_set_periodic_adv_params_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Periodic Advertising Data.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.62\n\n The HCI_LE_Set_Periodic_Advertising_Data command is used to set the data used\n in periodic advertising PDUs. This command may be issued at any time after the\n advertising set identified by the Advertising_Handle parameter has been configured for\n periodic advertising using the HCI_LE_Set_Periodic_Advertising_Parameters command\n (see Section 7.8.61), regardless of whether periodic advertising in that set is enabled\n or disabled. If the advertising set has not been configured for periodic advertising or\n has been configured for Periodic Advertising with Responses, then the Controller shall\n return the error code Command Disallowed (0x0C).\n\n If periodic advertising is currently enabled for the specified advertising set, the\n Controller shall use the new data in subsequent periodic advertising events for this\n advertising set. If a periodic advertising event is in progress when this command is\n issued, the Controller may use the old or new data for that event.\n\n If periodic advertising is currently disabled for the specified advertising set, the data\n shall be kept by the Controller and used once periodic advertising is enabled for that\n set. The data shall be discarded when the advertising set is removed.\n\n Only the significant part of the periodic advertising data should be transmitted in the\n advertising packets as defined in 3] Part C, Section 11.\n\n The Host may set the periodic advertising data in one or more operations using the\n Operation parameter in the command. If the combined length of the data exceeds\n the capacity of the advertising set identified by the Advertising_Handle parameter (see\n Section 7.8.57 LE Read Maximum Advertising Data Length command) or the amount\n of memory currently available, all the data shall be discarded and the Controller shall\n return the error code Memory Capacity Exceeded (0x07).\n\n If the combined length of the data is greater than the maximum that the Controller can\n transmit within the current periodic advertising interval (if periodic advertising is currently\n enabled) or the Periodic_Advertising_Interval_Max for the advertising set (if currently\n disabled), all the data shall be discarded and the Controller shall return the error code\n Packet Too Long (0x45). If advertising on the LE Coded PHY, the S=8 coding shall\n be assumed unless the current advertising parameters require the use of S=2 for an\n advertising physical channel, in which case the S=2 coding shall be assumed for that\n advertising physical channel.\n\n If Operation indicates the start of new data (values 0x01 or 0x03), then any existing\n partial or complete data shall be discarded.\n\n If Operation is 0x04, then the behavior is the same as if the current periodic advertising\n data had been sent again; this can be used to cause the Advertising DID value to be\n updated (see 6] Part B, Section 4.4.2.11).\n\n If Operation is 0x04 and:\n\n  periodic advertising is currently disabled for the advertising set;\n  the periodic advertising set contains no data; or\n  Advertising_Data_Length is not zero;\n\n then the Controller shall return the error code Invalid HCI Command Parameters (0x12).\n\n If Operation is not 0x03 or 0x04 and Advertising_Data_Length is zero, then the\n Controller shall return the error code Invalid HCI Command Parameters (0x12).\n\n If the periodic advertising data is discarded by the command or the combined length of\n the data after the command completes is zero, the advertising set will have no periodic\n advertising data.\n\n If periodic advertising is currently enabled for the specified advertising set and\n Operation does not have the value 0x03 or 0x04, then the Controller shall return the\n error code Command Disallowed (0x0C).\n\n If the advertising set corresponding to the Advertising_Handle parameter does not exist,\n then the Controller shall return the error code Unknown Advertising Identifier (0x42).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Periodic_Advertising_Data command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_periodic_adv_data(p_params: *const sdc_hci_cmd_le_set_periodic_adv_data_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Periodic Advertising Enable.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.63\n\n The HCI_LE_Set_Periodic_Advertising_Enable command is used to request the\n Controller to enable or disable the periodic advertising for the advertising set specified\n by the Advertising_Handle parameter (ordinary advertising is not affected).\n\n If the advertising set is not currently enabled (see the\n HCI_LE_Set_Extended_Advertising_Enable command), the periodic advertising is not\n started until the advertising set is enabled. Once the advertising set has been\n enabled, the Controller shall continue periodic advertising until the Host issues an\n HCI_LE_Set_Periodic_Advertising_Enable command with bit 0 of Enable set to 0\n (periodic advertising is disabled). Disabling the advertising set has no effect on the\n periodic advertising once the advertising set has been enabled.\n\n The Controller manages the timing of advertisements in accordance with the advertising\n parameters given in the HCI_LE_Set_Periodic_Advertising_Parameters command.\n\n If the advertising set corresponding to the Advertising_Handle parameter does not exist,\n the Controller shall return the error code Unknown Advertising Identifier (0x42).\n\n If bit 0 of Enable is set to 1 (periodic advertising is enabled) and the advertising set\n contains partial periodic advertising data, the Controller shall return the error code\n Command Disallowed (0x0C).\n\n If bit 0 of Enable is set to 1 and the Host has not issued the\n HCI_LE_Set_Periodic_Advertising_Parameters command for the advertising set, the\n Controller shall either use vendor-specified parameters or return the error code\n Command Disallowed (0x0C).\n\n If bit 0 of Enable is set to 1 and the length of the periodic advertising data is greater than\n the maximum that the Controller can transmit within the chosen periodic advertising\n interval, the Controller shall return the error code Packet Too Long (0x45). If advertising\n on the LE Coded PHY, the S=8 coding shall be assumed unless the current advertising\n parameters require the use of S=2 for an advertising physical channel, in which case\n the S=2 coding shall be assumed for that advertising physical channel.\n\n If bit 0 of Enable is set to 1 and the advertising set identified by the Advertising_Handle\n specified scannable, connectable, legacy, or anonymous advertising, the Controller shall\n return the error code Command Disallowed (0x0C).\n If bit 0 of Enable is set to 0 and the Controller supports the Periodic Advertising ADI\n Support feature, then the Controller shall ignore bit 1.\n\n If bit 1 of Enable is set to 1 and the Controller does not support the Periodic Advertising\n ADI Support feature, the Controller shall return an error which should use the error code\n Unsupported Feature or Parameter Value (0x11).\n\n Enabling periodic advertising when it is already enabled can cause the random address\n to change. Disabling periodic advertising when it is already disabled has no effect.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Periodic_Advertising_Enable command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_periodic_adv_enable(p_params: *const sdc_hci_cmd_le_set_periodic_adv_enable_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Extended Scan Parameters.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.64\n\n The HCI_LE_Set_Extended_Scan_Parameters command is used to set the extended\n scan parameters to be used on the advertising physical channels.\n\n The Scanning_PHYs parameter indicates the PHY(s) on which the advertising packets\n should be received on the primary advertising physical channel. The Host may enable\n one or more scanning PHYs. If the Host specifies a PHY that is not supported by the\n Controller, including a bit that is reserved for future use, it should return the error code\n Unsupported Feature or Parameter Value (0x11). The Scan_TypeScan_Intervaland Scan_Windowparameters array elements are ordered in the same order as\n the set bits in the Scanning_PHY parameter, starting from bit 0. The number of array\n elements is determined by the number of bits set in the Scanning_PHY parameter.\n\n The Scan_Typeparameter specifies the type of scan to perform.\n\n The Scan_Intervaland Scan_Windowparameters are recommendations from the\n Host on how long (Scan_Windowand how frequently (Scan_Intervalthe Controller\n should scan (see 6] Part B, Section 4.4.3); however the frequency and length\n of the scan is implementation specific. If the requested scan cannot be supported by\n the implementation, the Controller shall return the error code Invalid HCI Command\n Parameters (0x12).\n\n The Own_Address_Type parameter indicates the type of address being used in the\n scan request packets.\n\n If the Host issues this command when scanning is enabled in the Controller, the\n Controller shall return the error code Command Disallowed (0x0C).\n\n If the Controller does not support the Decision-Based Advertising Filtering feature and\n the Host issues this command with bits 2 and 3 of Scanning_Filter_Policy set to a value\n other than 0b00, the Controller shall return an error code which should be Unsupported\n Feature or Parameter Value (0x11).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Extended_Scan_Parameters command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_ext_scan_params(p_params: *const sdc_hci_cmd_le_set_ext_scan_params_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Extended Scan Enable.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.65\n\n The HCI_LE_Set_Extended_Scan_Enable command is used to enable or disable\n scanning for both legacy and extended advertising PDUs.\n\n The Enable parameter determines whether scanning is enabled or disabled. If it is set to\n 0x00, the remaining parameters shall be ignored.\n\n If Enable is set to 0x01 and the Host has not issued the\n HCI_LE_Set_Extended_Scan_Parameters command, the Controller shall either use\n vendor-specified parameters or return the error code Command Disallowed (0x0C).\n\n The Filter_Duplicates parameter controls whether the Link Layer should filter out\n duplicate advertising reports (filtering duplicates enabled) to the Host or if the Link\n Layer should generate advertising reports for each packet received (filtering duplicates\n disabled). See 6] Part B, Section 4.4.3.5.\n\n If the Filter_Duplicates parameter is set to 0x00, all advertisements received from\n advertisers shall be sent to the Host in advertising report events.\n\n If the Filter_Duplicates parameter is set to 0x01, duplicate advertisements should not be\n sent to the Host in advertising report events until scanning is disabled.\n\n If the Filter_Duplicates parameter is set to 0x02, duplicate advertisements in a single\n scan period should not be sent to the Host in advertising report events; this setting shall\n only be used if both Period and Duration are non-zero. If Filter_Duplicates is set to 0x02\n and either Period or Duration to zero, the Controller shall return the error code Invalid\n HCI Command Parameters (0x12).\n\n If the Duration parameter is zero or both the Duration parameter and Period parameter\n are non-zero, the Controller shall continue scanning until scanning is disabled by\n the Host issuing an HCI_LE_Set_Extended_Scan_Enable command with the Enable\n parameter set to 0x00 (Scanning is disabled). The Period parameter shall be ignored\n when the Duration parameter is zero.\n If the Duration parameter is non-zero and the Period parameter is zero, the Controller\n shall continue scanning until the duration specified in the Duration parameter has\n expired.\n\n If both the Duration and Period parameters are non-zero and the Duration is greater\n than or equal to the Period (comparing the times, not how they are represented), the\n Controller shall return the error code Invalid HCI Command Parameters (0x12).\n\n When the Duration and Period parameters are non-zero, the Controller shall scan for\n the duration of the Duration parameter within a scan period specified by the Period\n parameter. After the scan period has expired, a new scan period shall begin and\n scanning shall begin again for the duration specified. The scan periods continue until\n the Host disables scanning.\n\n If the HCI_LE_Set_Extended_Scan_Enable command with Enable set to 0x01 is sent\n while scanning is already enabled, the timers used for duration and period are reset\n to the new parameter values and a new scan period is started. Any change to the\n Filter_Duplicates setting or the random address shall take effect.\n\n Disabling scanning when it is disabled has no effect.\n\n Note: The duration of a scan period refers to the time spent scanning on both the\n primary and secondary advertising physical channels. However, expiry of the duration\n does not prevent the Link Layer from scanning for and receiving auxiliary packets of\n received advertisements.\n\n If Enable is set to 0x01, the scanning parameters' Own_Address_Type parameter is set\n to 0x00 or 0x02, and the device does not have a public address, the Controller should\n return an error code which should be Invalid HCI Command Parameters (0x12).\n\n If Enable is set to 0x01, the scanning parameters' Own_Address_Type parameter is set\n to 0x01 or 0x03, and the random address for the device has not been initialized using\n the HCI_LE_Set_Random_Address command, the Controller shall return the error code\n Invalid HCI Command Parameters (0x12).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Extended_Scan_Enable command has completed, an\n HCI_Command_Complete event shall be generated.\n Zero or more LE Extended Advertising Reports are generated by the Controller based\n on any advertising packets received and the duplicate filtering in effect. More than\n one advertising packet may be reported in each HCI_LE_Extended_Advertising_Report\n event.\n\n At the end of a single scan (Duration non-zero but Period zero), an\n HCI_LE_Scan_Timeout event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_ext_scan_enable(p_params: *const sdc_hci_cmd_le_set_ext_scan_enable_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Extended Create Connection The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.66\n\n The HCI_LE_Extended_Create_Connection command is used to create an ACL\n connection, with the local device in the Central role, to a connectable advertiser. The\n command is also used to create an ACL connection between a periodic advertiser and a\n synchronized device.\n\n If a connection is created with the local device in the Peripheral role while this command\n is pending, then this command remains pending.\n\n The Advertising_Handle parameter is used to identify the periodic advertising train.\n\n The Subevent parameter is used to identify the subevent where a connection\n request shall be initiated from a periodic advertising train. The Host may use\n this subevent whether or not the Controller has requested data for it using the\n HCI_LE_Periodic_Advertising_Subevent_Data_Request event.\n\n The Advertising_Handle and Subevent parameters shall be set to 0xFF if these\n parameters are not used. If the Host sets one but not both of these to 0xFF, then the\n Controller shall return an error which should use the error code Invalid HCI Command\n Parameters (0x12).\n\n If the Advertising_Handle and Subevent parameters are set to values other than 0xFF,\n then the Initiator_Filter_Policy, Scan_Intervaland Scan_Windowparameters shall\n be ignored.\n\n The Initiator_Filter_Policy parameter is used to determine whether the Filter Accept List\n is used and whether to process decision PDUs and other advertising PDUs. If the Filter\n Accept List is not used, the Peer_Address_Type and the Peer_Address parameters\n specify the address type and address of the advertising device to connect to for\n advertisements not using decision PDUs. If Initiator_Filter_Policy is set to 0x03, then\n devices on the Filter Accept List shall still be processed using the decision instructions\n (see Section 7.8.145).\n\n The Own_Address_Type parameter indicates the type of address being used in the\n connection request packets.\n\n The Peer_Address_Type parameter indicates the type of address used in the\n connectable advertisement sent by the peer.\n\n The Peer_Address parameter indicates the Peers Public Device Address, Random\n (static) Device Address, Non-Resolvable Private Address, or Resolvable Private\n Address depending on the Peer_Address_Type parameter.\n\n The Initiating_PHYs parameter indicates the PHY(s) on which the advertising packets\n should be received on the primary advertising physical channel and the PHYs for\n which connection parameters have been specified. The Host may enable one or more\n initiating PHYs. If the Host specifies a PHY that is not supported by the Controller,\n including a bit that is reserved for future use, the latter should return the error code\n Unsupported Feature or Parameter Value (0x11). If the Host sets Advertising_Handle to\n a value other than 0xFF and does not include the PHY used for the specified periodic\n advertising train in Initiating_PHYs, the Controller shall return an error which should use\n the error code Invalid HCI Command Parameters (0x12). The array elements of the\n arrayed parameters are ordered in the same order as the set bits in the Initiating_PHYs\n parameter, starting from bit 0. The number of array elements is determined by the\n number of bits set in the Initiating_PHYs parameter. When a connectable advertisement\n is received and a connection request is sent on one PHY, scanning on any other PHYs\n is terminated.\n\n The Scan_Intervaland Scan_Windowparameters are recommendations from the\n Host on how long (Scan_Windowand how frequently (Scan_Intervalthe Controller\n should scan (see 6] Part B, Section 4.5.3); however the frequency and length\n of the scan is implementation specific. If the requested scan cannot be supported by\n the implementation, the Controller shall return the error code Invalid HCI Command\n Parameters (0x12). If bit 1 is set in Initiating_PHYs, the values for the LE 2M PHY shall\n be ignored.\n\n The Connection_Interval_Minand Connection_Interval_Maxparameters define the\n minimum and maximum allowed connection interval. The Connection_Interval_Minparameter shall not be greater than the Connection_Interval_Maxparameter.\n The Max_Latencyparameter defines the maximum allowed Peripheral latency (see\n 6] Part B, Section 4.5.1).\n\n The Supervision_Timeoutparameter defines the link supervision timeout for the\n connection. The Supervision_Timeoutin milliseconds shall be larger than (1 +\n Max_Latency Connection_Interval_Max 2, where Connection_Interval_Maxis given in milliseconds (see 6] Part B, Section 4.5.2).\n\n The Min_CE_Lengthand Max_CE_Lengthparameters provide the Controller\n with the expected minimum and maximum length of the connection events. The\n Min_CE_Lengthparameter shall be less than or equal to the Max_CE_Lengthparameter. The Controller is not required to use these values.\n\n Where the connection is made on a PHY whose bit is not set in the\n Initiating_PHYs parameter, the Controller shall use the Connection_Interval_MinConnection_Interval_MaxMax_LatencySupervision_TimeoutMin_CE_Lengthand Max_CE_Lengthparameters for an implementation-chosen PHY whose bit is set\n in the Initiating_PHYs parameter.\n\n If the Host issues this command when another HCI_LE_Extended_Create_Connection\n command is pending in the Controller, the Controller shall return the error code\n Command Disallowed (0x0C).\n\n If the local device is already connected to the same device address as the advertiser\n (including two different Resolvable Private Addresses that resolve to the same IRK),\n then the Controller shall return an error which should use the error code Connection\n Already Exists (0x0B).\n\n If the Own_Address_Type parameter is set to 0x00 and the device does not have a\n public address, the Controller should return an error code which should be Invalid HCI\n Command Parameters (0x12).\n\n If the Own_Address_Type parameter is set to 0x01 and the random address for the\n device has not been initialized using the HCI_LE_Set_Random_Address command, the\n Controller shall return the error code Invalid HCI Command Parameters (0x12).\n\n If the Own_Address_Type parameter is set to 0x02, the Initiator_Filter_Policy parameter\n is set to 0x00, the Controller's resolving list did not contain a matching entry, and the\n device does not have a public address, the Controller should return an error code which\n should be Invalid HCI Command Parameters (0x12).\n\n If the Own_Address_Type parameter is set to 0x02, the Initiator_Filter_Policy parameter\n is not set to 0x00, and the device does not have a public address, the Controller should\n return an error code which should be Invalid HCI Command Parameters (0x12).\n\n If the Own_Address_Type parameter is set to 0x03, the Initiator_Filter_Policy\n parameter is set to 0x00, the Controller's resolving list did not contain a matching\n entry, and the random address for the device has not been initialized using the\n HCI_LE_Set_Random_Address command, the Controller shall return the error code\n Invalid HCI Command Parameters (0x12).\n\n If the Own_Address_Type parameter is set to 0x03, the Initiator_Filter_Policy parameter\n is not set to 0x00, and the random address for the device has not been initialized using\n the HCI_LE_Set_Random_Address command, the Controller shall return the error code\n Invalid HCI Command Parameters (0x12).\n\n If the Initiating_PHYs parameter does not have at least one bit set for a PHY allowed\n for scanning on the primary advertising physical channel, the Controller shall return the\n error code Invalid HCI Command Parameters (0x12).\n\n If the Host issues this command and the Controller has insufficient resources to handle\n any more connections, the Controller shall return the error code Connection Rejected\n due to Limited Resources (0x0D).\n\n If the Controller does not support the Decision-Based Advertising Filtering feature and\n the Host issues this command with Initiator_Filter_Policy set to a value other than 0x00\n or 0x01, the Controller shall return an error code which should be Unsupported Feature\n or Parameter Value (0x11).\n\n Missing parameters:\n When a version of this command is issued that does not include all the parameters, the\n following values shall be used for any missing parameters:\n Parameter Value\n Advertising_Handle 0xFF\n Subevent 0xFF\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_LE_Extended_Create_Connection command,\n the Controller sends the HCI_Command_Status event to the Host. An\n HCI_LE_Enhanced_Connection_Complete event shall be generated when a connection\n is created because of this command or the connection creation procedure is\n cancelled; until the event is generated, the command is considered pending. If\n a connection creation is discarded, then the error code Connection Failed to be\n Established / Synchronization Timeout (0x3E) shall be used. If a connection is created,\n this event shall be immediately followed by an HCI_LE_Channel_Selection_Algorithm\n event.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_ext_create_conn(p_params: *const sdc_hci_cmd_le_ext_create_conn_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Periodic Advertising Create Sync.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.67\n\n The HCI_LE_Periodic_Advertising_Create_Sync command is used to synchronize with\n a periodic advertising train from an advertiser and begin receiving periodic advertising\n packets.\n\n This command may be issued whether or not scanning is enabled and scanning may\n be enabled and disabled (see the LE Set Extended Scan Enable command) while\n this command is pending. However, synchronization can only occur when scanning is\n enabled. While scanning is disabled, no attempt to synchronize will take place.\n\n The Options parameter is used to determine whether the Periodic Advertiser List is\n used, whether HCI_LE_Periodic_Advertising_Report events for this periodic advertising\n train are initially enabled or disabled, and whether duplicate reports are filtered or not. If\n the Periodic Advertiser List is not used, the Advertising_SID, Advertiser Address_Type,\n and Advertiser Address parameters specify the periodic advertising device to listen to;\n otherwise they shall be ignored.\n\n The Advertising_SID parameter, if used, specifies the value that shall match the\n Advertising SID subfield in the ADI field of the received advertisement for it to be used\n to synchronize.\n\n The Skip parameter specifies the maximum number of consecutive periodic advertising\n events that the receiver may skip after successfully receiving a periodic advertising\n packet.\n\n The Sync_Timeout parameter specifies the maximum permitted time between\n successful receives. If this time is exceeded, synchronization is lost.\n\n The Sync_CTE_Type parameter specifies whether to only synchronize to periodic\n advertising with certain types of Constant Tone Extension (a value of 0 indicates that\n the presence or absence of a Constant Tone Extension is irrelevant). If the periodic\n advertising has the wrong type of Constant Tone Extension then:\n\n  If bit 0 of Options is set, the Controller shall ignore this address and SID and continue\n to search for other periodic advertisements.\n  Otherwise, the Controller shall cancel the synchronization with the error code\n Unsupported Remote Feature (0x1A).\n\n If the periodic advertiser changes the type of Constant Tone Extension after the scanner\n has synchronized with the periodic advertising, the scanner's Link Layer shall remain\n synchronized.\n\n If the Host sets all the non-reserved bits of the Sync_CTE_Type parameter to 1, the\n Controller shall return the error code Command Disallowed (0x0C).\n\n Irrespective of the value of the Skip parameter, the Controller should stop skipping\n packets before the Sync_Timeout would be exceeded.\n\n If the Host issues this command when another\n HCI_LE_Periodic_Advertising_Create_Sync command is pending, the Controller shall\n return the error code Command Disallowed (0x0C).\n\n If the Host issues this command with bit 0 of Options not set and with Advertising_SID,\n Advertiser_Address_Type, and Advertiser_Address the same as those of a periodic\n advertising train that the Controller is already synchronized to, the Controller shall return\n the error code Connection Already Exists (0x0B).\n\n If the Host issues this command and the Controller has insufficient resources to handle\n any more periodic advertising trains, the Controller shall return the error code Memory\n Capacity Exceeded (0x07).\n\n If bit 1 of Options is set to 1 and the Controller supports the Periodic Advertising ADI\n Support feature, then the Controller shall ignore bit 2.\n\n If bit 1 of Options is set to 0, bit 2 is set to 1, and the Controller does not support the\n Periodic Advertising ADI Support feature, then the Controller shall return an error which\n should use the error code Unsupported Feature or Parameter Value (0x11).\n\n If bit 1 of the Options parameter is set to 1 and the Controller does not support\n the HCI_LE_Set_Periodic_Advertising_Receive_Enable command, the Controller shall\n return the error code Connection Failed to be Established / Synchronization Timeout\n (0x3E).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Periodic_Advertising_Create_Sync command has been received,\n the Controller sends the HCI_Command_Status event to the Host. An\n HCI_LE_Periodic_Advertising_Sync_Established event shall be generated when the\n Controller starts receiving periodic advertising packets.\n\n When the Controller receives periodic advertising packets then, if reporting is enabled, it\n sends HCI_LE_Periodic_Advertising_Report events to the Host.\n\n If the Controller does not receive a periodic advertising packet within\n 6 periodic advertising events of first listening, then it shall generate an\n HCI_LE_Periodic_Advertising_Sync_Established event that should have Status set to\n Connection Failed to be Established / Synchronization Timeout (0x3E).\n\n Note: The HCI_LE_Periodic_Advertising_Sync_Established event can be\n sent as a result of synchronization being canceled by an\n HCI_LE_Periodic_Advertising_Create_Sync_Cancel command.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_periodic_adv_create_sync(p_params: *const sdc_hci_cmd_le_periodic_adv_create_sync_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Periodic Advertising Create Sync Cancel.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.68\n\n The HCI_LE_Periodic_Advertising_Create_Sync_Cancel command is used to cancel\n the HCI_LE_Periodic_Advertising_Create_Sync command while it is pending.\n\n If the Host issues this command while no HCI_LE_Periodic_Advertising_Create_Sync\n command is pending, the Controller shall return the error code Command Disallowed\n (0x0C).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Periodic_Advertising_Create_Sync_Cancel command has\n completed, the Controller sends an HCI_Command_Complete event to the Host.\n\n After the HCI_Command_Complete is sent and if the cancellation was successful, the\n Controller sends an HCI_LE_Periodic_Advertising_Sync_Established event to the Host\n with the error code Operation Cancelled by Host (0x44).\n\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_periodic_adv_create_sync_cancel() -> u8;
}
unsafe extern "C" {
    #[doc = "LE Periodic Advertising Terminate Sync.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.69\n\n The HCI_LE_Periodic_Advertising_Terminate_Sync command is used to stop reception\n of the periodic advertising train identified by the Sync_Handle parameter.\n\n If the periodic advertising train corresponding to the Sync_Handle parameter does not\n exist, then the Controller shall return the error code Unknown Advertising Identifier\n (0x42).\n\n Following successful completion of this command the Sync_Handle is destroyed.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Periodic_Advertising_Terminate_Sync command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_periodic_adv_terminate_sync(
        p_params: *const sdc_hci_cmd_le_periodic_adv_terminate_sync_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Add Device To Periodic Advertiser List.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.70\n\n The HCI_LE_Add_Device_To_Periodic_Advertiser_List command is used to add an\n entry, consisting of a single device address and SID, to the Periodic Advertiser\n list stored in the Controller. Any additions to the Periodic Advertiser list take effect\n immediately. If the entry is already on the list, the Controller shall return the error code\n Invalid HCI Command Parameters (0x12).\n\n If the Host issues this command when an HCI_LE_Periodic_Advertising_Create_Sync\n command is pending, the Controller shall return the error code Command Disallowed\n (0x0C).\n\n When a Controller cannot add an entry to the Periodic Advertiser list because the list is\n full, the Controller shall return the error code Memory Capacity Exceeded (0x07).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Add_Device_To_Periodic_Advertiser_List command has completed,\n an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_add_device_to_periodic_adv_list(
        p_params: *const sdc_hci_cmd_le_add_device_to_periodic_adv_list_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Remove Device From Periodic Advertiser List.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.71\n\n The HCI_LE_Remove_Device_From_Periodic_Advertiser_List command is used to\n remove one entry from the list of Periodic Advertisers stored in the Controller. Removals\n from the Periodic Advertisers List take effect immediately.\n\n If the Host issues this command when an HCI_LE_Periodic_Advertising_Create_Sync\n command is pending, the Controller shall return the error code Command Disallowed\n (0x0C).\n\n When a Controller cannot remove an entry from the Periodic Advertiser list because it\n is not found, the Controller shall return the error code Unknown Advertising Identifier\n (0x42).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Remove_Device_From_Periodic_Advertiser_List command has\n completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_remove_device_from_periodic_adv_list(
        p_params: *const sdc_hci_cmd_le_remove_device_from_periodic_adv_list_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Clear Periodic Advertiser List.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.72\n\n The HCI_LE_Clear_Periodic_Advertiser_List command is used to remove all entries\n from the list of Periodic Advertisers in the Controller.\n\n If this command is used when an HCI_LE_Periodic_Advertising_Create_Sync\n command is pending, the Controller shall return the error code Command Disallowed\n (0x0C).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Clear_Periodic_Advertiser_List command has completed, an\n HCI_Command_Complete event shall be generated.\n\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_clear_periodic_adv_list() -> u8;
}
unsafe extern "C" {
    #[doc = "LE Read Periodic Advertiser List Size.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.73\n\n The HCI_LE_Read_Periodic_Advertiser_List_Size command is used to read the total\n number of Periodic Advertiser list entries that can be stored in the Controller.\n\n Note: The number of entries that can be stored is not fixed and the Controller can\n change it at any time (e.g., because the memory used to store the list can also be used\n for other purposes).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_Periodic_Advertiser_List_Size command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_periodic_adv_list_size(
        p_return: *mut sdc_hci_cmd_le_read_periodic_adv_list_size_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Read Transmit Power.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.74\n\n The HCI_LE_Read_Transmit_Power command is used to read the minimum and\n maximum transmit powers supported by the Controller across all supported PHYs.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read _Transmit_Power command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_transmit_power(p_return: *mut sdc_hci_cmd_le_read_transmit_power_return_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Read RF Path Compensation.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.75\n\n The HCI_LE_Read_RF_Path_Compensation command is used to read the RF path\n compensation value parameters used in the Tx power level and RSSI calculation.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_RF_Path_Compensation command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_rf_path_compensation(
        p_return: *mut sdc_hci_cmd_le_read_rf_path_compensation_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Write RF Path Compensation.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.76\n\n The HCI_LE_Write_RF_Path_Compensation command is used to indicate the RF path\n gain or loss between the RF transceiver and the antenna contributed by intermediate\n components. A positive value means a net RF path gain and a negative value means\n a net RF path loss. The RF_TX_Path_Compensation_Value parameter shall be used\n by the Controller to calculate the radiative Tx power level used in HCI commands, HCI\n events, Advertising physical channel PDUs, and Link Layer Control PDUs using the\n following equation:\n\n Radiative Tx power level = Tx power level at RF transceiver output +\n RF_TX_Path_Compensation_Value\n\n For example, if the Tx power level is +4 (dBm) at RF transceiver output and the\n RF_TX_Path_Compensation_Value is -1.5 (dB), the radiative Tx power level is +4+\n (-1.5) = 2.5 (dBm).\n\n The RF_RX_Path_Compensation_Value parameter shall be used by the Controller to\n calculate the RSSI value reported to the Host using the following equation:\n\n Rx power level at RF transceiver input = Rx power level at antenna +\n RF_RX_Path_Compensation_Value\n\n For example, if the Rx power level is -45 (dBm) at RF transceiver input and the\n RF_RX_Path_Compensation_Value is -3.2 (dB), the Rx power level at antenna is -41.8\n (dBm).\n\n The default values for the RF path compensation are vendor-specific.\n\n This command can be issued at any time. If this command is issued during an ongoing\n over-the-air RF activity, the Controller may apply the Tx path compensation immediately\n or after a vendor-specific delay.\n\n The Controller shall apply a change to the Tx path compensation value either by leaving\n the power at the transceiver output unchanged and altering the radiative Tx power level\n or by altering the power at the transceiver output to maintain any previously chosen\n radiative Tx power level.\n\n If the Host needs to maintain a specific radiative transmit power level for an advertising\n set, it should disable that set before issuing this command then, after the command\n completes, reissue the HCI_LE_Set_Extended_Advertising_Parameters command for\n that set and then re-enable it.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Write_RF_Path_Compensation command has completed, an\n HCI_Command_Complete event shall be generated.\n\n If the command leads to a change in the local radiative transmit power\n level for an LE ACL connection, then the Controller shall generate an\n HCI_LE_Transmit_Power_Reporting event if local reporting is enabled and shall initiate\n a Link Layer Power Change Indication procedure (see 6] Part B, Section 5.1.18) if\n remote reporting is enabled.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_write_rf_path_compensation(
        p_params: *const sdc_hci_cmd_le_write_rf_path_compensation_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Privacy Mode.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.77\n\n The HCI_LE_Set_Privacy_Mode command is used to allow the Host to specify the\n privacy mode to be used for a given entry on the resolving list. The effect of this setting\n is specified in 6] Part B, Section 4.7.\n\n When an entry on the resolving list is removed, the mode associated with that entry\n shall also be removed.\n\n This command shall not be used when address resolution is enabled in the Controller\n and:\n\n  Advertising (other than periodic advertising) is enabled,\n  Scanning is enabled, or\n  an HCI_LE_Create_Connection, HCI_LE_Extended_Create_Connection, or\n HCI_LE_Periodic_Advertising_Create_Sync command is pending.\n\n This command may be used at any time when address resolution is disabled in the\n Controller.\n\n If the device is not on the resolving list, the Controller shall return the error code\n Unknown Connection Identifier (0x02).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Privacy_Mode command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_privacy_mode(p_params: *const sdc_hci_cmd_le_set_privacy_mode_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Connectionless CTE Transmit Parameters.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.80\n\n The HCI_LE_Set_Connectionless_CTE_Transmit_Parameters command is used to set\n the type, length, and antenna switching pattern for the transmission of Constant\n Tone Extensions in any periodic advertising on the advertising set identified by the\n Advertising_Handle parameter.\n\n The CTE_Count parameter specifies how many packets with a Constant Tone\n Extension are to be transmitted in each periodic advertising event. If the number of\n packets that would otherwise be transmitted is less than this, the Controller shall\n transmit sufficient AUX_CHAIN_IND PDUs with no AdvData to make up the number.\n However, if a change in circumstances since this command was issued means that the\n Controller can no longer schedule all of these packets, it should transmit as many as\n possible.\n\n If the Host issues this command when Constant Tone Extensions have been enabled\n in the advertising set, the Controller shall return the error code Command Disallowed\n (0x0C).\n\n The Switching_Pattern_Length and Antenna_IDsparameters are only used when\n transmitting an AoD Constant Tone Extension and shall be ignored if CTE_Type\n specifies an AoA Constant Tone Extension.\n\n If the CTE_Length parameter is greater than the maximum length of Constant Tone\n Extension supported, the Controller shall return the error code Unsupported Feature or\n Parameter Value (0x11).\n\n If the Host requests a type of Constant Tone Extension that the Controller does not\n support, the Controller shall return the error code Unsupported Feature or Parameter\n Value (0x11).\n\n If the Controller is unable to schedule CTE_Count packets in each event, the Controller\n shall return the error code Unsupported Feature or Parameter Value (0x11).\n If the advertising set corresponding to the Advertising_Handle parameter does not exist,\n the Controller shall return the error code Unknown Advertising Identifier (0x42).\n\n If Switching_Pattern_Length is greater than the maximum length of switching pattern\n supported by the Controller (see Section 7.8.87), the Controller shall return the error\n code Unsupported Feature or Parameter Value (0x11).\n\n If the Controller determines that any of the Antenna_IDsvalues do not identify an\n antenna in the device's antenna array, it shall return the error code Unsupported\n Feature or Parameter Value (0x11).\n\n Note: Some Controllers may be unable to determine which values do or do not identify\n an antenna.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Connectionless_CTE_Transmit_Parameters command has\n completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_connless_cte_transmit_params(
        p_params: *const sdc_hci_cmd_le_set_connless_cte_transmit_params_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Connectionless CTE Transmit Enable.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.81\n\n The HCI_LE_Set_Connectionless_CTE_Transmit_Enable command is used to request\n that the Controller enables or disables the use of Constant Tone Extensions in any\n periodic advertising on the advertising set identified by Advertising_Handle.\n\n In order to start sending periodic advertisements containing a Constant\n Tone Extension, the Host must also enable periodic advertising using the\n HCI_LE_Set_Periodic_Advertising_Enable command (see Section 7.8.63).\n\n Note: Periodic advertising can only be enabled when advertising is enabled on the\n same advertising set, but can continue after advertising has been disabled.\n\n If the Host issues this command before it has issued the\n HCI_LE_Set_Periodic_Advertising_Parameters command (see Section 7.8.61) for the\n advertising set, the Controller shall return the error code Command Disallowed (0x0C).\n\n Once enabled, the Controller shall continue advertising with Constant Tone Extensions\n until either one of the following occurs:\n\n  The Host issues an HCI_LE_Set_Connectionless_CTE_Transmit_Enable command\n with CTE_Enable set to 0x00 (disabling Constant Tone Extensions but allowing\n periodic advertising to continue).\n  The Host issues an HCI_LE_Set_Periodic_Advertising_Enable command (see\n Section 7.8.63) with Enable set to 0x00 (disabling periodic advertising). If periodic\n advertising is re-enabled then it shall continue to contain Constant Tone Extensions.\n\n If the Host issues this command before it has issued the\n HCI_LE_Set_Connectionless_CTE_Transmit_Parameters command for the advertising\n set, the Controller shall return the error code Command Disallowed (0x0C).\n\n If the periodic advertising is on a PHY that does not allow Constant Tone Extensions,\n the Controller shall return the error code Command Disallowed (0x0C).\n\n If the advertising set corresponding to the Advertising_Handle parameter does not exist,\n the Controller shall return the error code Unknown Advertising Identifier (0x42).\n\n The Host may issue this command when advertising or periodic advertising is enabled\n in the advertising set.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Connectionless_CTE_Transmit_Enable command has\n completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_connless_cte_transmit_enable(
        p_params: *const sdc_hci_cmd_le_set_connless_cte_transmit_enable_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Connection CTE Transmit Parameters.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.84\n\n The HCI_LE_Set_Connection_CTE_Transmit_Parameters command is used to set the\n antenna switching pattern and permitted Constant Tone Extension types used for\n transmitting Constant Tone Extensions requested by the peer device on the connection\n identified by the Connection_Handle parameter.\n\n If the Host issues this command when Constant Tone Extension responses have\n been enabled on the connection, the Controller shall return the error code Command\n Disallowed (0x0C).\n\n If the CTE_Types parameter has a bit set for a type of Constant Tone Extension that\n the Controller does not support, the Controller shall return the error code Unsupported\n Feature or Parameter Value (0x11).\n\n The Switching_Pattern_Length and Antenna_IDsparameters are only used when\n transmitting an AoD Constant Tone Extension and shall be ignored when CTE_Types\n does not have a bit set for an AoD Constant Tone Extension; they do not affect the\n transmission of an AoA Constant Tone Extension.\n\n If Switching_Pattern_Length is greater than the maximum length of switching pattern\n supported by the Controller, the Controller shall return the error code Unsupported\n Feature or Parameter Value (0x11).\n\n If the Controller determines that any of the Antenna_IDsvalues do not identify an\n antenna in the device's antenna array, it shall return the error code Unsupported\n Feature or Parameter Value (0x11).\n\n Note: Some Controllers may be unable to determine which values do or do not identify\n an antenna.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Connection_CTE_Transmit_Parameters command has\n completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_conn_cte_transmit_params(
        p_params: *const sdc_hci_cmd_le_set_conn_cte_transmit_params_t,
        p_return: *mut sdc_hci_cmd_le_set_conn_cte_transmit_params_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Connection CTE Response Enable.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.86\n\n The HCI_LE_Connection_CTE_Response_Enable command is used to request the\n Controller to respond to LL_CTE_REQ PDUs with LL_CTE_RSP PDUs on the specified\n connection.\n\n If the Host issues this command before issuing the\n HCI_LE_Set_Connection_CTE_Transmit_Parameters command at least once on the\n connection, the Controller shall return the error code Command Disallowed (0x0C).\n\n If the Host issues this command when the transmitter PHY for the connection is not a\n PHY that allows Constant Tone Extensions, the Controller shall return the error code\n Command Disallowed (0x0C).\n\n If the transmitter PHY for the connection changes to a PHY that does not allow\n Constant Tone Extensions, then the Controller shall automatically disable Constant\n Tone Extension responses.\n\n Note: If the PHY changes back to a PHY that allows Constant Tone Extensions, then\n the Controller will not automatically re-enable Constant Tone Extension responses.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Connection_CTE_Response_Enable command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_conn_cte_response_enable(
        p_params: *const sdc_hci_cmd_le_conn_cte_response_enable_t,
        p_return: *mut sdc_hci_cmd_le_conn_cte_response_enable_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Read Antenna Information.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.87\n\n The HCI_LE_Read_Antenna_Information command allows the Host to read the\n switching rates, the sampling rates, the number of antennae, and the maximum length\n of a transmitted Constant Tone Extension supported by the Controller.\n\n If the Controller does not support antenna switching, the value of\n Max_Switching_Pattern_Length shall still be valid but will not be used by the Host.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_Antenna_Information command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_antenna_information(
        p_return: *mut sdc_hci_cmd_le_read_antenna_information_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Periodic Advertising Receive Enable.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.88\n\n The HCI_LE_Set_Periodic_Advertising_Receive_Enable command will enable or\n disable reports for the periodic advertising train identified by the Sync_Handle\n parameter.\n\n The Enable parameter determines whether reporting and duplicate filtering are enabled\n or disabled. If the value is the same as the current state, the command has no effect.\n\n If the periodic advertising train corresponding to the Sync_Handle parameter does not\n exist, the Controller shall return the error code Unknown Advertising Identifier (0x42).\n\n If the Host sets both bits 0 and 1 of Enable and the Controller does not support the\n Periodic Advertising ADI Support feature, then the Controller shall return an error which\n should use the error code Unsupported Feature or Parameter Value (0x11).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Periodic_Advertising_Receive_Enable command has\n completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_periodic_adv_receive_enable(
        p_params: *const sdc_hci_cmd_le_set_periodic_adv_receive_enable_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Periodic Advertising Sync Transfer.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.89\n\n The HCI_LE_Periodic_Advertising_Sync_Transfer command is used to instruct the\n Controller to send synchronization information about the periodic advertising train\n identified by the Sync_Handle parameter to a connected device.\n\n The Service_Data parameter is a value provided by the Host for use by the Host of the\n peer device. It is not used by the Controller.\n\n The connected device is identified by the Connection_Handle parameter.\n\n If the periodic advertising train corresponding to the Sync_Handle parameter does not\n exist, the Controller shall return the error code Unknown Advertising Identifier (0x42).\n\n If the Connection_Handle parameter does not identify a current connection, the\n Controller shall return the error code Unknown Connection Identifier (0x02).\n\n If the remote device has not indicated support for the Periodic Advertising Sync Transfer\n - Recipient feature, the Controller shall return the error code Unsupported Remote\n Feature (0x1A).\n\n Note: This command may successfully complete after the periodic advertising\n synchronization information is queued for transmission but before it is actually sent.\n No indication is given as to how the recipient handled the information.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Periodic_Advertising_Sync_Transfer command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_periodic_adv_sync_transfer(
        p_params: *const sdc_hci_cmd_le_periodic_adv_sync_transfer_t,
        p_return: *mut sdc_hci_cmd_le_periodic_adv_sync_transfer_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Periodic Advertising Set Info Transfer.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.90\n\n The HCI_LE_Periodic_Advertising_Set_Info_Transfer command is used to instruct the\n Controller to send synchronization information about the periodic advertising in an\n advertising set to a connected device.\n\n The Advertising_Handle parameter identifies the advertising set. If the parameters in\n the advertising set have changed since the periodic advertising was first enabled, the\n current parameters  not the original ones  are sent.\n\n The Service_Data parameter is a value provided by the Host to identify the periodic\n advertising train to the peer device. It is not used by the Controller.\n\n The connected device is identified by the Connection_Handle parameter.\n\n If the advertising set corresponding to the Advertising_Handle parameter does not exist,\n the Controller shall return the error code Unknown Advertising Identifier (0x42).\n\n If periodic advertising is not currently in progress for the advertising set, the Controller\n shall return the error code Command Disallowed (0x0C).\n\n If the Connection_Handle parameter does not identify a current connection, the\n Controller shall return the error code Unknown Connection Identifier (0x02).\n\n If the remote device has not indicated support for the Periodic Advertising Sync Transfer\n - Recipient feature, the Controller shall return the error code Unsupported Remote\n Feature (0x1A).\n\n Note: This command may successfully complete after the periodic advertising\n synchronization information is queued for transmission but before it is actually sent.\n No indication is given as to how the recipient handled the information.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Periodic_Advertising_Set_Info_Transfer command has completed,\n an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_periodic_adv_set_info_transfer(
        p_params: *const sdc_hci_cmd_le_periodic_adv_set_info_transfer_t,
        p_return: *mut sdc_hci_cmd_le_periodic_adv_set_info_transfer_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Periodic Advertising Sync Transfer Parameters.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.91\n\n The HCI_LE_Set_Periodic_Advertising_Sync_Transfer_Parameters command is used\n to specify how the Controller will process periodic advertising synchronization\n information received from the device identified by the Connection_Handle parameter\n (the \"transfer mode\").\n\n The Mode parameter specifies the action to be taken when periodic advertising\n synchronization information is received. If Mode is 0x00, the Controller will ignore the\n information. Otherwise it will notify the Host and synchronize to the periodic advertising.\n Mode also specifies whether periodic advertising reports are initially enabled or disabled\n and whether duplicates are filtered.\n\n The Skip parameter specifies the number of consecutive periodic advertising packets\n that the receiver may skip after successfully receiving a periodic advertising packet.\n\n The Sync_Timeout parameter specifies the maximum permitted time between\n successful receives. If this time is exceeded, synchronization is lost.\n\n Irrespective of the value of the Skip parameter, the Controller should stop skipping\n packets before the Sync_Timeout would be exceeded.\n\n The CTE_Type parameter specifies whether to only synchronize to periodic advertising\n with certain types of Constant Tone Extension. If the periodic advertiser changes the\n type of the Constant Tone Extension after the Controller has synchronized with the\n periodic advertising, it shall remain synchronized.\n\n Note: A value of 0 (i.e. all bits clear) indicates that the presence or absence of a\n Constant Tone Extension is irrelevant.\n\n This command does not affect any processing of any periodic advertising\n synchronization information already received from the peer device, whether or not the\n Controller has yet synchronized to the periodic advertising train it describes.\n\n The parameter values provided by this command override those provided\n via the HCI_LE_Set_Default_Periodic_Advertising_Sync_Transfer_Parameters\n command (Section 7.8.92) or any preferences previously set using the\n HCI_LE_Set_Periodic_Advertising_Sync_Transfer_Parameters command on the same\n connection.\n\n If the Connection_Handle parameter does not identify a current connection, the\n Controller shall return the error code Unknown Connection Identifier (0x02).\n\n If the Host sets Mode to 0x03 and the Controller does not support the Periodic\n Advertising ADI Support feature, then the Controller shall return an error which should\n use the error code Unsupported Feature or Parameter Value (0x11).\n\n If the Host sets all the non-reserved bits of CTE_Type to 1, then the Controller should\n return an error using the error code Command Disallowed (0x0C).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Periodic_Advertising_Sync_Transfer_Parameters command\n has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params(
        p_params: *const sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_t,
        p_return: *mut sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Default Periodic Advertising Sync Transfer Parameters.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.92\n\n The HCI_LE_Set_Default_Periodic_Advertising_Sync_Transfer_Parameters command\n is used to specify the initial value for the mode, skip,\n timeout, and Constant Tone Extension type (set by the\n HCI_LE_Set_Periodic_Advertising_Sync_Transfer_Parameters command; see\n Section 7.8.91) to be used for all subsequent connections over the LE transport.\n\n The Mode parameter specifies the initial action to be taken. If Mode is 0x00, the\n Controller will ignore the information. Otherwise it will notify the Host and synchronize\n to the periodic advertising. Mode also specifies whether periodic advertising reports are\n initially enabled or disabled and whether duplicates are filtered.\n\n The Skip parameter specifies the number of consecutive periodic advertising packets\n that the receiver may skip after successfully receiving a periodic advertising packet.\n\n The Sync_Timeout parameter specifies the maximum permitted time between\n successful receives. If this time is exceeded, synchronization is lost.\n\n The CTE_Type parameter specifies whether to only synchronize to periodic advertising\n with certain types of Constant Tone Extension. If the periodic advertiser changes the\n type of the Constant Tone Extension after the Controller has synchronized with the\n periodic advertising, it shall remain synchronized.\n\n Note: A value of 0 (i.e. all bits clear) indicates that the presence or absence of a\n Constant Tone Extension is irrelevant.\n\n This command does not affect any existing connection.\n\n If the Host sets Mode to 0x03 and the Controller does not support the Periodic\n Advertising ADI Support feature, then the Controller shall return an error which should\n use the error code Unsupported Feature or Parameter Value (0x11).\n\n If the Host sets all the non-reserved bits of CTE_Type to 1, then the Controller should\n return an error using the error code Command Disallowed (0x0C).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Default_Periodic_Advertising_Sync_Transfer_Parameters\n command has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_default_periodic_adv_sync_transfer_params(
        p_params: *const sdc_hci_cmd_le_set_default_periodic_adv_sync_transfer_params_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Read Buffer Size The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.2\n\n This command is used to read the maximum size of the data portion of ACL data\n packets and isochronous data packets sent from the Host to the Controller. The Host\n shall fragment the data transmitted to the Controller according to these values so that\n the HCI ACL Data packets and HCI ISO Data packets will contain data up to this size\n (data includes optional fields in the HCI ISO Data packet, such as ISO_SDU_Length).\n The HCI_LE_Read_Buffer_Size command also returns the total number of HCI LE ACL\n Data packets and isochronous data packets that can be stored in the data buffers of the\n Controller. The HCI_LE_Read_Buffer_Size command shall be issued by the Host before\n it sends any data to an LE Controller (see Section 4.1.1). If the Controller supports HCI\n ISO Data packets, it shall return non-zero values for the ISO_Data_Packet_Length and\n Total_Num_ISO_Data_Packets parameters.\n\n If the Controller returns a length value of zero for ACL data packets, the Host shall use\n the HCI_Read_Buffer_Size command to determine the size of the data buffers (shared\n between BR/EDR and LE transports).\n\n Note: Both the HCI_Read_Buffer_Size command and the HCI_LE_Read_Buffer_Size\n command may return buffer length and number of packets parameter values that are\n nonzero. This allows a Controller to offer different buffers and number of buffers for\n BR/EDR data packets and LE data packets.\n\n The LE_ACL_Data_Packet_Length parameter shall be used to determine the maximum\n size of the L2CAP PDU fragments that are contained in ACL data packets, and which\n are transferred from the Host to the Controller to be broken up into packets by the Link\n Layer. The Total_Num_LE_ACL_Data_Packets parameter contains the total number of\n HCI ACL Data packets that can be stored in the data buffers of the Controller. The Host\n determines how to divide the buffers between different connection handles.\n\n The ISO_Data_Packet_Length parameter shall be used to determine the maximum\n size of the SDU fragments that are contained in isochronous data packets, and which\n are transferred from the Host to the Controller. The Total_Num_ISO_Data_Packets\n parameter contains the total number of isochronous data packets that can be stored\n in the data buffers of the Controller. The Host determines how to divide the buffers\n between different connection handle(s).\n\n Note: The LE_ACL_Data_Packet_Length and ISO_Data_Packet_Length return\n parameters do not include the length of the HCI ACL Data packet header or the HCI\n ISO Data packet header respectively.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_Buffer_Size command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_buffer_size_v2(p_return: *mut sdc_hci_cmd_le_read_buffer_size_v2_return_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Read ISO TX Sync.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.96\n\n This command is used to read the TX_Time_Stamp and Time_Offset of a transmitted\n SDU identified by the Packet_Sequence_Number on a CIS or BIS identified by the\n Connection_Handle parameter on the Central or Peripheral.\n\n The Packet_Sequence_Number parameter contains the sequence number of a\n transmitted SDU.\n\n The TX_Time_Stamp and Time_Offset parameters are described in 6] Part G,\n Section 3.3 and 6] Part G, Section 3.1 respectively. When the Connection_Handle\n identifies a CIS or BIS that is transmitting unframed PDUs, the value of Time_Offset\n returned shall be zero.\n\n If the Host issues this command with a connection handle that does not exist, or the\n connection handle is not associated with a CIS or BIS, the Controller shall return the\n error code Unknown Connection Identifier (0x02).\n\n If the Host issues this command on an existing connection handle for a CIS or BIS\n that is not configured for transmitting SDUs, the Controller shall return the error code\n Command Disallowed (0x0C).\n\n If the Host issues this command before an SDU has been transmitted by the Controller,\n the Controller shall return the error code Command Disallowed (0x0C).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_ISO_TX_Sync command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_iso_tx_sync(
        p_params: *const sdc_hci_cmd_le_read_iso_tx_sync_t,
        p_return: *mut sdc_hci_cmd_le_read_iso_tx_sync_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set CIG Parameters.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.97\n\n The HCI_LE_Set_CIG_Parameters command is used by a Centrals Host to create a\n CIG and to set the parameters of one or more CISes that are associated with a CIG in\n the Controller.\n\n The CIG_ID parameter identifies a CIG. This parameter is allocated by the Centrals\n Host and passed to the Peripherals Host through the Link Layers during the process\n of creating a CIS. If the CIG_ID does not exist, then the Controller shall first create a\n new CIG. Once the CIG is created (whether through this command or previously), the\n Controller shall modify or add CIS configurations in the CIG that is identified by the\n CIG_ID and update all the parameters that apply to the CIG.\n\n The SDU_Interval_C_To_P parameter specifies the time interval between the start of\n consecutive SDUs from the Centrals Host for all the CISes in the CIG. This parameter\n shall be ignored for all CISes that are unidirectional from Peripheral to Central.\n\n The SDU_Interval_P_To_C parameter specifies the time interval between the start\n of consecutive SDUs from the Peripherals Host for all the CISes in the CIG. This\n parameter shall be ignored for all CISes that are unidirectional from Central to\n Peripheral.\n The Worst_Case_SCA parameter shall be the worst-case sleep clock accuracy of all\n the Peripherals that will participate in the CIG. The Host should get the sleep clock\n accuracy from all the Peripherals before issuing this command. If the Host cannot get\n the sleep clock accuracy from all the Peripherals, it shall set the Worst_Case_SCA\n parameter to zero.\n\n Note: The Worst_Case_SCA parameter can be used by the Link Layer to better allow\n for clock drift when scheduling the CISes in the CIG. For example, if a CIS has\n more than two subevents, the Link Layer of the Central can set the timing of the\n subevents such that the worst case drift in the Peripheral's clock will not exceed 2 \n Sub_Interval. This prevents the Peripheral from synchronizing its timing to the wrong\n subevent (adjacent subevents cannot be on the same channel).\n\n The Packing parameter indicates the preferred method of arranging subevents\n of multiple CISes. The subevents can be arranged in Sequential or Interleaved\n arrangement (see 6] Part B, Section 4.5.14.2). This is a recommendation to the\n Controller which the Controller may ignore. This parameter shall be ignored when there\n is only one CIS in the CIG.\n\n The Framing parameter indicates the format of the CIS Data PDUs of the specified\n CISes' framing mode (see 6] Part G, Section 2) that the Host is requesting for the\n CIG. The Controller may use any framing mode permitted by 6] Part G, Table 2.1\n but shall set the framing mode of all the CISes in the CIG to the same mode. This\n overrides any framing mode previously set for the CIG.\n\n The Max_Transport_Latency_C_To_P parameter contains the maximum transport\n latency from the Central to the Peripheral, in milliseconds, as described in 6] Part\n G, Section 3.2.1 and 6] Part G, Section 3.2.2. This parameter shall be ignored for\n all CISes that are unidirectional from Peripheral to Central.\n\n The Max_Transport_Latency_P_To_C parameter contains the maximum transport\n latency from the Peripheral to the Central, in milliseconds, as described in 6] Part\n G, Section 3.2.1 and 6] Part G, Section 3.2.2. This parameter shall be ignored for\n all CISes that are unidirectional from Central to Peripheral.\n\n The CIS_Count parameter indicates the number of CIS configurations being modified or\n added by this command. The Controller shall set the CIS_Count return parameter equal\n to this.\n\n The CIS_IDparameter identifies a CIS and is set by the Centrals Host and passed to\n the Peripherals Host through the Link Layers during the process of establishing a CIS.\n\n The Max_SDU_C_To_Pparameter identifies the maximum size of an SDU from the\n Centrals Host. If the CIS is unidirectional from Peripheral to Central, this parameter\n shall be set to 0. If a CIS configuration that is being modified has a data path set in\n the Central to Peripheral direction and the Host has specified that Max_SDU_C_To_Pshall be set to zero, the Controller shall return the error code Command Disallowed\n (0x0C).\n\n The Max_SDU_P_To_Cparameter identifies the maximum size of an SDU from the\n Peripherals Host. If the CIS is unidirectional from Central to Peripheral, this parameter\n shall be set to 0. If a CIS configuration that is being modified has a data path set in\n the Peripheral to Central direction and the Host has specified that Max_SDU_P_To_Cshall be set to zero, the Controller shall return the error code Command Disallowed\n (0x0C).\n\n The PHY_C_To_Pparameter identifies which PHY to use for transmission from the\n Central to the Peripheral. The Host shall set at least one bit in this parameter and the\n Controller shall pick a PHY from the bits that are set.\n\n The PHY_P_To_Cparameter identifies which PHY to use for transmission from the\n Peripheral to the Central. The Host shall set at least one bit in this parameter and the\n Controller shall pick a PHY from the bits that are set.\n\n The RTN_C_To_P(Retransmission Number) parameter contains the number of times\n that a CIS Data PDU should be retransmitted from the Central to Peripheral before\n being acknowledged or flushed (irrespective of which CIS events the retransmission\n opportunities occur in). If the CIS is unidirectional from Peripheral to Central, this\n parameter shall be ignored. Otherwise, this parameter is a recommendation to the\n Controller which the Controller may ignore.\n\n The RTN_P_To_Cparameter contains the number of times that a CIS Data PDU\n should be retransmitted from the Peripheral to Central before being acknowledged or\n flushed (irrespective of which CIS events the retransmission opportunities occur in). If\n the CIS is unidirectional from Central to Peripheral, this parameter shall be ignored.\n Otherwise, this parameter is a recommendation to the Controller which the Controller\n may ignore.\n\n In each direction, if the Controller satisfies the recommendation, then every PDU\n will have at least RTN+1 opportunities for transmission (assuming that the initial\n transmission of that PDU happens at the earliest allowed subevent). The RTN value\n indicates that the Host is recommending that the Controller selects a combination of CIS\n parameters that satisfy the inequality:\n\n NSE  FT  NSE  BN  BN1  RTN + 1\n\n If the Status parameter is non-zero, then the state of the CIG and its CIS configurations\n shall not be changed by the command. If the CIG did not already exist, it shall not be\n created.\n If Status is zero, then the Controller shall set each Connection_Handleto the\n connection handle corresponding to the CIS configuration specified in CIS_IDIf the\n same CIS_ID is being reconfigured, the same connection handle shall be returned.\n\n The connection handle of a CIS shall refer to the CIS when it exists and to the\n configuration of the CIS stored in a CIG when the CIG exists but the CIS with that\n CIS_ID does not.\n\n If the Host issues this command when the CIG is not in the configurable state, the\n Controller shall return the error code Command Disallowed (0x0C).\n\n If the Host attempts to create a CIG or set parameters that exceed the maximum\n supported resources in the Controller, the Controller shall return the error code Memory\n Capacity Exceeded (0x07).\n\n If the Host attempts to set CIS parameters that exceed the maximum supported\n connections in the Controller, the Controller shall return the error code Connection Limit\n Exceeded (0x09).\n\n If the Host sets, in the PHY_C_To_Por PHY_P_To_Cparameters, a bit for a PHY\n that the Controller does not support, including a bit that is reserved for future use, the\n Controller shall return the error code Unsupported Feature or Parameter Value (0x11).\n\n If the Controller does not support asymmetric PHYs and the Host sets PHY_C_To_Pto a different value than PHY_P_To_Cthe Controller shall return the error code\n Unsupported Feature or Parameter Value (0x11).\n\n If the Host specifies an invalid combination of CIS parameters, the Controller shall\n return the error code Invalid HCI Command Parameters (0x12) or the error code\n Unsupported Feature or Parameter Value (0x11); it should return the error code Invalid\n HCI Command Parameters (0x12).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_CIG_Parameters command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_cig_params(
        p_params: *const sdc_hci_cmd_le_set_cig_params_t,
        p_return: *mut sdc_hci_cmd_le_set_cig_params_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set CIG Parameters Test.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.98\n\n The HCI_LE_Set_CIG_Parameters_Test command should only be used for testing\n purposes.\n\n The command is used by a Centrals Host to create a CIG and to set the parameters of\n one or more CISes that are associated with a CIG in the Controller.\n\n The CIG_ID parameter identifies a CIG. This parameter is allocated by the Centrals\n Host and passed to the Peripherals Host through the Link Layers during the process\n of creating a CIS. If the CIG_ID does not exist, then the Controller shall first create a\n new CIG. Once the CIG is created (whether through this command or previously), the\n Controller shall modify or add CIS configurations in the CIG that is identified by the\n CIG_ID and update all the parameters that apply to the CIG.\n\n The SDU_Interval_C_To_P parameter specifies the time interval of periodic SDUs from\n the Centrals Host.\n The SDU_Interval_P_To_C parameter specifies the time interval of periodic SDUs from\n the Peripherals Host.\n\n The FT_C_To_P parameter identifies the maximum time for a payload from the Central\n to Peripheral to be transmitted and re-transmitted, after which it is flushed (see 6]\n Part B, Section 4.5.13.5). This parameter is expressed in multiples of ISO_Interval.\n\n The FT_P_To_C parameter identifies the maximum time for a payload from the\n Peripheral to Central to be transmitted and re-transmitted, after which it is flushed\n (see 6] Part B, Section 4.5.13.5). This parameter is expressed in multiples of\n ISO_Interval.\n\n The ISO_Interval parameter specifies the time between two consecutive CIS anchor\n points.\n\n The CIS_Count parameter contains the number of CIS configurations being added or\n modified by this command. The Controller shall set the CIS_Count return parameter\n equal to this.\n\n The CIS_IDparameter identifies the CIS and is set by the Centrals Host and passed\n to the Peripherals Host through the Link Layers during the process of establishing a\n CIS.\n\n The Worst_Case_SCA parameter is the worst-case sleep clock accuracy of all the\n Peripherals that will participate in the CIG. The Host should get the sleep clock\n accuracy from all the Peripherals before issuing this command. In case the Host cannot\n get the sleep clock accuracy from all the Peripherals, it shall set the Worst_Case_SCA\n parameter to zero.\n\n Note: The Worst_Case_SCA parameter can be used by the Link Layer to better allow\n for clock drift when scheduling the CISes in the CIG. For example, if a CIS has\n more than two subevents, the Link Layer of the Central can set the timing of the\n subevents such that the worst case drift in the Peripheral's clock will not exceed 2 \n Sub_Interval. This prevents the Peripheral from synchronizing its timing to the wrong\n subevent (adjacent subevents cannot be on the same channel).\n\n The Packing parameter is used to indicate the preferred method of arranging subevents\n of multiple CISes. The subevents can be arranged in Sequential or Interleaved\n arrangement. This is a recommendation to the Controller which it may ignore. This\n parameter shall be ignored when there is only one CIS in the CIG.\n\n The Framing parameter specifies the framing mode (see 6] Part G, Section 2) that\n the Controller shall use for all the CISes in the CIG. This overrides any framing mode\n previously set for the CIG.\n\n The CIS_IDparameter is used to identify a CIS.\n The NSEparameter identifies the maximum number of subevents for each CIS in a\n CIG event.\n\n The Max_SDU_C_To_Pparameter identifies the maximum size of SDU from the\n Centrals Host. If the CIS is unidirectional from Peripheral to Central, this parameter\n shall be set to 0. If a CIS configuration that is being modified has a data path set in\n the Central to Peripheral direction and the Host has specified that Max_SDU_C_To_Pshall be set to zero, the Controller shall return the error code Command Disallowed\n (0x0C). The minimum value of the Max_SDU_Size parameter in the ISO Transmit Test\n mode when the Payload_Type = 1 or 2 shall be 4 octets.\n\n The Max_SDU_P_To_Cparameter identifies the maximum size of SDU from the\n Peripherals Host. If the CIS is unidirectional from Central to Peripheral, this parameter\n shall be set to 0. If a CIS configuration that is being modified has a data path set in\n the Peripheral to Central direction and the Host has specified that Max_SDU_P_To_Cshall be set to zero, the Controller shall return the error code Command Disallowed\n (0x0C).The minimum value of the Max_SDU parameter in the ISO Transmit Test mode\n when the Payload_Type = 1 or 2 shall be 4 octets.\n\n The Max_PDU_C_To_Pparameter identifies the maximum size PDU from the Central\n to Peripheral.\n\n The Max_PDU_P_To_Cparameter identifies the maximum size PDU from the\n Peripheral to Central.\n\n The PHY_C_To_Pparameter identifies the PHY to be used for transmission of\n packets from the Central to the Peripheral. The Host shall set only one bit in this\n parameter and the Controller shall use the PHY set by the Host.\n\n The PHY_P_To_Cparameter identifies the PHY to be used for transmission of\n packets from the Peripheral to the Central. The Host shall set only one bit in this\n parameter and the Controller shall use the PHY set by the Host.\n\n The BN_C_To_Pparameter identifies the burst number for Central to Peripheral (see\n 6] Part B, Section 4.5.13). If the CIS is unidirectional from Peripheral to Central, this\n parameter shall be set to zero.\n\n The BN_P_To_Cparameter identifies the burst number for Peripheral to Central (see\n 6] Part B, Section 4.5.13). If the CIS is unidirectional from Central to Peripheral, this\n parameter shall be set to zero.\n\n If the Status parameter is non-zero, then the state of the CIG and its CIS configurations\n shall not be changed by the command. If the CIG did not already exist, it shall not be\n created.\n If Status is zero, then the Controller shall set Connection_Handleto the connection\n handle corresponding to the CIS configuration specified in CIS_IDIf the same CIS_ID\n is being reconfigured, the same connection handle shall be returned.\n\n If the Host issues this command when the CIG is not in the configurable state, the\n Controller shall return the error code Command Disallowed (0x0C).\n\n If the Host attempts to create a CIG or set parameters that exceed the maximum\n supported resources in the Controller, the Controller shall return the error code Memory\n Capacity Exceeded (0x07).\n\n If the Host attempts to set CIS parameters that exceed the maximum supported\n connections in the Controller, the Controller shall return the error code Connection Limit\n Exceeded (0x09).\n\n If the Host attempts to set an invalid combination of CIS parameters, the Controller\n shall return the error code Invalid HCI Command Parameters (0x12) or the error code\n Unsupported Feature or Parameter Value (0x11); it should return the error code Invalid\n HCI Command Parameters (0x12).\n\n If the Host sets, in the PHY_C_To_Por PHY_P_To_Cparameters, a bit for a PHY\n that the Controller does not support, including a bit that is reserved for future use, the\n Controller shall return the error code Unsupported Feature or Parameter Value (0x11).\n\n If the Controller does not support asymmetric PHYs and the Host sets PHY_C_To_Pto a different value than PHY_P_To_Cthe Controller shall return the error code\n Unsupported Feature or Parameter Value (0x11).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_CIG_Parameters_Test command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_cig_params_test(
        p_params: *const sdc_hci_cmd_le_set_cig_params_test_t,
        p_return: *mut sdc_hci_cmd_le_set_cig_params_test_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Create CIS.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.99\n\n The HCI_LE_Create_CIS command is used by the Centrals Host to create one or\n more CISes using the connections identified by the ACL_Connection_Handle arrayed\n parameter.\n\n The CIS_Count parameter is the total number of CISes created by this command.\n\n The CIS_Connection_Handleparameter specifies the connection handle\n corresponding to the configuration of the CIS to be created and whose configuration\n is already stored in a CIG.\n\n The ACL_Connection_Handleparameter specifies the connection handle of\n the ACL connection associated with each CIS to be created. The list of\n the ACL_Connection_Handles shall be in the same order as the list of\n the CIS_Connection_Handles e.g., CIS_Connection_Handlewill connect to the\n Peripheral associated with the ACL_Connection_HandleIf this command is issued on the Central before the devices have performed the\n Feature Exchange procedure, then the Controller shall complete that procedure before\n initiating the Connected Isochronous Stream Creation procedure (see 6] Part B,\n Section 5.1.15).\n\n If any ACL_Connection_Handleis not the handle of an existing ACL connection or any\n CIS_Connection_Handleis not the handle of a CIS or CIS configuration, the Controller\n shall return the error code Unknown Connection Identifier (0x02).\n\n If the Host attempts to create a CIS that has already been created, the Controller shall\n return the error code Connection Already Exists (0x0B).\n\n If two different elements of the CIS_Connection_Handle arrayed parameter identify the\n same CIS, the Controller shall return the error code Invalid HCI Command Parameters\n (0x12).\n\n If the Host issues this command before all the HCI_LE_CIS_Established events from\n the previous use of the command have been generated, the Controller shall return the\n error code Command Disallowed (0x0C).\n If the Host issues this command on an ACL_Connection_Handle where the Controller is\n the Peripheral, the Controller shall return the error code Command Disallowed (0x0C).\n\n Note: The order of the CIS connection handles in this command does not\n relate to the order of connection handles in the return parameters of the\n HCI_LE_Set_CIG_Parameters command or the HCI_LE_Set_CIG_Parameters_Test\n command.\n\n If the Host issues this command when the Connected Isochronous Stream (Host\n Support) feature bit (see 6] Part B, Section 4.6.27) is not set, the Controller shall\n return the error code Command Disallowed (0x0C).\n\n If the Host specified an invalid combination of parameters in the\n HCI_LE_Set_CIG_Parameters or HCI_LE_Set_CIG_Parameters_Test command that\n created the CIS configuration, but the Controller could not detect the problem without\n knowing the properties of the ACL connection associated with the CIS, then the\n Controller shall return an error which should use the error code Unsupported Feature or\n Parameter Value (0x11).\n\n Note: If an error is reported in the HCI_Command_Status event, it means that no\n CIS is created and the Host cannot determine which CIS had the error. Therefore, in\n the case of an error that only affects one CIS of several, reporting the error in the\n HCI_LE_CIS_Established event for that CIS means that the remaining CISes are still\n created and the Host can determine which CIS had the error.\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_LE_Create_CIS command, the Controller sends\n the HCI_Command_Status event to the Host. An HCI_LE_CIS_Established event will\n be generated for each CIS when it is established or if it is disconnected or considered\n lost before being established; until all the events are generated, the command remains\n pending.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_create_cis(p_params: *const sdc_hci_cmd_le_create_cis_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Remove CIG.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.100\n\n The HCI_LE_Remove_CIG command is used by the Centrals Host to remove the CIG\n identified by CIG_ID.\n\n The CIG_ID parameter contains the identifier of the CIG.\n\n This command shall delete the CIG_ID and also delete the Connection_Handles of the\n CIS configurations stored in the CIG.\n\n This command shall also remove the isochronous data paths that are associated with\n the Connection_Handles of the CIS configurations, which is equivalent to issuing the\n HCI_LE_Remove_ISO_Data_Path command (see Section 7.8.110).\n\n If the Host tries to remove a CIG which is in the active state, then the Controller shall\n return the error code Command Disallowed (0x0C).\n\n If the Host issues this command with a CIG_ID that does not exist, the Controller shall\n return the error code Unknown Connection Identifier (0x02).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Remove_CIG command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_remove_cig(
        p_params: *const sdc_hci_cmd_le_remove_cig_t,
        p_return: *mut sdc_hci_cmd_le_remove_cig_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Accept CIS Request.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.101\n\n The HCI_LE_Accept_CIS_Request command is used by the Peripherals Host to\n inform the Controller to accept the request for the CIS that is identified by the\n Connection_Handle.\n\n The command shall only be issued after an HCI_LE_CIS_Request event has occurred.\n The event contains the Connection_Handle of the CIS.\n\n If the Peripherals Host issues this command with a Connection_Handle that does not\n exist, or the Connection_Handle is not for a CIS, the Controller shall return the error\n code Unknown Connection Identifier (0x02).\n\n If the Peripheral's Host issues this command with a Connection_Handle for a CIS that\n has already been established or that already has an HCI_LE_Accept_CIS_Request\n or HCI_LE_Reject_CIS_Request command in progress, the Controller shall return the\n error code Command Disallowed (0x0C).\n\n If the Centrals Host issues this command, the Controller shall return the error code\n Command Disallowed (0x0C).\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_LE_Accept_CIS_Request command,\n the Controller sends the HCI_Command_Status event to the Host. An\n HCI_LE_CIS_Established event will be generated when the CIS is established or is\n considered lost before being established.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_accept_cis_request(p_params: *const sdc_hci_cmd_le_accept_cis_request_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Reject CIS Request.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.102\n\n The HCI_LE_Reject_CIS_Request command is used by the Peripherals Host to\n inform the Controller to reject the request for the CIS that is identified by the\n Connection_Handle.\n\n The command shall only be issued after an HCI_LE_CIS_Request event has occurred.\n The event contains the Connection_Handle of the CIS.\n\n When this command succeeds, the Controller shall delete the Connection_Handle of\n the requested CIS.\n\n The Reason parameter indicates the reason for rejecting the CIS request.\n\n If the Peripheral's Host issues this command with a Connection_Handle that is not for a\n CIS, the Controller shall return the error code Unknown Connection Identifier (0x02).\n\n If the Peripheral's Host issues this command with a Connection_Handle for a CIS that\n has already been established or that already has an HCI_LE_Accept_CIS_Request\n or HCI_LE_Reject_CIS_Request command in progress, the Controller shall return the\n error code Command Disallowed (0x0C).\n\n If the Centrals Host issues this command, the Controller shall return the error code\n Command Disallowed (0x0C).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Reject_CIS_Request command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_reject_cis_request(
        p_params: *const sdc_hci_cmd_le_reject_cis_request_t,
        p_return: *mut sdc_hci_cmd_le_reject_cis_request_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Create BIG.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.103\n\n The HCI_LE_Create_BIG command is used to create a BIG with one or more BISes\n (see 6] Part B, Section 4.4.6). All BISes in a BIG have the same value for all\n parameters.\n\n The BIG_Handle contains the identifier of the BIG. This parameter is allocated by the\n Host and used by the Controller and the Host to identify a BIG.\n\n The Advertising_Handle identifies the associated periodic advertising train of the BIG\n (see 6] Part B, Section 4.4.5.1).\n\n The Num_BIS parameter contains the total number of BISes in the BIG.\n\n The SDU_Interval parameter contains the time interval of the periodic SDUs.\n\n The Max_SDU parameter contains the maximum size of an SDU.\n\n The Max_Transport_Latency parameter is the maximum transport latency (in\n milliseconds) as described in 6] Part G, Section 3.2.1 and 6] Part G,\n Section 3.2.2. This includes pre-transmissions.\n\n The RTN (Retransmission Number) parameter contains the number of times every PDU\n should be retransmitted, irrespective of which BIG events the retransmissions occur in.\n This is a recommendation to the Controller which the Controller may ignore.\n\n The PHY parameter is a bit field that indicates the PHY used for transmission of PDUs\n of BISes in the BIG. The Host shall set at least one bit in this parameter and the\n Controller shall pick a PHY from the bits set. If the Host sets, in the PHY parameter,\n a bit for a PHY that the Controller does not support, including a bit that is reserved\n for future use, then the Controller shall return the error code Unsupported Feature or\n Parameter Value (0x11).\n\n The Packing parameter is used to indicate the preferred method of arranging subevents\n of multiple BISes. The subevents can be arranged in Sequential or Interleaved\n arrangement. This is a recommendation to the Controller which it may ignore. This\n parameter shall be ignored when there is only one BIS in the BIG.\n\n The Framing parameter indicates the format of the BIS Data PDUs and the mode of\n framed PDUs that the Host is requesting the Controller to use on the specified BIG. The\n Controller may use any combination of format and mode permitted by 6] Part G,\n Table 2.1\n\n The Encryption parameter identifies the encryption mode of the BISes. If the Encryption\n parameter is set to 1 (encrypted), then the Broadcast_Code is used in the encryption of\n payloads (see 6] Part B, Section 4.4.6.10).\n\n The Broadcast_Code parameter is used to generate the encryption key for encrypting\n payloads of all BISes. When the Encryption parameter is set to 0 (unencrypted),\n the Broadcast_Code parameter shall be set to zero by the Host and ignored by the\n Controller.\n\n If the Controller cannot create all BISes of the BIG or if Num_BIS exceeds the maximum\n value supported by the Controller, then it shall return the error code Connection\n Rejected due to Limited Resources (0x0D).\n\n If the Advertising_Handle does not identify a periodic advertising train, the periodic\n advertising train is associated with another BIG, or the periodic advertising train has\n responses and the Controller does not support that, then the Controller shall return the\n error code Unknown Advertising Identifier (0x42).\n\n If the Host issues this command with a BIG_Handle for a BIG that is already created,\n then the Controller shall return the error code Command Disallowed (0x0C).\n\n If the Host specifies an invalid combination of BIG parameters, then the Controller shall\n return an error which should use the error code Invalid HCI Command Parameters\n (0x12).\n\n If the length of the associated periodic advertising, with the BIGInfo added to\n the ACAD, is greater than the maximum that the Controller can transmit within\n the periodic advertising interval (if periodic advertising is currently enabled) or the\n Periodic_Advertising_Interval_Max for the advertising set (if currently disabled), then the\n Controller shall return an error and should use the error code Packet Too Long (0x45).\n If advertising on the LE Coded PHY, then the S=8 coding shall be assumed unless\n the current advertising parameters require the use of S=2 for an advertising physical\n channel, in which case the S=2 coding shall be assumed for that advertising physical\n channel.\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_LE_Create_BIG command, the Controller sends\n the HCI_Command_Status event to the Host. When the HCI_LE_Create_BIG command\n has completed, the HCI_LE_Create_BIG_Complete event is generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_create_big(p_params: *const sdc_hci_cmd_le_create_big_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Create BIG Test.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.104\n\n The HCI_LE_Create_BIG_Test command should only be used for testing purposes.\n\n The command is used to create one or more BISes of a BIG (see 6] Part B,\n Section 4.4.6). All BISes in the BIG have the same values for all parameters.\n\n The BIG_Handle contains the identifier of the BIG. This parameter is allocated by the\n Host and used by the Controller and the Host to identify a BIG.\n\n The Advertising_Handle identifies the associated periodic advertising train of the BIG.\n\n The Num_BIS parameter contains the total number of BISes in the BIG.\n\n The SDU_Interval parameter specifies the time interval of the periodic SDUs.\n\n The ISO_Interval parameter contains the time duration between two consecutive BIG\n anchor points.\n\n The NSE (Number of SubEvents) parameter contains the total number of subevents\n that are used to transmit BIS Data PDUs for each BIS in a BIG event. The NSE\n parameter shall be greater than or equal to IRC  BN.\n The Max_SDU parameter contains the maximum size, in octets, of an SDU. The\n minimum value of the Max_SDU parameter in the ISO Transmit Test mode when the\n Payload_Type = 1 or 2 shall be 4.\n\n The Max_PDU parameter contains the maximum size of every BIS Data PDU for every\n BIS in the BIG.\n\n The PHY parameter is a bit field that indicates the PHY used for transmission of PDUs\n of BISes in the BIG. The Host shall set only one bit in this parameter and the Controller\n shall use the PHY set by the Host. If the Host sets, in the PHY parameter, a bit for\n a PHY that the Controller does not support, including a bit that is reserved for future\n use, the Controller shall return the error code Unsupported Feature or Parameter Value\n (0x11).\n\n The Packing parameter indicates the preferred method of arranging subevents\n of multiple BISes. The subevents can be arranged in Sequential or Interleaved\n arrangement. This is a recommendation to the Controller which it may ignore. This\n parameter shall be ignored when there is only one BIS in the BIG.\n\n The Framing parameter indicates the format of the BIS Data PDUs and the mode\n of framed PDUs (see 6] Part G, Section 2) that the Controller shall use on the\n specified BIG.\n\n The BN (Burst Number) parameter contains the number of new payloads for each BIS\n in a BIS event.\n\n The IRC (Immediate Repetition Count) parameter contains the number of times the\n scheduled data packet is transmitted (see 6] Part B, Section 4.4.6). The IRC\n parameter shall be an integer in the range 1 to (NSE  BN).\n\n The PTO (Pre_Transmission_Offset) parameter contains the offset in number of\n ISO_Intervals for pre transmissions of data packets (see 6] Part B, Section 4.4.6).\n\n The Encryption parameter identifies the encryption mode of the BISes in the BIG. If\n the Encryption parameter is set to 1 (encrypted), the Broadcast_Code is used in the\n encryption of payloads (see 6] Part B, Section 4.4.6).\n\n The Broadcast_Code parameter is a 16-octet field that is used to generate the session\n key to encrypt payloads of all BISes in the BIG. When the Encryption parameter is set to\n 0 (unencrypted), all 16 octets of the Broadcast_Code parameter shall be set to zero by\n the Host and ignored by the Controller.\n\n If the Controller cannot create all BISes of the BIG or if Num_BIS exceeds the maximum\n value supported by the Controller, it shall return the error code Connection Rejected due\n to Limited Resources (0x0D).\n If the Advertising_Handle does not identify a periodic advertising train, the periodic\n advertising train is associated with another BIG, or the periodic advertising train has\n responses and the Controller does not support that, the Controller shall return the error\n code Unknown Advertising Identifier (0x42).\n\n If the Host issues this command with a BIG_Handle for a BIG that is already created,\n the Controller shall return the error code Command Disallowed (0x0C).\n\n If the value of the Max_PDU, NSE, BN, IRC or PTO parameters exceeds the values\n supported by the Controller, the Controller shall return the error code Unsupported\n Feature or Parameter Value (0x11).\n\n If the Host specifies an invalid combination of BIG parameters, the Controller shall\n return an error. If the value of the NSE parameter is not an integer multiple of BN,\n or NSE is less than (IRC  BN), or the parameters are not in the specified range,\n these errors shall use the error code Unsupported Feature or Parameter Value (0x11).\n The errors in all other circumstances should use the error code Invalid HCI Command\n Parameters (0x12).\n\n If the length of the associated periodic advertising, with the BIGInfo added to the\n ACAD, is greater than the maximum that the Controller can transmit within the periodic\n advertising interval, then the Controller shall return an error and should use the error\n code Packet Too Long (0x45). If advertising on the LE Coded PHY, then the S=8 coding\n shall be assumed unless the current advertising parameters require the use of S=2 for\n an advertising physical channel, in which case the S=2 coding shall be assumed for that\n advertising physical channel.\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_LE_Create_BIG_Test command,\n the Controller sends the HCI_Command_Status event to the Host.\n When the HCI_LE_Create_BIG_Test command has completed, the\n HCI_LE_Create_BIG_Complete event is generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_create_big_test(p_params: *const sdc_hci_cmd_le_create_big_test_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Terminate BIG.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.105\n\n The HCI_LE_Terminate_BIG command is used to terminate a BIG identified by the\n BIG_Handle parameter. The command also terminates the transmission of all BISes\n of the BIG, destroys the associated connection handles of the BISes in the BIG and\n removes the data paths for all BISes in the BIG.\n\n The Reason parameter is used to indicate the reason why the BIG is to be terminated.\n\n If the BIG_Handle does not identify a BIG, the Controller shall return the error code\n Unknown Advertising Identifier (0x42).\n\n If the Controller is not the Isochronous Broadcaster for the BIG identified by\n BIG_Handle, the Controller shall return the error code Command Disallowed (0x0C).\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_LE_Terminate_BIG command, the Controller\n sends the HCI_Command_Status event to the Host.\n When the HCI_LE_Terminate_BIG command has completed, the\n HCI_LE_Terminate_BIG_Complete event will be generated.\n\n If the Host attempts to terminate a BIG while the process of establishment of the\n BIG is in progress (i.e. HCI_LE_Create_BIG_Complete event has not been generated)\n the process of establishment shall stop and the Controller shall generate the HCI_LE_-\n Create_BIG_Complete event to the Host with the error code Operation Cancelled by\n Host (0x44).\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_terminate_big(p_params: *const sdc_hci_cmd_le_terminate_big_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE BIG Create Sync.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.106\n\n The HCI_LE_BIG_Create_Sync command is used to synchronize to a BIG described in\n the periodic advertising train specified by the Sync_Handle parameter.\n\n The BIG_Handle parameter is assigned by the Host to identify the synchronized BIG.\n\n The Encryption parameter indicates whether the Broadcast_Code parameter is valid.\n\n The Broadcast_Code parameter is a 16-octet field that is used to generate the session\n key to encrypt or decrypt payloads of an encrypted BIS. Broadcast_Code shall be\n ignored by the Controller if Encryption is set to 0x00.\n\n If Encryption is set to 0x00 for an encrypted BIG or is set to 0x01 for an unencrypted\n BIG, then the Controller shall return the error Encryption Mode Not Acceptable (0x25).\n\n The MSE (Maximum Subevents) parameter is the maximum number of subevents that\n a Controller should listen to for data payloads in each interval for a BIS. The Controller\n may select any of the subevents to listen to.\n\n The BIG_Sync_Timeout parameter specifies the maximum permitted time between\n successful receptions of BIS PDUs. If this time is exceeded, synchronization is lost.\n When the Controller establishes synchronization and if the BIG_Sync_Timeout set by\n the Host is less than 6  ISO_Interval, the Controller shall set the timeout to 6 \n ISO_Interval.\n\n The Num_BIS parameter contains the number of BIS indices specified in the BIS\n arrayed parameter. The number of BISes requested may be a subset of the BISes\n available in the BIG.\n\n The BIS arrayed parameter is a list of indices corresponding to BIS(es) in the\n synchronized BIG. The list of BIS indices shall be in ascending order and shall not\n contain any duplicates. This list of specified BIS(es) may be all or a subset of BISes\n available in the BIG.\n\n If the Sync_Handle does not exist, the Controller shall return the error code Unknown\n Advertising Identifier (0x42).\n\n If the Host sends this command with a BIG_Handle that is already allocated, the\n Controller shall return the error code Command Disallowed (0x0C).\n\n If the information describing the BIG does not specify a PHY supported by the\n Controller or does not specify exactly one PHY, the Controller shall return the error\n code Unsupported Feature or Parameter Value (0x11).\n\n If the Num_BIS parameter is greater than the total number of BISes in the BIG, the\n Controller shall return the error code Unsupported Feature or Parameter Value (0x11).\n\n If MSE is less than the BN value for the BIS, then the Controller should return the error\n code Invalid HCI Command Parameters (0x12).\n\n If the Host sends this command when the Controller is in the process of synchronizing\n to any BIG, i.e. the HCI_LE_BIG_Sync_Established event has not been generated, the\n Controller shall return the error code Command Disallowed (0x0C).\n\n If the Controller is unable to receive PDUs from the specified number of BISes in the\n synchronized BIG, it shall return the error code Connection Rejected Due To Limited\n Resources (0x0D).\n\n If the Controller is already synchronized to the BIG specified by Sync_Handle, it shall\n return an error which should use the error code Command Disallowed (0x0C).\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_LE_BIG_Create_Sync command,\n the Controller sends the HCI_Command_Status event to the Host.\n When the HCI_LE_BIG_Create_Sync command has completed, the\n HCI_LE_BIG_Sync_Established event will be generated.\n\n If the Controller does not receive a BIS PDU within 6 BIS events of first listening, then it\n shall generate an HCI_LE_BIG_Sync_Established event that should have Status set to\n Connection Failed to be Established / Synchronization Timeout (0x3E).\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_big_create_sync(p_params: *const sdc_hci_cmd_le_big_create_sync_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE BIG Terminate Sync.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.107\n\n The HCI_LE_BIG_Terminate_Sync command is used to stop synchronizing or cancel\n the process of synchronizing to the BIG identified by the BIG_Handle parameter.\n The command also terminates the reception of BISes in the BIG specified in the\n HCI_LE_BIG_Create_Sync command, destroys the associated connection handles of\n the BISes in the BIG and removes the data paths for all BISes in the BIG.\n\n If the Host issues this command with a BIG_Handle that does not exist, the Controller\n shall return the error code Unknown Advertising Identifier (0x42).\n\n If the Host issues this command for a BIG which it is neither synchronized to nor in the\n process of synchronizing to, then the Controller shall return the error code Command\n Disallowed (0x0C).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_BIG_Terminate_Sync command has completed, an\n HCI_Command_Complete event shall be generated.\n\n If the Host attempts to terminate synchronization with a BIG while the process of\n synchronization with that BIG is in progress (i.e. HCI_LE_BIG_Sync_Established event\n has not been generated) the process of synchronization shall stop, and the Controller\n shall generate the HCI_LE_BIG_Sync_Established event to the Host with the error code\n Operation Cancelled by Host (0x44).\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_big_terminate_sync(
        p_params: *const sdc_hci_cmd_le_big_terminate_sync_t,
        p_return: *mut sdc_hci_cmd_le_big_terminate_sync_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Request Peer SCA.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.108\n\n This command is used to read the Sleep Clock Accuracy (SCA) of the peer device.\n\n The Connection_Handle parameter is the connection handle of the ACL connection.\n\n If the Host sends this command with a Connection_Handle that does not exist, or the\n Connection_Handle is not for an ACL the Controller shall return the error code Unknown\n Connection Identifier (0x02).\n\n If the Host sends this command and the peer device does not support the Sleep\n Clock Accuracy Updates feature, the Controller shall return the error code Unsupported\n Feature or Parameter Value (0x11) in the HCI_LE_Request_Peer_SCA_Complete\n event.\n\n If the Host issues this command when the Controller is aware (e.g., through a previous\n feature exchange) that the peer device's Link Layer does not support the Sleep Clock\n Accuracy Updates feature, the Controller shall return the error code Unsupported\n Remote Feature (0x1A).\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_LE_Request_Peer_SCA command,\n the Controller sends the HCI_Command_Status event to the Host.\n When the HCI_LE_Request_Peer_SCA command has completed, the\n HCI_LE_Request_Peer_SCA_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_request_peer_sca(p_params: *const sdc_hci_cmd_le_request_peer_sca_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Setup ISO Data Path.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.109\n\n The HCI_LE_Setup_ISO_Data_Path command is used to identify and create the\n isochronous data path between the Host and the Controller for a CIS, CIS configuration,\n or BIS identified by the Connection_Handle parameter. This command can also be used\n to configure a codec for each data path. When a connection is created no data paths\n are set up for that connection. When the command has completed successfully, data\n shall be allowed to flow over the specified path in the specified direction irrespective of\n the state of the other direction or any other path.\n\n The input and output directions are defined from the perspective of the Controller, so\n \"input\" refers to data flowing from the Host to the Controller.\n\n If the Host issues this command more than once for the same Connection_Handle\n and direction before issuing the HCI_LE_Remove_ISO_Data_Path command for that\n Connection_Handle and direction, the Controller shall return the error code Command\n Disallowed (0x0C).\n\n If the Host issues this command for a CIS on a Peripheral before it has issued the\n HCI_LE_Accept_CIS_Request command for that CIS, then the Controller shall return\n the error code Command Disallowed (0x0C).\n\n The Data_Path_Direction parameter specifies the direction for which the data path is\n being configured.\n\n The Data_Path_ID parameter specifies the data transport path used. When set to 0x00,\n the data path shall be over the HCI transport. When set to a value in the range\n 0x01 to 0xFE, the data path shall use a vendor-specific transport interface (e.g., a\n PCM interface) with logical transport numbers. The meanings of these logical transport\n numbers are vendor-specific.\n If the Host issues this command for a vendor-specific data transport path that has\n not been configured, the Controller shall return the error code Command Disallowed\n (0x0C).\n\n If the Host attempts to set a data path with a Connection Handle that does not exist or\n that is not for a CIS, CIS configuration, or BIS, the Controller shall return the error code\n Unknown Connection Identifier (0x02).\n\n If the Host attempts to set an output data path using a connection handle that is for an\n Isochronous Broadcaster, for an input data path on a Synchronized Receiver, or for a\n data path for the direction on a unidirectional CIS where BN is set to 0, the Controller\n shall return the error code Command Disallowed (0x0C).\n\n The Codec_ID parameter specifies the coding format used over the air.\n\n When Data_Path_Direction is set to 0x00 (input), the Controller_Delay parameter\n specifies the delay at the data source from the reference time of an SDU\n to the CIG reference point (see 6] Part B, Section 4.5.14.1) or BIG\n anchor point (see 6] Part B, Section 4.4.6.4). When Data_Path_Direction\n is set to 0x01 (output), Controller_Delay specifies the delay from the\n SDU_Synchronization_Reference to the point in time at which the Controller begins\n to transfer the corresponding data to the data path interface. The Host should use the\n HCI_Read_Local_Supported_Controller_Delay command to obtain a suitable value for\n Controller_Delay.\n\n Note: Controller vendors may provide additional guidance to the Host on how to\n select a suitable Controller_Delay value from the range of values provided by the\n HCI_Read_Local_Supported_Controller_Delay command for various configurations of\n the data path interface.\n\n The Codec_Configuration parameter specifies codec-specific configuration information\n for the specified direction.\n\n If the Host issues this command with Codec_Configuration_Length non-zero and\n Codec_ID set to transparent air mode, the Controller shall return the error code Invalid\n HCI Command Parameters (0x12).\n\n If the Host issues this command with codec-related parameters that exceed the\n bandwidth and latency allowed on the established CIS or BIS identified by the\n Connection_Handle parameter, the Controller shall return the error code Invalid HCI\n Command Parameters (0x12).\n\n If the Host issues this command when the CIS or BIS identified by Connection_Handle\n is in ISO Test mode (see Section 7.8.111, Section 7.8.112, and 6] Part B, Section 7)\n for the specified Data_Path_Direction, then the Controller shall return the error code\n Command Disallowed (0x0C).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Setup_ISO_Data_Path command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_setup_iso_data_path(
        p_params: *const sdc_hci_cmd_le_setup_iso_data_path_t,
        p_return: *mut sdc_hci_cmd_le_setup_iso_data_path_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Remove ISO Data Path.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.110\n\n The HCI_LE_Remove_ISO_Data_Path command is used to remove the input and/or\n output data path(s) associated with a CIS, CIS configuration, or BIS identified by the\n Connection_Handle parameter.\n\n The Data_Path_Direction parameter specifies which directions are to have the data\n path removed.\n\n If the Host issues this command with a Connection_Handle that does not exist or is not\n for a CIS, CIS configuration, or BIS, the Controller shall return the error code Unknown\n Connection Identifier (0x02).\n\n If the Host issues this command for a data path that has not been set up (using the\n HCI_LE_Setup_ISO_Data_Path command), the Controller shall return the error code\n Command Disallowed (0x0C).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Remove_ISO_Data_Path command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_remove_iso_data_path(
        p_params: *const sdc_hci_cmd_le_remove_iso_data_path_t,
        p_return: *mut sdc_hci_cmd_le_remove_iso_data_path_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE ISO Transmit Test.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.111\n\n The HCI_LE_ISO_Transmit_Test command should only be used in the ISO Test mode\n and only for testing purposes.\n\n The command is used to configure an established CIS or BIS specified by the\n Connection_Handle parameter, and transmit test payloads which are generated by the\n Controller.\n\n The Payload_Type parameter defines the configuration of SDUs in the payload.\n\n If the Host issues this command with a connection handle that does not exist, or the\n Connection_Handle parameter is not associated with a CIS or a BIS, then the Controller\n shall return the error code Unknown Connection Identifier (0x02).\n\n If the Host issues this command when the value of the transmit BN parameter of the\n CIS is set to zero, the Controller shall return the error code Unsupported Feature or\n Parameter Value (0x11).\n\n If the Host has set the input data path for the CIS or BIS identified by the connection\n handle, the Controller shall return the error code Command Disallowed (0x0C).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_ISO_Transmit_Test command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_iso_transmit_test(
        p_params: *const sdc_hci_cmd_le_iso_transmit_test_t,
        p_return: *mut sdc_hci_cmd_le_iso_transmit_test_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE ISO Receive Test.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.112\n\n The HCI_LE_ISO_Receive_Test command should only be used in the ISO Test mode\n and only for testing purposes.\n\n The command is used to configure an established CIS or a synchronized BIG specified\n by the Connection_Handle parameter to receive payloads.\n\n When using this command for a BIS, the Host shall synchronize with a BIG using the\n HCI_LE_BIG_Create_Sync command before invoking this command.\n\n The Payload_Type parameter defines the configuration of SDUs in the payload.\n\n If the Host issues this command with a connection handle that is not for an established\n CIS or a BIS, the Controller shall return the error code Unknown Connection Identifier\n (0x02).\n\n If the Host issues this command when the value of the receive BN parameter of the CIS\n or BIS is set to zero, the Controller shall return the error code Unsupported Feature or\n Parameter Value (0x11).\n\n If the Host has set the output data path for the CIS or BIS identified by the\n Connection_Handle parameter, the Controller shall return the error code Command\n Disallowed (0x0C).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_ISO_Receive_Test command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_iso_receive_test(
        p_params: *const sdc_hci_cmd_le_iso_receive_test_t,
        p_return: *mut sdc_hci_cmd_le_iso_receive_test_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE ISO Read Test Counters.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.113\n\n The HCI_LE_ISO_Read_Test_Counters command should only be used in the ISO Test\n mode and only for testing purposes.\n\n The command is used to read the test counters (see 6] Part B, Section 7) in the\n Controller which is configured in ISO Receive Test mode for a CIS or BIS specified by\n the Connection_Handle. Reading the test counters does not reset the test counters.\n\n The Received_SDU_Count, Missed_SDU_Count and Failed_SDU_Count parameters\n are set in the ISO Receive Test mode (see 6] Part B, Section 7.2).\n\n If the Host issues this command with a Connection_Handle parameter that is not for an\n established CIS or a BIS, the Controller shall return the error code Unknown Connection\n Identifier (0x02).\n\n If the Host issues this command for a CIS or BIS that is not configured in the ISO\n Receive Test mode, the Controller shall return the error code Unsupported Feature or\n Parameter Value (0x11).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_ISO_Read_Test_Counters command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_iso_read_test_counters(
        p_params: *const sdc_hci_cmd_le_iso_read_test_counters_t,
        p_return: *mut sdc_hci_cmd_le_iso_read_test_counters_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE ISO Test End.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.114\n\n The HCI_LE_ISO_Test_End command should only be used in the ISO Test mode and\n only for testing purposes.\n\n The command is used to terminate the ISO Transmit and/or Receive Test mode for a\n CIS or BIS specified by the Connection_Handle parameter but does not terminate the\n CIS or BIS.\n\n When the Host terminates the ISO Test mode for a CIS or BIS that is set to ISO\n Transmit Test mode only, the test counters in the return parameters shall be set to zero.\n\n When the Host terminates the ISO Test mode for a CIS or BIS that is set to the ISO\n Receive Test mode, the return parameters contain the values of the test counters as\n defined in 6] Part B, Section 7.\n\n If the Host issues this command with a Connection_Handle that is not for an established\n CIS or a BIS, the Controller shall return the error code Unknown Connection Identifier\n (0x02).\n\n If the Host issues this command for a CIS or BIS that is not configured in the ISO\n Transmit or Receive Test mode, the Controller shall return the error code Unsupported\n Feature or Parameter Value (0x11).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_ISO_Test_End command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_iso_test_end(
        p_params: *const sdc_hci_cmd_le_iso_test_end_t,
        p_return: *mut sdc_hci_cmd_le_iso_test_end_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Host Feature.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.115\n\n The HCI_LE_Set_Host_Feature command is used by the Host to set or clear a bit\n controlled by the Host in the Link Layer FeatureSet stored in the Controller (see 6]\n Part B, Section 4.6).\n\n The Bit_Number parameter specifies the bit position in the FeatureSet.\n\n The Bit_Value parameter specifies whether the feature is enabled or disabled.\n\n If Bit_Number specifies a feature bit that is not controlled by the Host, the Controller\n shall return the error code Unsupported Feature or Parameter Value (0x11).\n\n If Bit_Value is set to 0x01 and Bit_Number specifies a feature bit that requires support of\n a feature that the Controller does not support, the Controller shall return the error code\n Unsupported Feature or Parameter Value (0x11).\n\n If the Host issues this command while the Controller has a connection to another\n device, the Controller shall return the error code Command Disallowed (0x0C).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Host_Feature command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_host_feature(p_params: *const sdc_hci_cmd_le_set_host_feature_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Read ISO Link Quality.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.116\n\n This command returns the values of various counters related to link quality that are\n associated with the isochronous stream specified by the Connection_Handle parameter.\n\n This command may be issued on both the Central and Peripheral if the connection\n handle identifies a CIS and on the Synchronized Receiver if the connection handle\n identifies a BIS.\n\n Each of the remaining return parameters shall contain the current value of the\n corresponding counter; all the values shall be recorded at the same moment. Each\n counter shall be a 32-bit unsigned value, shall be initialized to zero when the\n isochronous stream is created, and shall be incremented by one as described below. If\n a counter is not associated with the type of isochronous stream specified, the value of\n the parameter shall be ignored.\n\n Counter Associated When Incremented\n Streams\n TX_UnACKed_Packets CIS The Link Layer does not receive an acknowledgment for\n a CIS Data PDU that it transmitted at least once by\n its\n flush point (see 6] Part B, Section 4.5.13.5).\n TX_Flushed_Packets CIS The Link Layer does not transmit a specific payload\n by\n its flush point.\n TX_Last_Subevent_- CIS in Peripher- The Link Layer transmits a CIS Data PDU in the last\n Packets al role subevent of a CIS event.\n Retransmitted_Packets CIS The Link Layer retransmits a CIS Data PDU.\n CRC_Error_Packets CIS and BIS The Link Layer receives a packet with a CRC error.\n Counter Associated When Incremented\n Streams\n RX_Unreceived_- CIS and BIS The Link Layer does not receive a specific\n payload by\n Packets its flush point (on a CIS) or the end of the\n event it is\n associated with (on a BIS; see 6] Part B,\n Section\n 4.4.6.6).\n Duplicate_Packets CIS The Link Layer receives a retransmission of a CIS\n Data\n PDU.\n\n Table 7.4: Isochronous streams link quality counters\n\n If the Connection_Handle parameter does not identify a current CIS connection or a BIS\n that the Controller is synchronized to, the Controller shall return the error code Unknown\n Connection Identifier (0x02).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_ISO_Link_Quality command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_iso_link_quality(
        p_params: *const sdc_hci_cmd_le_read_iso_link_quality_t,
        p_return: *mut sdc_hci_cmd_le_read_iso_link_quality_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Enhanced Read Transmit Power Level.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.117\n\n The HCI_LE_Enhanced_Read_Transmit_Power_Level command is used to read the\n current and maximum transmit power levels of the local Controller on the ACL\n connection identified by the Connection_Handle parameter and the PHY indicated by\n the PHY parameter.\n\n If the Host sets PHY to a value that the Controller does not support, including a value\n that is reserved for future use, the Controller shall return the error code Unsupported\n Feature or Parameter Value (0x11).\n\n If the Connection_Handle parameter does not identify a current ACL connection, the\n Controller shall return the error code Unknown Connection Identifier (0x02).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Enhanced_Read_Transmit_Power_Level command has completed,\n an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_enhanced_read_transmit_power_level(
        p_params: *const sdc_hci_cmd_le_enhanced_read_transmit_power_level_t,
        p_return: *mut sdc_hci_cmd_le_enhanced_read_transmit_power_level_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Read Remote Transmit Power Level.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.118\n\n The HCI_LE_Read_Remote_Transmit_Power_Level command is used to read the\n transmit power level used by the remote Controller on the ACL connection that is\n identified by the Connection_Handle parameter and the PHY indicated by the PHY\n parameter.\n\n The local Controller may use the remote transmit power level value obtained from a\n prior Power Change Indication or Power Control Request procedure (see 6] Part B,\n Section 5.1.17 and 6] Part B, Section 5.1.18). If the Controller chooses not to use\n these prior values, or if no prior value is available for one or more of the remote transmit\n power level, maximum transmit power level, or minimum transmit power level, the local\n Controller shall initiate a new Power Control Request procedure to obtain the remote\n transmit power level.\n\n If the Host sets PHY to a value that the Controller does not support, including a value\n that is reserved for future use, the Controller shall return the error code Unsupported\n Feature or Parameter Value (0x11).\n\n If the Connection_Handle parameter does not identify a current ACL connection, the\n Controller shall return the error code Unknown Connection Identifier (0x02).\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_LE_Read_Remote_Transmit_Power_Level\n command, the Controller shall send the HCI_Command_Status event to the Host.\n When the Controller has determined the remote transmit power, it shall generate an\n HCI_LE_Transmit_Power_Reporting event with Reason 0x02.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_remote_transmit_power_level(
        p_params: *const sdc_hci_cmd_le_read_remote_transmit_power_level_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Path Loss Reporting Parameters.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.119\n\n The HCI_LE_Set_Path_Loss_Reporting_Parameters command is used to set the\n path loss threshold reporting parameters for the ACL connection identified by the\n Connection_Handle parameter.\n\n The path loss threshold-based mechanism is described in 6] Part B, Section 4.5.16.\n For each zone boundary, the upwards boundary shall equal the threshold plus the\n hysteresis and the downwards boundary shall equal the threshold minus the hysteresis.\n\n If the Host issues this command with High_Threshold+High_Hysteresis greater than\n 0xFF or with Low_Threshold less than Low_Hysteresis, the Controller shall return the\n error code Invalid HCI Command Parameters (0x12).\n\n If the Host issues this command with Low_Threshold greater than High_Threshold\n or with Low_Threshold+Low_Hysteresis greater than High_ThresholdHigh_Hysteresis,\n the Controller shall return the error code Invalid HCI Command Parameters (0x12).\n\n The Min_Time_Spent parameter indicates the minimum time that the Controller shall\n observe the path loss has crossed the threshold before the Controller generates an\n event for the threshold crossing. The Host should specify a suitable value based on the\n connection interval, subrate factor, and Peripheral latency.\n\n If the Host issues this command when path loss monitoring is enabled, the Controller\n shall override the existing path loss threshold reporting parameters with the parameters\n provided in this command.\n\n The High_Threshold and the Low_Threshold parameters are common to all PHYs\n supported by the Controller. However, the Host can reissue this command with suitable\n parameters whenever a PHY switch is detected.\n\n If the Connection_Handle parameter does not identify a current ACL connection, the\n Controller shall return the error code Unknown Connection Identifier (0x02).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Path_Loss_Reporting_Parameters command has completed,\n an HCI_Command_Complete event shall be generated.\n\n If the Host issues this command when path loss monitoring is enabled, and\n if the new parameters mean that the path loss is now in a different zone,\n an HCI_LE_Path_Loss_Threshold event shall be generated as soon as possible\n irrespective of the Min_Time_Spent parameter and the timer shall be reset.\n\n If the Host issues this command with High_Threshold parameter set to 0xFF,\n then the Controller shall not generate an HCI_LE_Path_Loss_Threshold event with\n Zone_Entered set to 0x02.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_path_loss_reporting_params(
        p_params: *const sdc_hci_cmd_le_set_path_loss_reporting_params_t,
        p_return: *mut sdc_hci_cmd_le_set_path_loss_reporting_params_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Path Loss Reporting Enable.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.120\n\n The HCI_LE_Set_Path_Loss_Reporting_Enable command is used to enable or disable\n path loss reporting for the ACL connection identified by the Connection_Handle\n parameter.\n\n If the Enable parameter is set to 0x01 and no prior LE Power Control Request\n procedure has been initiated on the ACL connection, then the Controller may need\n to initiate a new LE Power Control Request procedure on that ACL.\n\n Path loss reporting is disabled when the connection is first created.\n\n If the Host issues this command before it has issued the\n HCI_LE_Set_Path_Loss_Reporting_Parameters command on this connection, the\n Controller shall return the error code Command Disallowed (0x0C).\n\n If the Connection_Handle parameter does not identify a current ACL connection, the\n Controller shall return the error code Unknown Connection Identifier (0x02).\n\n Enabling path loss monitoring when it is already enabled or disabling path loss\n monitoring when it is already disabled has no effect.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Path_Loss_Reporting_Enable command has completed, an\n HCI_Command_Complete event shall be generated.\n\n When reporting is enabled and was previously disabled, the Controller shall generate\n an HCI_LE_Path_Loss_Threshold event as soon as it has a reliable measurement\n of the path loss. If the Controller has to query the remote Controller for its transmit\n power level, then it shall generate this event within Tpath_loss_enable from the time it\n receives a response to its query. Otherwise, the Controller shall generate this event\n within Tpath_loss_enable from the time the command is issued. Tpath_loss_enable shall be\n Min_Time_Spent + 6 connection events or, if longer, 2 connection events where the\n Controller actually receives a packet from the peer, where Min_Time_Spent is specified\n by the HCI_LE_Set_Path_Loss_Reporting_Parameters command.\n\n After the initial event on reporting being enabled, the Controller shall generate this\n event each time it determines that the path loss has moved to a different zone and\n stayed in that zone for Min_Time_Spent.As stated in 6] Part B, Section 4.5.16, two\n consecutive events must not indicate the same zone.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_path_loss_reporting_enable(
        p_params: *const sdc_hci_cmd_le_set_path_loss_reporting_enable_t,
        p_return: *mut sdc_hci_cmd_le_set_path_loss_reporting_enable_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Transmit Power Reporting Enable.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.121\n\n The HCI_LE_Set_Transmit_Power_Reporting_Enable command is used to enable or\n disable the reporting to the local Host of transmit power level changes in the local\n and remote Controllers for the ACL connection identified by the Connection_Handle\n parameter.\n\n If the Remote_Enable parameter is set to 0x01 and no prior LE Power Control Request\n procedure has been initiated on the ACL connection, then the Controller shall initiate a\n new LE Power Control Request procedure on that ACL.\n\n Reporting is disabled when the connection is first created.\n\n If the Connection_Handle parameter does not identify a current ACL connection, the\n Controller shall return the error code Unknown Connection Identifier (0x02).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Transmit_Power_Reporting_Enable command has completed,\n an HCI_Command_Complete event shall be generated.\n\n When local reporting is enabled, the Controller shall generate an\n HCI_LE_Transmit_Power_Reporting event with Reason 0x00 each time the local\n transmit power level is changed.\n\n When remote reporting is enabled, the Controller shall generate an\n HCI_LE_Transmit_Power_Reporting event with Reason 0x01 each time it becomes\n aware that the remote transmit power level has changed.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_transmit_power_reporting_enable(
        p_params: *const sdc_hci_cmd_le_set_transmit_power_reporting_enable_t,
        p_return: *mut sdc_hci_cmd_le_set_transmit_power_reporting_enable_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Data Related Address Changes.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.122\n\n The HCI_LE_Set_Data_Related_Address_Changes command specifies circumstances\n when the Controller shall refresh any Resolvable Private Address used by the\n advertising set identified by the Advertising_Handle parameter, whether or not the\n address timeout period has been reached. This command may be used while\n advertising is enabled.\n\n The Change_Reasons parameter specifies the reason(s) for refreshing addresses. The\n default when an advertising set is created, or if legacy advertising commands (see\n Section 3.1.1) are used, is for all bits to be clear.\n\n If extended advertising commands (see Section 3.1.1) are being used and the\n advertising set corresponding to the Advertising_Handle parameter does not exist, or\n if no command specified in Table 3.2 has been used, then the Controller shall return the\n error code Unknown Advertising Identifier (0x42).\n\n If legacy advertising commands are being used, the Controller shall ignore the\n Advertising_Handle parameter.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Data_Related_Address_Changes command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_data_related_address_changes(
        p_params: *const sdc_hci_cmd_le_set_data_related_address_changes_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Default Subrate.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.123\n\n The HCI_LE_Set_Default_Subrate command is used by the Host to set the initial\n values for the acceptable parameters for subrating requests, as defined by the HCI_LE\n Subrate_Request command (see Section 7.8.124), for all future ACL connections where\n the Controller is the Central. This command does not affect any existing connection.\n\n The parameters have the same meanings as those in the HCI_LE_Subrate_Request\n command.\n\n If the Host issues this command with Subrate_Max  (Max_Latency + 1) greater than\n 500, then the Controller shall return the error code Invalid HCI Command Parameters\n (0x12).\n\n If the Host issues this command with Subrate_Max less than Subrate_Min, then the\n Controller shall return the error code Invalid HCI Command Parameters (0x12).\n\n If the Host issues this command with Continuation_Number greater than or equal to\n Subrate_Max, then the Controller shall return the error code Invalid HCI Command\n Parameters (0x12).\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_LE_Set_Default_Subrate command, the\n Controller sends the HCI_Command_Complete event to the Host.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_default_subrate(p_params: *const sdc_hci_cmd_le_set_default_subrate_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Subrate Request.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.124\n\n The HCI_LE_Subrate_Request command is used by a Central or a Peripheral to\n request a change to the subrating factor and/or other parameters (see 6] Part B,\n Section 4.5.1) applied to an existing connection using the Connection Subrate Update\n procedure.\n\n The Subrate_Min and Subrate_Max parameters specify the range of acceptable\n subrating factors being requested.\n\n The Max_Latency parameter specifies the maximum Peripheral latency in units of\n subrated connection events. The same maximum shall apply irrespective of the\n subrating factor actually chosen.\n\n The Continuation_Number parameter specifies the number of underlying connection\n intervals to remain active after a packet (other than an empty packet) is transmitted or\n received.\n\n The Supervision_Timeout parameter specifies the link supervision timeout for the\n connection. The Supervision_Timeout, in milliseconds, shall be greater than 2  current\n connection interval  Subrate_Max  (Max_Latency + 1).\n\n If this command is issued on the Central, the following rules shall apply when the\n Controller initiates the Connection Subrate Update procedure (see 6] Part B,\n Section 5.1.19):\n\n  The Peripheral latency shall be less than or equal to Max_Latency.\n  The subrate factor shall be between Subrate_Min and Subrate_Max.\n  The continuation number shall be equal to the lesser of Continuation_Number and\n (subrate factor - 1).\n  The connection supervision timeout shall be equal to Supervision_Timeout.\n\n If this command is issued on the Central, it also sets the acceptable parameters\n for requests from the Peripheral (see 6] Part B, Section 5.1.20). The\n acceptable parameters set by this command override those provided via the\n HCI_LE_Set_Default_Subrate command or any values set by previous uses of this\n command on the same connection.\n\n If this command is issued on the Central before the devices have performed the Feature\n Exchange procedure, then the Controller shall complete that procedure before initiating\n the Connection Subrate Update procedure.\n\n If this command is issued on the Peripheral, the following rules shall apply when the\n Controller initiates the Connection Subrate Request procedure:\n\n  The Peripheral latency shall be less than or equal to Max_Latency.\n  The minimum and maximum subrate factors shall be between Subrate_Min and\n Subrate_Max.\n  The continuation number shall be equal to the lesser of Continuation_Number and\n (maximum subrate factor - 1).\n  The connection supervision timeout shall be equal to Supervision_Timeout.\n\n If the Connection_Handle parameter does not identify a current ACL connection, the\n Controller shall return the error code Unknown Connection Identifier (0x02).\n\n If the Host issues this command with parameters such that Subrate_Max \n (Max_Latency + 1) is greater than 500 or the current connection interval  Subrate_Max\n  (Max_Latency + 1) is greater than or equal to half the Supervision_Timeout\n parameter, the Controller shall return the error code Invalid HCI Command Parameters\n (0x12).\n\n If the Host issues this command with Subrate_Max less than Subrate_Min, the\n Controller shall return the error code Invalid HCI Command Parameters (0x12).\n\n If the Host issues this command with Continuation_Number greater than or equal to\n Subrate_Max, then the Controller shall return the error code Invalid HCI Command\n Parameters (0x12).\n\n If the Central's Host issues this command when the Connection Subrating (Host\n Support) bit is not set in the Peripheral's FeatureSet, the Controller shall return the\n error code Unsupported Remote Feature (0x1A).\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_LE_Subrate_Request command, the Controller\n sends the HCI_Command_Status event to the Host. An HCI_LE_Subrate_Change\n event shall be generated when the Connection Subrate Update procedure has\n completed.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_subrate_request(p_params: *const sdc_hci_cmd_le_subrate_request_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Extended Advertising Parameters The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.53\n\n The HCI_LE_Set_Extended_Advertising_Parameters command is used by the Host to\n set the advertising parameters.\n The Advertising_Handle parameter identifies the advertising set whose parameters are\n being configured.\n\n The Advertising_Event_Properties parameter describes the type of advertising event\n that is being configured and its basic properties. The type shall be one supported by the\n Controller. In particular, the following restrictions apply to this parameter:\n\n  If legacy advertising PDU types are being used, then the parameter value shall be\n one of those specified in Table 7.3. If the advertising set already contains data, the\n type shall be one that supports advertising data and the amount of data shall not\n exceed 31 octets.\n\n Advertising\n Event Advertising\n Event Type PDU Type Properties Data\n\n Connectable and scannable ADV_IND 0b00010011 Supported\n undirected\n\n Connectable directed ADV_DIRECT_IND 0b00010101 Not allowed\n (low duty cycle)\n\n Connectable directed ADV_DIRECT_IND 0b00011101 Not allowed\n (high duty cycle)\n\n Scannable undirected ADV_SCAN_IND 0b00010010 Supported\n\n Non-connectable and non- ADV_NONCONN_IND 0b00010000 Supported\n scannable undirected\n\n Table 7.3: Advertising_Event_Properties values for legacy PDUs\n\n  If extended advertising PDU types are being used (bit 4 = 0), then the advertisement\n shall not be both connectable and scannable (bits 0 and 1 must not both be set to 1)\n and high duty cycle directed connectable advertising ( 3.75 ms advertising interval)\n shall not be used (bit 3 = 0).\n\n If the Advertising_Event_Properties parameter does not describe an event type\n supported by the Controller, contains an invalid bit combination, or specifies a type\n that does not support advertising data when the advertising set already contains some,\n the Controller shall return the error code Invalid HCI Command Parameters (0x12).\n\n The Own_Address_Type parameter shall be ignored for undirected anonymous\n advertising (bit 2 = 0 and bit 5 = 1).\n\n If Directed advertising is selected, the Peer_Address_Type and Peer_Address shall be\n valid and the Advertising_Filter_Policy parameter shall be ignored.\n\n The Primary_Advertising_Interval_Min parameter shall be less than or equal to the\n Primary_Advertising_Interval_Max parameter. The Primary_Advertising_Interval_Min\n and Primary_Advertising_Interval_Max parameters should not be the same value so\n that the Controller can choose the best advertising interval given other activities.\n\n For high duty cycle connectable directed advertising event type (ADV_DIRECT_IND),\n the Primary_Advertising_Interval_Min and Primary_Advertising_Interval_Max\n parameters are not used and shall be ignored.\n\n If the primary advertising interval range provided by the Host\n (Primary_Advertising_Interval_Min, Primary_Advertising_Interval_Max) does not\n overlap with the advertising interval range supported by the Controller, then the\n Controller shall return the error code Unsupported Feature or Parameter Value (0x11).\n\n The Primary_Advertising_Channel_Map is a bit field that indicates the advertising\n channel indices that shall be used when transmitting advertising packets. At least one\n channel bit shall be set in the Primary_Advertising_Channel_Map parameter.\n\n The Own_Address_Type parameter specifies the type of address being used in\n the advertising packets. For random addresses, the address is specified by the\n HCI_LE_Set_Advertising_Set_Random_Address command.\n\n If Own_Address_Type equals 0x02 or 0x03, the Peer_Address parameter contains\n the peers Identity Address and the Peer_Address_Type parameter contains the\n peers Identity Type (i.e., 0x00 or 0x01). These parameters are used to locate the\n corresponding local IRK in the resolving list; this IRK is used to generate their own\n address used in the advertisement.\n\n The Advertising_TX_Power parameter indicates the maximum power level at which the\n advertising packets are to be transmitted on the advertising physical channels. The\n Controller shall choose a power level lower than or equal to the one specified by the\n Host.\n\n The Primary_Advertising_PHY parameter indicates the PHY on which the advertising\n packets are transmitted on the primary advertising physical channel. If legacy\n advertising PDUs are being used, the Primary_Advertising_PHY shall indicate the LE\n 1M PHY. The Secondary_Advertising_PHY parameter indicates the PHY on which the\n advertising packets are be transmitted on the secondary advertising physical channel.\n If the Host specifies a PHY that is not supported by the Controller, including a value\n that is reserved for future use, it should return the error code Unsupported Feature or\n Parameter Value (0x11). If Constant Tone Extensions are enabled for the advertising set\n and Secondary_Advertising_PHY specifies a PHY that does not allow Constant Tone\n Extensions, the Controller shall return the error code Command Disallowed (0x0C).\n\n If the Primary_Advertising_PHY indicates the LE Coded PHY, then the\n Primary_Advertising_PHY_Options shall indicate the Host's preference or requirement\n concerning coding scheme. Otherwise, Primary_Advertising_PHY_Options shall\n be ignored. If the Secondary_Advertising_PHY indicates the LE Coded PHY,\n then the Secondary_Advertising_PHY_Options shall indicate the Host's preference\n or requirement concerning coding scheme (including for periodic advertising).\n Otherwise, Secondary_Advertising_PHY_Options shall be ignored. If the Host\n specifies that it requires a specific coding (i.e., value 0x03 or 0x04) in the\n Primary_Advertising_PHY_Options or Secondary_Advertising_PHY_Options and the\n Controller supports the LE Feature (Advertising Coding Selection) but is currently\n unable to provide all the required settings, then the Controller shall return the error\n code Command Disallowed (0x0C).\n\n The Secondary_Advertising_Max_Skip parameter is the maximum number of\n advertising events that can be skipped before the AUX_ADV_IND can be sent.\n\n The Advertising_SID parameter specifies the value to be transmitted in the Advertising\n SID subfield of the ADI field of the Extended Header of those advertising physical\n channel PDUs that have an ADI field. If the advertising set only uses PDUs that do not\n contain an ADI field, Advertising_SID shall be ignored.\n\n The Scan_Request_Notification_Enable parameter indicates whether the Controller\n shall send notifications upon the receipt of a scan request PDU that is in response\n to an advertisement from the specified advertising set that contains its device address\n and is from a scanner that is allowed by the advertising filter policy.\n\n The Controller shall set the Selected_TX_Power parameter to the transmit power that\n it will use for transmitting the advertising packets for the specified advertising set. The\n Controller shall only change this value if requested by the Host. If the radiated power\n level will vary between packets (e.g., because of frequency-dependent properties of the\n transmitter) then the value should be the best estimate of the maximum power used.\n\n If the Host issues this command when advertising is enabled for the specified\n advertising set, the Controller shall return the error code Command Disallowed (0x0C).\n\n If the Host issues this command when periodic advertising is enabled for the specified\n advertising set and connectable, scannable, legacy, or anonymous advertising is\n specified, the Controller shall return the error code Invalid HCI Command Parameters\n (0x12).\n\n If periodic advertising is enabled for the advertising set and the\n Secondary_Advertising_PHY parameter does not specify the PHY currently being\n used for the periodic advertising, the Controller shall return the error code Command\n Disallowed (0x0C).\n\n If the Advertising_Handle does not identify an existing advertising set and the Controller\n is unable to support a new advertising set at present, the Controller shall return the error\n code Memory Capacity Exceeded (0x07).\n\n If the advertising set already contains advertising data or scan response data, extended\n advertising is being used, and the length of the data is greater than the maximum that\n the Controller can transmit within the longest possible auxiliary advertising segment\n consistent with the parameters, the Controller shall return the error code Packet Too\n Long (0x45). If advertising on the LE Coded PHY, the S=8 coding shall be assumed\n unless the current advertising parameters require the use of S=2 for an advertising\n physical channel, in which case the S=2 coding shall be assumed for that advertising\n physical channel.\n\n If the Controller does not support the LE Feature (Advertising Coding\n Selection) and the Host does not set both Primary_Advertising_PHY_Options and\n Secondary_Advertising_PHY_Options to zero, the Controller shall return the error code\n Unsupported Feature or Parameter Value (0x11).\n\n Missing parameters:\n\n When a version of this command is issued that does not include all the\n parameters, the following values shall be used:\n\n Parameter Value\n\n Primary_Advertising_PHY_Options 0x00\n\n Secondary_Advertising_PHY_Options 0x00\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Extended_Advertising_Parameters command has\n completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_ext_adv_params_v2(
        p_params: *const sdc_hci_cmd_le_set_ext_adv_params_v2_t,
        p_return: *mut sdc_hci_cmd_le_set_ext_adv_params_v2_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Periodic Advertising Subevent Data.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.125\n\n The HCI_LE_Set_Periodic_Advertising_Subevent_Data command is used by the\n Host to set the data for one or more subevents of PAwR in reply to an\n HCI_LE_Periodic_Advertising_Subevent_Data_Request event. The data for a subevent\n shall be transmitted only once.\n\n When using more than one instance of this command to provide data, the Host may\n provide the data in any order. For example, if providing data for subevents 0 and 1 in\n separate commands, the first command can contain either subevent.\n\n The Advertising_Handle parameter identifies the advertising set whose periodic\n advertising subevent data is being set. If the corresponding advertising set does not\n already exist, then the Controller shall return the error code Unknown Advertising\n Identifier (0x42). If the corresponding advertising set exists but has not been configured\n for Periodic Advertising with Responses, then the Controller shall return the error code\n Command Disallowed (0x0C).\n\n The Num_Subevents_With_Data parameter is the number of subevent data contained\n in the parameter arrays.\n\n The Subeventparameter identifies the subevent of the PAwR that is being set.\n If the Host provides a subevent value that is outside of the range of subevents\n requested using the HCI_LE_Periodic_Advertising_Subevent_Data_Request event,\n then the Controller shall return the error code Command Disallowed (0x0C). If two\n elements of the array specify the same subevent, then the Controller shall return an\n error code which should be Invalid HCI Command Parameters (0x12).\n\n The Response_Slot_Startand Response_Slot_Countparameters identify the\n starting response slot and the number of response slots that are expected to be used in\n this subevent.\n Note: If the Host does not expect any responses in a subevent, then it can\n set Response_Slot_Countfor that subevent to 0. If the Host expects one or\n more responses in a future subevent, then it can set Response_Slot_Startand\n Response_Slot_Countfor that subevent appropriately either in the same command\n or a subsequent use of this command.\n\n The Subevent_Data_Lengthparameter determines the length of the Subevent_Data\n that is significant.\n\n The Subevent_Dataparameter contains the advertising data to be transmitted in\n the subevent of the advertising set. If the combined data length is greater than the\n maximum that the Controller can transmit within the current subevent interval, then all\n data shall be discarded and the Controller shall return the error code Packet Too Long\n (0x45). If advertising on the LE Coded PHY, then the S=8 coding shall be assumed\n unless the current advertising parameters require the use of S=2 for an advertising\n physical channel, in which case the S=2 coding shall be assumed for that advertising\n physical channel.\n\n If the Subevent_Data cannot be transmitted because, for example, the subevent where\n this data would have been sent has already passed or is too early, then the Controller\n shall return the error code Too Late (0x46) or Too Early (0x47) and discard the data.\n\n If the Host sends this command without the Controller having issued an\n HCI_LE_Periodic_Advertising_Subevent_Data_Request event, or sends it twice for the\n same subevent of the same periodic advertising event, then the Controller shall return\n an error which should use the error code Command Disallowed (0x0C).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Periodic_Advertising_Subevent_Data command has completed,\n an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_periodic_adv_subevent_data(
        p_params: *const sdc_hci_cmd_le_set_periodic_adv_subevent_data_t,
        p_return: *mut sdc_hci_cmd_le_set_periodic_adv_subevent_data_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Periodic Advertising Response Data.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.126\n\n The HCI_LE_Set_Periodic_Advertising_Response_Data command is used by the Host\n to set the data for a response slot in a specific subevent of the PAwR identified by the\n Sync_Handle. The data for a response slot shall be transmitted only once.\n\n The Request_Event parameter identifies the periodic advertising event in which the\n periodic advertising packet that the Host is responding to was received.\n\n The Request_Subevent parameter identifies the subevent in which the periodic\n advertising packet that the Host is responding to was received.\n\n The Response_Subevent parameter identifies the subevent that the response shall be\n sent in.\n\n The Response_Slot parameter identifies the response slot in the subevent identified by\n the Response_Subevent parameter in which this response data is to be transmitted.\n\n The Response_Data_Length specifies the length of the Response_Data that is\n significant.\n\n The Response_Data contains the advertising data to be transmitted in the response\n slot. If the Response_Data_Length is greater than the maximum that the Controller can\n transmit within the response slot, then the Response_Data shall be discarded and the\n Controller shall return the error code Packet Too Long (0x45). If the periodic advertising\n train is on the LE Coded PHY, then the S=8 coding shall be assumed.\n\n If the response slot identified by the Response_Slot parameter has passed by the time\n this command is received by the Controller, the Controller shall return the error code\n Too Late (0x46) and discard the Response_Data parameter.\n If Response_Subevent exceeds numSubevents of the periodic advertising train, or the\n Controller is not synchronized with the subevent, then the Controller should return the\n error code Command Disallowed (0x0C).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Periodic_Advertising_Response_Data command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_periodic_adv_response_data(
        p_params: *const sdc_hci_cmd_le_set_periodic_adv_response_data_t,
        p_return: *mut sdc_hci_cmd_le_set_periodic_adv_response_data_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Periodic Sync Subevent.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.127\n\n The HCI_LE_Set_Periodic_Sync_Subevent command is used to instruct the Controller\n to synchronize with a subset of the subevents within a PAwR train identified by the\n Sync_Handle parameter, listen for packets sent by the peer device and pass any\n received data up to the Host. If the Controller is synchronized with any subevents that\n are not in the subset of subevents in this command, then the Controller shall no longer\n synchronize with those subevents.\n\n The Periodic_Advertising_Properties parameter indicates which fields should be\n included in the AUX_SYNC_SUBEVENT_RSP PDUs.\n\n The Num_Subevents_To_Sync parameter identifies the number of values in the sub-\n events parameter.\n\n The Subevents arrayed parameter identifies the subevents that the Controller shall\n synchronize with.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Periodic_Sync_Subevent command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_periodic_sync_subevent(
        p_params: *const sdc_hci_cmd_le_set_periodic_sync_subevent_t,
        p_return: *mut sdc_hci_cmd_le_set_periodic_sync_subevent_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Extended Create Connection The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.66\n\n The HCI_LE_Extended_Create_Connection command is used to create an ACL\n connection, with the local device in the Central role, to a connectable advertiser. The\n command is also used to create an ACL connection between a periodic advertiser and a\n synchronized device.\n\n If a connection is created with the local device in the Peripheral role while this command\n is pending, then this command remains pending.\n\n The Advertising_Handle parameter is used to identify the periodic advertising train.\n\n The Subevent parameter is used to identify the subevent where a connection\n request shall be initiated from a periodic advertising train. The Host may use\n this subevent whether or not the Controller has requested data for it using the\n HCI_LE_Periodic_Advertising_Subevent_Data_Request event.\n\n The Advertising_Handle and Subevent parameters shall be set to 0xFF if these\n parameters are not used. If the Host sets one but not both of these to 0xFF, then the\n Controller shall return an error which should use the error code Invalid HCI Command\n Parameters (0x12).\n\n If the Advertising_Handle and Subevent parameters are set to values other than 0xFF,\n then the Initiator_Filter_Policy, Scan_Intervaland Scan_Windowparameters shall\n be ignored.\n\n The Initiator_Filter_Policy parameter is used to determine whether the Filter Accept List\n is used and whether to process decision PDUs and other advertising PDUs. If the Filter\n Accept List is not used, the Peer_Address_Type and the Peer_Address parameters\n specify the address type and address of the advertising device to connect to for\n advertisements not using decision PDUs. If Initiator_Filter_Policy is set to 0x03, then\n devices on the Filter Accept List shall still be processed using the decision instructions\n (see Section 7.8.145).\n\n The Own_Address_Type parameter indicates the type of address being used in the\n connection request packets.\n\n The Peer_Address_Type parameter indicates the type of address used in the\n connectable advertisement sent by the peer.\n\n The Peer_Address parameter indicates the Peers Public Device Address, Random\n (static) Device Address, Non-Resolvable Private Address, or Resolvable Private\n Address depending on the Peer_Address_Type parameter.\n\n The Initiating_PHYs parameter indicates the PHY(s) on which the advertising packets\n should be received on the primary advertising physical channel and the PHYs for\n which connection parameters have been specified. The Host may enable one or more\n initiating PHYs. If the Host specifies a PHY that is not supported by the Controller,\n including a bit that is reserved for future use, the latter should return the error code\n Unsupported Feature or Parameter Value (0x11). If the Host sets Advertising_Handle to\n a value other than 0xFF and does not include the PHY used for the specified periodic\n advertising train in Initiating_PHYs, the Controller shall return an error which should use\n the error code Invalid HCI Command Parameters (0x12). The array elements of the\n arrayed parameters are ordered in the same order as the set bits in the Initiating_PHYs\n parameter, starting from bit 0. The number of array elements is determined by the\n number of bits set in the Initiating_PHYs parameter. When a connectable advertisement\n is received and a connection request is sent on one PHY, scanning on any other PHYs\n is terminated.\n\n The Scan_Intervaland Scan_Windowparameters are recommendations from the\n Host on how long (Scan_Windowand how frequently (Scan_Intervalthe Controller\n should scan (see 6] Part B, Section 4.5.3); however the frequency and length\n of the scan is implementation specific. If the requested scan cannot be supported by\n the implementation, the Controller shall return the error code Invalid HCI Command\n Parameters (0x12). If bit 1 is set in Initiating_PHYs, the values for the LE 2M PHY shall\n be ignored.\n\n The Connection_Interval_Minand Connection_Interval_Maxparameters define the\n minimum and maximum allowed connection interval. The Connection_Interval_Minparameter shall not be greater than the Connection_Interval_Maxparameter.\n The Max_Latencyparameter defines the maximum allowed Peripheral latency (see\n 6] Part B, Section 4.5.1).\n\n The Supervision_Timeoutparameter defines the link supervision timeout for the\n connection. The Supervision_Timeoutin milliseconds shall be larger than (1 +\n Max_Latency Connection_Interval_Max 2, where Connection_Interval_Maxis given in milliseconds (see 6] Part B, Section 4.5.2).\n\n The Min_CE_Lengthand Max_CE_Lengthparameters provide the Controller\n with the expected minimum and maximum length of the connection events. The\n Min_CE_Lengthparameter shall be less than or equal to the Max_CE_Lengthparameter. The Controller is not required to use these values.\n\n Where the connection is made on a PHY whose bit is not set in the\n Initiating_PHYs parameter, the Controller shall use the Connection_Interval_MinConnection_Interval_MaxMax_LatencySupervision_TimeoutMin_CE_Lengthand Max_CE_Lengthparameters for an implementation-chosen PHY whose bit is set\n in the Initiating_PHYs parameter.\n\n If the Host issues this command when another HCI_LE_Extended_Create_Connection\n command is pending in the Controller, the Controller shall return the error code\n Command Disallowed (0x0C).\n\n If the local device is already connected to the same device address as the advertiser\n (including two different Resolvable Private Addresses that resolve to the same IRK),\n then the Controller shall return an error which should use the error code Connection\n Already Exists (0x0B).\n\n If the Own_Address_Type parameter is set to 0x00 and the device does not have a\n public address, the Controller should return an error code which should be Invalid HCI\n Command Parameters (0x12).\n\n If the Own_Address_Type parameter is set to 0x01 and the random address for the\n device has not been initialized using the HCI_LE_Set_Random_Address command, the\n Controller shall return the error code Invalid HCI Command Parameters (0x12).\n\n If the Own_Address_Type parameter is set to 0x02, the Initiator_Filter_Policy parameter\n is set to 0x00, the Controller's resolving list did not contain a matching entry, and the\n device does not have a public address, the Controller should return an error code which\n should be Invalid HCI Command Parameters (0x12).\n\n If the Own_Address_Type parameter is set to 0x02, the Initiator_Filter_Policy parameter\n is not set to 0x00, and the device does not have a public address, the Controller should\n return an error code which should be Invalid HCI Command Parameters (0x12).\n\n If the Own_Address_Type parameter is set to 0x03, the Initiator_Filter_Policy\n parameter is set to 0x00, the Controller's resolving list did not contain a matching\n entry, and the random address for the device has not been initialized using the\n HCI_LE_Set_Random_Address command, the Controller shall return the error code\n Invalid HCI Command Parameters (0x12).\n\n If the Own_Address_Type parameter is set to 0x03, the Initiator_Filter_Policy parameter\n is not set to 0x00, and the random address for the device has not been initialized using\n the HCI_LE_Set_Random_Address command, the Controller shall return the error code\n Invalid HCI Command Parameters (0x12).\n\n If the Initiating_PHYs parameter does not have at least one bit set for a PHY allowed\n for scanning on the primary advertising physical channel, the Controller shall return the\n error code Invalid HCI Command Parameters (0x12).\n\n If the Host issues this command and the Controller has insufficient resources to handle\n any more connections, the Controller shall return the error code Connection Rejected\n due to Limited Resources (0x0D).\n\n If the Controller does not support the Decision-Based Advertising Filtering feature and\n the Host issues this command with Initiator_Filter_Policy set to a value other than 0x00\n or 0x01, the Controller shall return an error code which should be Unsupported Feature\n or Parameter Value (0x11).\n\n Missing parameters:\n When a version of this command is issued that does not include all the parameters, the\n following values shall be used for any missing parameters:\n Parameter Value\n Advertising_Handle 0xFF\n Subevent 0xFF\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_LE_Extended_Create_Connection command,\n the Controller sends the HCI_Command_Status event to the Host. An\n HCI_LE_Enhanced_Connection_Complete event shall be generated when a connection\n is created because of this command or the connection creation procedure is\n cancelled; until the event is generated, the command is considered pending. If\n a connection creation is discarded, then the error code Connection Failed to be\n Established / Synchronization Timeout (0x3E) shall be used. If a connection is created,\n this event shall be immediately followed by an HCI_LE_Channel_Selection_Algorithm\n event.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_ext_create_conn_v2(p_params: *const sdc_hci_cmd_le_ext_create_conn_v2_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Periodic Advertising Parameters The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.61\n\n The HCI_LE_Set_Periodic_Advertising_Parameters command is used by the Host to\n set the parameters for periodic advertising.\n\n The Advertising_Handle parameter identifies the advertising set whose periodic\n advertising parameters are being configured. If the corresponding advertising set does\n not already exist, then the Controller shall return the error code Unknown Advertising\n Identifier (0x42).\n\n The Periodic_Advertising_Interval_Min parameter shall be less than or equal to the\n Periodic_Advertising_Interval_Max parameter. The Periodic_Advertising_Interval_Min\n and Periodic_Advertising_Interval_Max parameters should not be the same value to\n enable the Controller to determine the best advertising interval given other activities.\n\n If the periodic advertising interval range provided by the Host (Periodic_Advertising_-\n Interval_Min, Periodic_Advertising_Interval_Max) does not overlap with the periodic\n advertising interval range supported by the Controller, then the Controller shall return\n an error which should use the error code Unsupported Feature or Parameter Value\n (0x11).\n\n The Periodic_Advertising_Properties parameter indicates which fields should be\n included in the advertising packet.\n\n The Num_Subevents parameter identifies the number of subevents that shall be\n transmitted for each periodic advertising event. If the Num_Subevents parameter value\n is 0x00, then the Periodic Advertising does not have responses and the Controller\n shall ignore the Subevent_Interval, Response_Slot_Delay, Response_Slot_Spacing,\n and Num_Response_Slots parameters. If Num_Subevents is greater than 0, then the\n Periodic Advertising is PAwR.\n\n The Subevent_Interval parameter identifies the time between the subevents\n of PAwR. The Subevent_Interval shall be less than or equal to the\n Periodic_Advertising_Interval_Min divided by the Num_Subevents of the advertising\n set. If Num_Subevents is set to 1, then the Controller shall ignore Subevent_Interval\n and uses of Subevent_Interval in the next two paragraphs shall be replaced by\n Periodic_Advertising_Interval_Max.\n\n The Response_Slot_Delay parameter identifies the time between the start of the\n advertising packet at the start of a subevent and the start of the first response slot.\n The Response_Slot_Delay shall be less than the Subevent_Interval.\n\n The Response_Slot_Spacing parameter identifies the time between the start of two\n consecutive response slots. The Response_Slot_Spacing shall be less than or equal\n to 10  (Subevent_Interval  Response_Slot_Delay)  Num_Response_Slots. If the\n Num_Response_Slots parameter is set to 1, then the Controller shall ignore the\n Response_Slot_Spacing parameter.\n\n The Num_Response_Slots parameter identifies the number of response slots in a\n subevent.\n\n If the advertising set identified by the Advertising_Handle specified scannable,\n connectable, legacy, or anonymous advertising, the Controller shall return the error\n code Invalid HCI Command Parameters (0x12).\n\n If the Host issues this command when periodic advertising is enabled for the specified\n advertising set, the Controller shall return the error code Command Disallowed (0x0C).\n\n If the Advertising_Handle does not identify an advertising set that is already configured\n for periodic advertising and the Controller is unable to support more periodic advertising\n at present, the Controller shall return the error code Memory Capacity Exceeded (0x07).\n\n If the advertising set already contains periodic advertising data and the length of the\n data is greater than the maximum that the Controller can transmit within a periodic\n advertising interval of Periodic_Advertising_Interval_Max, the Controller shall return the\n error code Packet Too Long (0x45). If advertising on the LE Coded PHY, the S=8 coding\n shall be assumed unless the current advertising parameters require the use of S=2 for\n an advertising physical channel, in which case the S=2 coding shall be assumed for that\n advertising physical channel.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Periodic_Advertising_Parameters command has\n completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_periodic_adv_params_v2(
        p_params: *const sdc_hci_cmd_le_set_periodic_adv_params_v2_t,
        p_return: *mut sdc_hci_cmd_le_set_periodic_adv_params_v2_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE CS Read Local Supported Capabilities.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.130\n\n The HCI_LE_CS_Read_Local_Supported_Capabilities command allows a Host to read\n the CS capabilities that are supported by the local Controller. This command may\n be used along with the local supported features to provide additional details of the\n supported CS capabilities.\n\n The Num_Config_Supported parameter indicates the number of CS configurations that\n are supported by the Controller.\n\n The Max_Consecutive_Procedures_Supported parameter indicates the maximum\n number of consecutive CS procedures that are supported by the local Controller.\n\n The Num_Antennas_Supported parameter indicates the number of antenna elements\n that are available for CS tone exchanges.\n The Max_Antenna_Paths_Supported parameter indicates the maximum number of\n antenna paths that are supported by the local Controller for CS tone exchanges.\n\n The Roles_Supported parameter indicates the CS roles that are supported by the local\n Controller.\n\n The Modes_Supported parameter indicates the optional CS modes that are supported\n by the local Controller.\n\n The RTT_Capability, RTT_AA_Only_N, RTT_Sounding_N, and the RTT_Random_-\n Payload_N parameters indicate the time-of-flight accuracy as described in 6] Part\n B, Section 2.4.2.44.\n\n The NADM_Sounding_Capability and NADM_Random_Capability parameters indicate\n the support by the local Controller for reporting Normalized Attack Detector Metric\n (NADM) when a CS_SYNC with a sounding sequence or random sequence is received.\n\n The CS_SYNC_PHYs_Supported parameter indicates the optional transmit and receive\n PHYs that are supported by the local Controller for CS_SYNC exchanges as described\n in 6] Part H, Section 4.3.\n\n The Subfeatures_Supported parameter indicates which of the following optional\n subfeatures are supported by the local Controller:\n\n  A Frequency Actuation Error of zero for all allowed CS channels relative to mode-0\n transmissions when in the reflector role as described in 6] Part A, Section 3.5.\n  Channel Selection Algorithm #3c as described in 6] Part H, Section 4.1.4.2.\n  Phase-based ranging from a sounding sequence as described in 6] Part H,\n Section 3.3.1.\n\n The T_IP1_Times_Supported, T_IP2_Times_Supported, T_FCS_Times_Supported,\n T_PM_Times_Supported, and T_SW_Time_Supported parameters indicate the\n supported optional time durations used in CS steps as described in 6] Part H,\n Section 4.3.\n\n The TX_SNR_Capability parameter indicates the supported SNR levels used in RTT\n packets as described in 6] Part A, Section 3.1.3.\n\n If the Host issues this command when the Channel Sounding (Host Support) feature bit\n (see 6] Part B, Section 4.6.33.4) is not set, then the Controller shall return the error\n code Command Disallowed (0x0C).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_CS_Read_Local_Supported_Capabilities command has completed,\n an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_cs_read_local_supported_capabilities(
        p_return: *mut sdc_hci_cmd_le_cs_read_local_supported_capabilities_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE CS Read Remote Supported Capabilities.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.131\n\n The HCI_LE_CS_Read_Remote_Supported_Capabilities command allows a Host\n to query the CS capabilities that are supported by the remote Controller.\n If no Channel Sounding Capability Exchange procedure has been initiated\n on the ACL connection specified by the Connection_Handle and if no prior\n HCI_LE_CS_Write_Cached_Remote_Supported_Capabilities command has been\n issued by the Host, then the Controller shall initiate a Channel Sounding Capabilities\n Exchange procedure on the ACL. Otherwise, the Controller may use a cached copy of\n the capabilities of the remote device.\n\n If this command is issued on the Central or Peripheral before the devices have\n performed the Feature Exchange procedure, then the Controller of the Central or\n Peripheral shall complete that procedure before initiating the Channel Sounding\n Capability Exchange procedure (see 6] Part B, Section 5.1.24).\n\n If the Host issues this command when the local or remote Channel Sounding (Host\n Support) feature bit (see 6] Part B, Section 4.6.33.4) is not set, then the Controller\n shall return the error code Command Disallowed (0x0C).\n\n If the Host sends this command with a Connection_Handle that does not exist, or the\n Connection_Handle is not for an ACL, then the Controller shall return the error code\n Unknown Connection Identifier (0x02).\n\n The Host may store a copy of the remote devices capabilities and write the remote\n capabilities in the local Controller when it reconnects to the same remote device by\n using the HCI_LE_CS_Write_Cached_Remote_Supported_Capabilities command.\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_LE_CS_Read_Remote_Supported_Capabilities\n command, the Controller shall send the HCI_Command_Status event to the\n Host. When the Controller has completed the Channel Sounding Capability\n Exchange procedure with the remote Controller or has a cached copy of\n the capabilities of the remote Controller, the Controller shall generate an\n HCI_LE_CS_Read_Remote_Supported_Capabilities_Complete event.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_cs_read_remote_supported_capabilities(
        p_params: *const sdc_hci_cmd_le_cs_read_remote_supported_capabilities_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE CS Write Cached Remote Supported Capabilities.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.132\n\n The HCI_LE_CS_Write_Cached_Remote_Supported_Capabilities command allows a\n Host to write the cached copy of the CS capabilities that are supported by the remote\n Controller for the connection identified by the Connection_Handle parameter.\n\n The Num_Config_Supported parameter indicates the number of CS configurations that\n are supported by the remote Controller.\n\n The Max_Consecutive_Procedures_Supported parameter indicates the maximum\n number of consecutive CS procedures that are supported by the remote Controller.\n\n The Num_Antennas_Supported parameter indicates the number of antenna elements\n that are available for CS tone exchanges.\n The Max_Antenna_Paths_Supported parameter indicates the maximum number of\n antenna paths that are supported by the local Controller for CS tone exchanges.\n\n The Roles_Supported parameter indicates the CS roles that are supported by the\n remote Controller.\n\n The Modes_Supported parameter indicates the optional CS modes that are supported\n by the remote Controller.\n\n The RTT_Capability, RTT_AA_Only_N, RTT_Sounding_N, and the\n RTT_Random_Payload_N parameters indicate the time-of-flight accuracy as described\n in 6] Part B, Section 2.4.2.44.\n\n The NADM_Sounding_Capability and NADM_Random_Capability parameters indicate\n the support by the remote Controller for reporting Normalized Attack Detector Metric\n (NADM) when a CS_SYNC with a sounding sequence or random sequence is received.\n\n The CS_SYNC_PHYs_Supported parameter indicates the optional transmit and receive\n PHYs that are supported by the remote Controller for CS_SYNC exchanges as\n described in 6] Part H, Section 4.3.\n\n The Subfeatures_Supported parameter indicates which of the following optional\n subfeatures are supported by the remote Controller:\n\n  A Frequency Actuation Error of zero for all allowed CS channels relative to mode-0\n transmissions when in the reflector role as described in 6] Part A, Section 3.5.\n  Channel Selection Algorithm #3c as described in 6] Part H, Section 4.1.4.2.\n  Phase-based ranging from a sounding sequence as described in 6] Part H,\n Section 3.3.1.\n\n The T_IP1_Times_Supported, T_IP2_Times_Supported, T_FCS_Times_Supported,\n T_PM_Times_Supported, and T_SW_Time_Supported parameters indicate the\n supported optional time durations used in CS steps as described in 6] Part H,\n Section 4.3.\n\n The TX_SNR_Capability parameter indicates the supported SNR levels used in RTT\n packets as described in 6] Part A, Section 3.1.3.\n\n If the Host issues this command after an LL_CS_CAPABILITIES_REQ or\n LL_CS_CAPABILITIES_RSP PDU has been received from the remote Controller, then\n the Controller shall return the error code Command Disallowed (0x0C).\n\n If the Host issues this command after a CS configuration has been created in the local\n Controller, then the Controller shall return the error code Command Disallowed (0x0C).\n If the Host issues this command when the Channel Sounding (Host Support) feature bit\n (see 6] Part B, Section 4.6.33.4) is not set, then the Controller shall return the error\n code Command Disallowed (0x0C).\n\n If the Host sends this command with a Connection_Handle that does not exist, or the\n Connection_Handle is not for an ACL the Controller shall return the error code Unknown\n Connection Identifier (0x02).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_CS_Write_Cached_Remote_Supported_Capabilities command has\n completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities(
        p_params: *const sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_t,
        p_return: *mut sdc_hci_cmd_le_cs_write_cached_remote_supported_capabilities_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE CS Security Enable.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.133\n\n The HCI_LE_CS_Security_Enable command is used by a Host to start or restart\n the Channel Sounding Security Start procedure in the local Controller for the ACL\n connection identified by the Connection_Handle parameter.\n\n If the Host issues this command on a Connection_Handle where the Controller is the\n Peripheral, then the Controller shall return the error code Command Disallowed (0x0C).\n\n If the connection identified by the Connection_Handle parameter is not encrypted, then\n the Controller shall return the error code Insufficient Security (0x2F).\n\n If the Host sends this command with a Connection_Handle that does not exist, or the\n Connection_Handle is not for an ACL, then the Controller shall return the error code\n Unknown Connection Identifier (0x02).\n\n If the Host issues this command when the Channel Sounding (Host Support) feature bit\n (see 6] Part B, Section 4.6.33.4) is not set, then the Controller shall return the error\n code Command Disallowed (0x0C).\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_LE_CS_Security_Enable command, the\n Controller shall send the HCI_Command_Status event to the Host. When the Controller\n has completed the Channel Sounding Security Start procedure with the remote\n Controller, the Controller shall generate an LE_CS_Security_Enable_Complete event.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_cs_security_enable(p_params: *const sdc_hci_cmd_le_cs_security_enable_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE CS Set Default Settings.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.134\n\n The HCI_LE_CS_Set_Default_Settings command is used by a Host to set default CS\n settings in the local Controller for the connection identified by the Connection_Handle\n parameter. The default settings specify that all roles are disabled in a Controller and\n CS_SYNC_Antenna_Selection is set to 0x01.\n\n The Role_Enable parameter is used to enable or disable the CS roles in the local\n Controller. If the Host issues this command to disable a Role for which a valid CS\n configuration is present, then the Controller shall return the error code Invalid HCI\n Command Parameters (0x12).\n\n The CS_SYNC_Antenna_Selection parameter indicates the antenna identifier to be\n used for transmitting and receiving CS_SYNC packets.\n\n If the Role_Enable parameter is used to enable an unsupported role or the\n CS_SYNC_Antenna_Selection parameter indicates an unsupported antenna identifier,\n then the Controller shall return the error code Unsupported Feature or Parameter Value\n (0x11).\n\n The Max_TX_Power parameter is used to set the maximum output power, EIRP, to be\n used for all CS transmissions. If the value provided in this parameter is higher than\n the maximum output power supported by the Controller, then the Controller shall use\n the maximum output power that it supports. If the Controller is unable to use the exact\n output power requested by the Host, then the Controller shall use an output power that\n is lower but closest to the requested value.\n\n If the Host sends this command with a Connection_Handle that does not exist, or the\n Connection_Handle is not for an ACL, then the Controller shall return the error code\n Unknown Connection Identifier (0x02).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_CS_Set_Default_Settings command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_cs_set_default_settings(
        p_params: *const sdc_hci_cmd_le_cs_set_default_settings_t,
        p_return: *mut sdc_hci_cmd_le_cs_set_default_settings_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE CS Read Remote FAE Table.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.135\n\n The HCI_LE_CS_Read_Remote_FAE_Table command is used by a Host to read the\n per-channel mode-0 Frequency Actuation Error table of the remote Controller.\n\n If the remote Controller supports a Frequency Actuation Error of zero relative to\n its mode-0 transmissions in the reflector role (No_FAE bit set as described in\n 6] Part B, Section 2.4.2.44), then the Controller shall generate the LE_CS_-\n Read_Remote_FAE_Table_Complete event with Status set to Unsupported Feature or\n Parameter Value (0x11).\n\n The Host may store a copy of the remote devices Frequency Actuation\n Error table and write the remote Frequency Actuation Error table in the\n local Controller when it reconnects to the same remote device by using the\n HCI_LE_CS_Write_Cached_Remote_FAE_Table command.\n\n If the Host sends this command with a Connection_Handle that does not exist, or the\n Connection_Handle is not for an ACL, then the Controller shall return the error code\n Unknown Connection Identifier (0x02).\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_LE_CS_Read_Remote_FAE_Table command,\n the Controller shall send the HCI_Command_Status event to the Host. When\n the Controller has completed the Channel Sounding Mode-0 FAE Table\n Request procedure with the remote Controller, the Controller shall generate an\n LE_CS_Read_Remote_FAE_Table_Complete event.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_cs_read_remote_fae_table(p_params: *const sdc_hci_cmd_le_cs_read_remote_fae_table_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE CS Write Cached Remote FAE Table.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.136\n\n The HCI_LE_CS_Write_Cached_Remote_FAE_Table command is used by a Host to\n write a cached copy of the per-channel mode-0 Frequency Actuation Error table of the\n remote device in the local Controller.\n\n If the remote Controller supports a Frequency Actuation Error of zero relative to its\n mode-0 transmissions in the reflector role (No_FAE bit set as described in 6]\n Part B, Section 2.4.2.44), then the Controller shall return the error code Unsupported\n Feature or Parameter Value (0x11).\n\n If the Host issues this command after an LL_CS_FAE_RSP PDU has been received\n from the remote Controller, then the Controller shall return the error code Command\n Disallowed (0x0C).\n\n If the Host issues this command after a CS configuration has been created in the local\n Controller, then the Controller shall return the error code Command Disallowed (0x0C).\n\n If the Host sends this command with a Connection_Handle that does not exist, or the\n Connection_Handle is not for an ACL, then the Controller shall return the error code\n Unknown Connection Identifier (0x02).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_CS_Write_Cached_Remote_FAE_Table command has completed,\n an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_cs_write_cached_remote_fae_table(
        p_params: *const sdc_hci_cmd_le_cs_write_cached_remote_fae_table_t,
        p_return: *mut sdc_hci_cmd_le_cs_write_cached_remote_fae_table_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE CS Create Config.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.137\n\n The HCI_LE_CS_Create_Config command is used by a Host to create a new CS\n configuration or update an existing CS configuration with the identifier Config_ID on\n the connection identified by the Connection_Handle in the local and/or the remote\n Controller.\n\n When the Create_Context parameter is set to 0x00, the CS configuration is written\n only in the local Controller. Otherwise when set to 0x01, the CS configuration is written\n in both the local and remote Controllers using the Channel Sounding Configuration\n procedure.\n\n The Main_Mode_Type and the Sub_Mode_Type parameters indicate the CS modes to\n be used during the CS procedure for the specified CS configuration.\n\n The Min_Main_Mode_Steps and Max_Main_Mode_Steps parameters indicate the\n range of main mode CS steps to be executed before a submode CS step is executed\n during the CS procedure. When the Sub_Mode_Type parameter is set to 0xFF,\n the Min_Main_Mode_Steps and Max_Main_Mode_Steps parameters are reserved for\n future use.\n The Main_Mode_Repetition parameter indicates the number of main mode CS steps\n repeated from the last CS subevent at the beginning of the current CS subevent.\n\n The Mode_0_Steps parameter indicates the number of mode-0 CS steps to be included\n at the beginning of each CS subevent.\n\n The Role parameter indicates the CS role for the local Controller for the specified CS\n configuration. The RTT_Type parameter indicates the RTT variant to be used during the\n CS procedure, and the CS_SYNC_PHY parameter indicates the PHY to be used for\n CS_SYNC exchanges during the CS procedure for the specified CS configuration.\n\n The Channel_Map parameter indicates the channels to be used or unused during the\n CS procedure, and the Channel_Map_Repetition parameter indicates the number of\n times the channels specified by Channel_Map are to be repeated for non-mode-0 steps\n during the CS procedure (see 6] Part H, Section 4.1.4).\n\n The Channel_Selection_Type parameter indicates the Channel Selection Algorithm\n to be used during the CS procedure for non-mode-0 steps. When the\n Channel_Selection_Type is set to 0x01, the Ch3c_Shape and the Ch3c_Jump\n parameters shall each be set to the selected shape and channels to be skipped\n as described in 6] Part H, Section 4.1.4.2. Otherwise, the Ch3c_Shape and the\n Ch3c_Jump parameters shall be ignored.\n\n If the Host issues this command with parameters that are not supported by the local or\n remote Controllers, then the Controller shall return the error code Unsupported Feature\n or Parameter Value (0x11).\n\n If the Host issues this command with a Role not enabled by a prior\n HCI_LE_CS_Set_Default_Settings command or with a set of parameters that are\n considered an invalid configuration according to 6] Part H, then the Controller shall\n return the error code Invalid HCI Command Parameters (0x12).\n\n If the Host issues this command before a Channel Sounding\n Capability Exchange procedure has been completed or an\n HCI_LE_CS_Write_Cached_Remote_Supported_Capabilities command has been\n issued for the connection identified by the Connection_Handle parameter, then the\n Controller may autonomously initiate the Channel Sounding Capability Exchange\n procedure. Otherwise, the Controller shall return the error code Command Disallowed\n (0x0C).\n\n If the Host issues this command to update a CS configuration identified by the\n Config_ID parameter that is already enabled using the HCI_LE_CS_Procedure_Enable\n command, then the Controller shall return the error code Command Disallowed (0x0C).\n If the Host sends this command with a Connection_Handle that does not exist, or the\n Connection_Handle is not for an ACL, then the Controller shall return the error code\n Unknown Connection Identifier (0x02).\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_LE_CS_Create_Config command, the Controller\n shall send the HCI_Command_Status event to the Host. When the Controller has\n completed the Channel Sounding Configuration procedure with the remote Controller\n or when the Create_Context parameter is set to 0x00, the Controller shall generate an\n LE_CS_Config_Complete event.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_cs_create_config(p_params: *const sdc_hci_cmd_le_cs_create_config_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE CS Remove Config.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.138\n\n The HCI_LE_CS_Remove_Config command is used to remove a CS configuration\n identified by Config_ID from the local Controller for the connection identified by\n the Connection_Handle parameter. When the Host issues this command, the local\n Controller shall initiate a Channel Sounding Configuration procedure to remove the CS\n configuration from both the local and remote device. The Controller shall delete any CS\n procedure related parameters set using the HCI_LE_CS_Set_Procedure_Parameters\n command for the CS configuration identified by Config_ID.\n\n If the CS configuration corresponding to Config_ID does not exist, then the Controller\n shall return the error code Invalid HCI Command Parameters (0x12).\n\n If the Host issues this command when one or more CS procedures have been enabled\n using the HCI_LE_CS_Procedure_Enable command, then the Controller shall return the\n error code Command Disallowed (0x0C).\n\n If the Host sends this command with a Connection_Handle that does not exist, or the\n Connection_Handle is not for an ACL, then the Controller shall return the error code\n Unknown Connection Identifier (0x02).\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_LE_CS_Remove_Config command, the\n Controller shall send the HCI_Command_Status event to the Host. When the\n Controller has completed the Channel Sounding Configuration procedure to disable the\n configuration, the Controller shall generate an LE_CS_Config_Complete event.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_cs_remove_config(p_params: *const sdc_hci_cmd_le_cs_remove_config_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE CS Set Channel Classification.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.139\n\n The HCI_LE_CS_Set_Channel_Classification command is used by a Host to update the\n channel classification based on its local information. This channel classification persists\n until overwritten with a subsequent HCI_LE_CS_Set_CS_Channel_Classification\n command or until the Controller is reset. The Controller may combine the channel\n classification information provided by the Host along with local channel classification\n information to send an updated CS channel map to the remote Controller.\n\n If this command is used, then the Host should send updates within 10 seconds of\n knowing that the CS channel classification has changed.\n\n If the host issues this command less than 1 second after the previous time it issued this\n command, then the Controller shall return the error code Command Disallowed (0x0C).\n\n If the Channel_Classification parameter enables channels that are reserved for future\n use or enables fewer than 15 channels, then the Controller shall return the error code\n Invalid HCI Command Parameters (0x12).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_CS_Set_Channel_Classification command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_cs_set_channel_classification(
        p_params: *const sdc_hci_cmd_le_cs_set_channel_classification_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE CS Set Procedure Parameters.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.140\n\n The HCI_LE_CS_Set_Procedure_Parameters command is used by a Host to set the\n parameters for the scheduling of one or more CS procedures by the local Controller,\n with the remote device for the CS configuration identified by Config_ID and the\n connection identified by the Connection_Handle parameter.\n\n The Max_Procedure_Len parameter indicates the maximum duration of each CS\n procedure. The Min_Procedure_Interval and Max_Procedure_Interval parameters\n indicate the minimum and maximum interval period between consecutive\n CS procedures. The Max_Procedure_Count parameter indicates the maximum\n number of consecutive CS procedures to be scheduled as part of this\n measurement. If Max_Procedure_Count is set to 1, then Min_Procedure_Interval and\n Max_Procedure_Interval shall be ignored.\n\n The Min_Subevent_Len and Max_Subevent_Len parameters indicate the minimum and\n maximum duration of each CS subevent during the CS procedure.\n\n The values for Min_Procedure_Interval, Max_Procedure_Interval, Min_Subevent_Len,\n and Max_Subevent_Len are recommendations to the Controller which it may ignore.\n\n The Tone_Antenna_Config_Selection parameter indicates the Antenna Configuration\n Index to be used in the CS procedure.\n The power delta value Tx_Power_Delta indicates the recommended difference between\n the remote devices power level for the CS tones and RTT packets and the power level\n for the PHY indicated by the PHY parameter.\n\n The Preferred_Peer_Antenna parameter indicates the preferred peer-ordered antenna\n elements to be used by the remote device for the antenna configuration denoted by\n the Tone_Antenna_Config_Selection parameter. The number of bits set in this field\n shall be greater than or equal to the number of antenna elements denoted by the\n Tone_Antenna_Config_Selection parameter.\n\n The SNR_Control_Initiator parameter indicates the SNR control adjustment for the\n CS_SYNC transmissions of the initiator.\n\n The SNR_Control_Reflector parameter indicates the SNR control adjustment for the\n CS_SYNC transmissions of the reflector.\n\n If the Host issues this command with parameters that exceed the CS capabilities or\n any coexistence constraints, then the Controller shall return the error code Connection\n Rejected Due to Limited Resources (0x0D).\n\n If the CS configuration corresponding to Config_ID does not exist or is removed using\n the HCI_LE_CS_Remove_Config command, then the Controller shall return the error\n code Invalid HCI Command Parameters (0x12).\n\n If the Host issues this command when a CS procedure measurement is already enabled\n for the specified Config_ID in the Controller using the HCI_LE_CS_Procedure_Enable\n command, then the Controller shall return the error code Command Disallowed (0x0C).\n\n The parameters specified by this command for the CS configuration identified\n by the Config_ID parameter become invalid after the Host issues the\n HCI_LE_CS_Remove_Config command for the given Config_ID.\n\n If the number of channels available for Channel Sounding before the start of a new CS\n procedure measurement is less than 15, then the Controller shall return the error code\n Insufficient Channels (0x48).\n\n If the Host sends this command with a Connection_Handle that does not exist, or the\n Connection_Handle is not for an ACL, then the Controller shall return the error code\n Unknown Connection Identifier (0x02).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_CS_Set_Procedure_Parameters command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_cs_set_procedure_params(
        p_params: *const sdc_hci_cmd_le_cs_set_procedure_params_t,
        p_return: *mut sdc_hci_cmd_le_cs_set_procedure_params_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "LE CS Procedure Enable.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.141\n\n The HCI_LE_CS_Procedure_Enable command is used by a Host to enable or disable\n the scheduling of CS procedures by the local Controller, with the remote device for the\n connection identified by the Connection_Handle parameter.\n\n If the Host issues this command to enable a CS configuration identified by the\n Config_ID parameter before a corresponding HCI_LE_CS_Set_Procedure_Parameters\n command has been issued for the same Config_ID, then the Controller shall return the\n error code Command Disallowed (0x0C).\n\n If the CS configuration corresponding to Config_ID does not exist (or has been removed\n using the HCI_LE_CS_Remove_Config command), then the Controller shall return the\n error code Invalid HCI Command Parameters (0x12).\n\n If the CS procedure parameters associated with the given Config_ID exceed any\n scheduling or coexistence constraints at the time this command is issued, then the\n Controller shall return the error code Connection Rejected Due to Limited Resources\n (0x0D).\n\n If the Host issues this command to enable a CS configuration identified by the\n Config_ID parameter that is already enabled using the HCI_LE_CS_Procedure_Enable\n command, then the Controller shall return the error code Command Disallowed (0x0C).\n\n If the number of channels available for Channel Sounding before the start of a new CS\n procedure measurement is less than 15, then the Controller shall return the error code\n Insufficient Channels (0x48).\n\n If the Host sends this command with a Connection_Handle that does not exist, or the\n Connection_Handle is not for an ACL, then the Controller shall return the error code\n Unknown Connection Identifier (0x02).\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_LE_CS_Procedure_Enable command, the\n Controller shall send the HCI_Command_Status event to the Host. When\n the locally initiated Channel Sounding Start procedure has completed or\n when the Controller has received the LL_CS_IND PDU, it shall generate\n an LE_CS_Procedure_Enable_Complete event. When the Host has issued a\n command to disable an active CS procedure, the Controller shall generate an\n LE_CS_Procedure_Enable_Complete event after any pending CS subevent results\n have been sent to the Host and the LL_CS_TERMINATE_RSP PDU has been\n successfully sent or received.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_cs_procedure_enable(p_params: *const sdc_hci_cmd_le_cs_procedure_enable_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE CS Test.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.142\n\n This command is used to start a CS test where the Implementation Under Test (IUT)\n is placed in the role of either the initiator or reflector. The first mode-0 channel in the\n list is used as the starting channel for the test. At the beginning of any test, the IUT\n in the reflector role shall listen on the first mode-0 channel until it receives the first\n transmission from the initiator. Similarly, with the IUT in the initiator role, the tester\n will start by listening on the first mode-0 channel and the IUT shall transmit on that\n channel for the first half of the first CS step. Thereafter, the parameters of this command\n describe the required transmit and receive behavior for the CS test.\n\n This command is used to schedule a single CS procedure that consists of one or more\n CS subevents. After the channels contained in the Channel map or the Channel array in\n case of an override have been used the number of times indicated by Channel_Map_-\n Repetition to schedule CS steps, or the maximum number of allowed steps in a CS\n procedure has been reached, or the maximum number of subevents indicated by\n the Max_Num_Subevents parameter has been reached, or the maximum number of\n allowed subevents in a CS procedure has been reached, the CS procedure will end.\n\n The Main_Mode_Type and the Sub_Mode_Type parameters indicate the CS modes to\n be used during the CS procedure for the specified CS configuration.\n\n The Main_Mode_Repetition parameter indicates the number of main mode CS steps\n repeated from the last CS subevent at the beginning of the current CS subevent.\n\n The Mode_0_Steps parameter indicates the number of mode-0 CS steps to be included\n at the beginning of each CS subevent.\n\n The Role parameter indicates the CS role for the local Controller.\n\n The RTT_Type parameter indicates the RTT type and payload length to be used during\n the CS procedure.\n\n The CS_SYNC_PHY parameter indicates the PHY to be used for CS_SYNC exchanges\n during the CS procedure.\n\n The CS_SYNC_Antenna_Selection parameter indicates the antenna identifier to be\n used for transmitting and receiving CS_SYNC packets.\n\n The Subevent_Len parameter indicates the maximum length of a CS subevent.\n\n The Subevent_Interval parameter indicates the gap between the start of consecutive\n CS subevents. When Subevent_Interval is set to zero, the Subevent_Len parameter is\n ignored, and only one CS subevent is executed in the CS test.\n\n The Max_Num_Subevents parameter indicates the maximum number of subevents\n that are in the procedure. If Max_Num_Subevents is set to 0x00, then the\n Max_Num_Subevents parameter is ignored.\n\n The Transmit_Power_Level parameter indicates the transmit power level used for the\n CS procedure.\n The T_IP1_Time, T_IP2_Time, T_FCS_Time, T_PM_Time, and T_SW_Time\n parameters indicate the time durations used in CS steps as described in 6] Part\n H, Section 4.3.\n\n The Tone_Antenna_Config_Selection parameter indicates the Antenna Configuration\n Index used during antenna switching during the tone phases of CS steps as described\n in 6] Part A, Section 5.3.\n\n The SNR_Control_Initiator parameter indicates the SNR control adjustment for the\n CS_SYNC transmissions of the initiator.\n\n The SNR_Control_Reflector parameter indicates the SNR control adjustment for of the\n CS_SYNC transmissions of the reflector.\n\n The DRBG_Nonce parameter specifies octets 14 and 15 of the initial value of the DRBG\n nonce, VDRBG, used in calls to the random bit generation function described in 6]\n Part E, Section 3.1.6. The remaining octets of the initial nonce value VDRBG are set to\n 0x00. All octets of the initial temporal key KDRBG are set to 0x00. The most significant bit\n of this parameter is stored in the most significant bit of the octet 14 of the DRBG nonce.\n The least significant bit of this parameter is stored in the least significant bit of octet 15\n of the DRBG nonce.\n\n The Channel_Map_Repetition field shall indicate the number of times the\n Channel_Map is cycled through for non-mode-0 steps within a CS procedure. The\n Channel_Map_Repetition field shall be greater than or equal to 1. The Channel_Map\n content is selected based on the setting of the Override_Config bit 0 as described\n below.\n\n The Override_Config parameter indicates which CS parameters are not derived from\n the DRBG but determined from the Override_Parameters_Data parameter in this\n command.\n\n If the Override_Config bit 2 corresponding to CS submode insertion is not set, then the\n number of main mode CS steps to be executed before a submode CS step during the\n CS procedure is determined using DRBG with following default values:\n\n  Min_Main_Mode_Steps: 6\n  Max_Main_Mode_Steps: 10\n\n If the Override_Config bit 10 corresponding to the Stable Phase test is set, then\n the procedure is replaced with the Stable Phase test as described in 6] Part F,\n Section 2.4.\n The Override_Parameters_Data is a variable sized object with a length indicated by\n Override_Parameters_Length parameter whose contents are determined by the bits set\n in the Override_Config parameter.\n\n An ongoing CS test can be stopped using the HCI_LE_CS_Test_End command (see\n Section 7.8.143).\n\n The CS test is considered complete when all the results of the CS procedure initiated by\n the CS test have been reported to the Host.\n\n If the Host issues this command when a CS test is already enabled using the\n HCI_LE_CS_Test command and has not completed, then the Controller shall return\n the error code Command Disallowed (0x0C).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_CS_Test command has completed, an HCI_Command_Complete\n event shall be generated. The Controller shall either generate the LE_CS_Subevent_-\n Result event once or generate the LE_CS_Subevent_Result_Continue event multiple\n times to send results from the completed CS steps to the Host.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_cs_test(p_params: *const sdc_hci_cmd_le_cs_test_t) -> u8;
}
unsafe extern "C" {
    #[doc = "LE CS Test End.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.143\n\n The HCI_LE_CS_Test_End command is used to stop any CS test that is in progress.\n\n If the Host issues this command when there is no prior CS test initiated using the\n HCI_LE_CS_Test command or when a prior CS test has already been completed, then\n the Controller shall return the error code Command Disallowed (0x0C).\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_LE_CS_Test_End command, the Controller\n shall send the HCI_Command_Status event to the Host. When the Controller has\n successfully sent all the pending CS subevent results to the Host, the Controller shall\n generate an LE_CS_Test_End_Complete event.\n\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_cs_test_end() -> u8;
}
unsafe extern "C" {
    #[doc = "LE Set Host Feature The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.8.115\n\n The HCI_LE_Set_Host_Feature command is used by the Host to set or clear a bit\n controlled by the Host in the Link Layer FeatureSet stored in the Controller (see 6]\n Part B, Section 4.6).\n\n The Bit_Number parameter specifies the bit position in the FeatureSet.\n\n The Bit_Value parameter specifies whether the feature is enabled or disabled.\n\n If Bit_Number specifies a feature bit that is not controlled by the Host, the Controller\n shall return the error code Unsupported Feature or Parameter Value (0x11).\n\n If Bit_Value is set to 0x01 and Bit_Number specifies a feature bit that requires support of\n a feature that the Controller does not support, the Controller shall return the error code\n Unsupported Feature or Parameter Value (0x11).\n\n If the Host issues this command while the Controller has a connection to another\n device, the Controller shall return the error code Command Disallowed (0x0C).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Host_Feature command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_host_feature_v2(p_params: *const sdc_hci_cmd_le_set_host_feature_v2_t) -> u8;
}
#[doc = "See sdc_hci_cmd_lc_disconnect()."]
pub const SDC_HCI_OPCODE_CMD_LC_DISCONNECT: sdc_hci_opcode_lc = 1030;
#[doc = "See sdc_hci_cmd_lc_read_remote_version_information()."]
pub const SDC_HCI_OPCODE_CMD_LC_READ_REMOTE_VERSION_INFORMATION: sdc_hci_opcode_lc = 1053;
#[doc = "HCI LC OpCode Field values."]
pub type sdc_hci_opcode_lc = ::core::ffi::c_uint;
#[doc = "Disconnect command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_lc_disconnect_t {
    pub conn_handle: u16,
    pub reason: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_lc_disconnect_t"][::core::mem::size_of::<sdc_hci_cmd_lc_disconnect_t>() - 3usize];
    ["Alignment of sdc_hci_cmd_lc_disconnect_t"][::core::mem::align_of::<sdc_hci_cmd_lc_disconnect_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_lc_disconnect_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_lc_disconnect_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_lc_disconnect_t::reason"]
        [::core::mem::offset_of!(sdc_hci_cmd_lc_disconnect_t, reason) - 2usize];
};
#[doc = "Read Remote Version Information command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_lc_read_remote_version_information_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_lc_read_remote_version_information_t"]
        [::core::mem::size_of::<sdc_hci_cmd_lc_read_remote_version_information_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_lc_read_remote_version_information_t"]
        [::core::mem::align_of::<sdc_hci_cmd_lc_read_remote_version_information_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_lc_read_remote_version_information_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_lc_read_remote_version_information_t, conn_handle) - 0usize];
};
unsafe extern "C" {
    #[doc = "HCI_VS_API API\n # /\n/* Disconnect.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.1.6\n\n The HCI_Disconnect command is used to terminate an existing connection. The\n Connection_Handle parameter indicates which connection is to be disconnected. The\n Reason parameter indicates the reason for ending the connection and is copied into\n the error code field of the LMP_DETACH PDU on a BR/EDR connection or the\n error code field of the LL_TERMINATE_IND or LL_CIS_TERMINATE_IND PDU on\n an LE connection. All SCO, eSCO, and CIS connections on a physical link should\n be disconnected before the ACL connection on the same physical connection is\n disconnected. If it does not, they will be implicitly disconnected as part of the ACL\n disconnection.\n\n If, on the Central, the Host issues this command before issuing the\n HCI_LE_Create_CIS command for the same CIS (including if a previous CIS with the\n same CIS_ID in the same CIG has been terminated or considered lost), then the\n Controller shall return the error code Command Disallowed (0x0C). If the Host issues\n this command when there is a pending HCI_LE_Create_CIS command for the same\n CIS but before the CIS is created, then this command shall be successful and the CIS\n shall not be created.\n\n Note: The CIS is created when the Central sends an LL_CIS_IND PDU to the\n Peripheral for that CIS (see 6] Part B, Section 5.1.15).\n\n Note: If the Controller follows the requirements of version v5.4 of this specification or\n lower, it may return an error if this command is issued before the CIS is created.\n\n If, on the Peripheral, the Host issues this command before the Controller has generated\n the HCI_LE_CIS_Established event for that CIS, then the Controller shall return the\n error code Command Disallowed (0x0C).\n\n Note: As specified in Section 7.7.5, on the Central, the handle for a CIS remains valid\n even after disconnection and, therefore, the Host can recreate a disconnected CIS at a\n later point in time using the same connection handle.\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_Disconnect command, it shall send the\n HCI_Command_Status event to the Host. The HCI_Disconnection_Complete event will\n occur at each Host when the termination of the connection has completed, and on\n the local Host also indicates that this command has been completed. The Reason\n parameter in the event on the local Host shall be set to the value Connection\n Terminated by Local Host (0x16), while that on the remote Host shall be set to the\n value of Reason. However, if the termination procedure completes because a timer\n expires and, therefore, the local Controller cannot determine whether or not Reason\n was received by the remote Controller, the Reason parameter on the local Host should\n instead be set to the value LMP Response Timeout / LL Response Timeout (0x22).\n\n If this command is issued for a CIS on the Central and the CIS is successfully\n terminated before being created, or after being created but before being established,\n then an HCI_LE_CIS_Established event shall also be sent for this CIS with the Status\n Operation Cancelled by Host (0x44).\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_lc_disconnect(p_params: *const sdc_hci_cmd_lc_disconnect_t) -> u8;
}
unsafe extern "C" {
    #[doc = "Read Remote Version Information.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.1.23\n\n This command will obtain the values for the version information for the remote device\n identified by the Connection_Handle parameter. The Connection_Handle shall be a\n Connection_Handle for an ACL-U or LE-U logical link.\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_Read_Remote_Version_Information command,\n the Controller shall send the HCI_Command_Status event to the Host.\n When the Link Manager or Link Layer has completed the sequence to\n determine the remote version information, the local Controller shall send\n an HCI_Read_Remote_Version_Information_Complete event to the Host. The\n HCI_Read_Remote_Version_Information_Complete event contains the status of this\n command, and parameters describing the version and subversion of the LMP or Link\n Layer used by the remote device.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_lc_read_remote_version_information(
        p_params: *const sdc_hci_cmd_lc_read_remote_version_information_t,
    ) -> u8;
}
#[doc = "See sdc_hci_cmd_sp_read_rssi()."]
pub const SDC_HCI_OPCODE_CMD_SP_READ_RSSI: sdc_hci_opcode_sp = 5125;
#[doc = "HCI SP OpCode Field values."]
pub type sdc_hci_opcode_sp = ::core::ffi::c_uint;
#[doc = "Read RSSI command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_sp_read_rssi_t {
    pub handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_sp_read_rssi_t"][::core::mem::size_of::<sdc_hci_cmd_sp_read_rssi_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_sp_read_rssi_t"][::core::mem::align_of::<sdc_hci_cmd_sp_read_rssi_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_sp_read_rssi_t::handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_sp_read_rssi_t, handle) - 0usize];
};
#[doc = "Read RSSI return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_sp_read_rssi_return_t {
    pub handle: u16,
    pub rssi: i8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_sp_read_rssi_return_t"][::core::mem::size_of::<sdc_hci_cmd_sp_read_rssi_return_t>() - 3usize];
    ["Alignment of sdc_hci_cmd_sp_read_rssi_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_sp_read_rssi_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_sp_read_rssi_return_t::handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_sp_read_rssi_return_t, handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_sp_read_rssi_return_t::rssi"]
        [::core::mem::offset_of!(sdc_hci_cmd_sp_read_rssi_return_t, rssi) - 2usize];
};
unsafe extern "C" {
    #[doc = "HCI_VS_API API\n # /\n/* Read RSSI.\n\n The description below is extracted from Core_v6.0,\n Vol 4, Part E, Section 7.5.4\n\n This command reads the Received Signal Strength Indication (RSSI) value from a\n Controller.\n\n For a BR/EDR Controller, the RSSI parameter returns the difference between the\n measured Received Signal Strength Indication (RSSI) and the limits of a range selected\n by the Controller. The lower limit shall correspond to a received power not less than -56\n dBm and not greater than 6 dB above the actual sensitivity of the receiver. The upper\n limit shall be 206 dB above the lower limit. A positive RSSI value shall indicate how\n many dB the RSSI is above the upper limit, a negative value shall indicate how many\n dB the RSSI is below the lower limit, and zero shall indicate that the RSSI is inside the\n range.\n\n The returned RSSI value is not required to have any specific accuracy provided that\n it correctly indicates whether the received signal strength was above the upper limit,\n below the lower limit, or between the limits.\n\n For an LE transport, the RSSI parameter returns the absolute received signal strength\n value in dBm to 6 dB accuracy. If the RSSI cannot be read, the RSSI parameter shall\n be set to 127.\n\n Event(s) generated (unless masked away):\n When the HCI_Read_RSSI command has completed, an HCI_Command_Complete\n event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_sp_read_rssi(
        p_params: *const sdc_hci_cmd_sp_read_rssi_t,
        p_return: *mut sdc_hci_cmd_sp_read_rssi_return_t,
    ) -> u8;
}
#[doc = "See sdc_hci_cmd_vs_zephyr_read_version_info()."]
pub const SDC_HCI_OPCODE_CMD_VS_ZEPHYR_READ_VERSION_INFO: sdc_hci_opcode_vs = 64513;
#[doc = "See sdc_hci_cmd_vs_zephyr_read_supported_commands()."]
pub const SDC_HCI_OPCODE_CMD_VS_ZEPHYR_READ_SUPPORTED_COMMANDS: sdc_hci_opcode_vs = 64514;
#[doc = "See sdc_hci_cmd_vs_zephyr_write_bd_addr()."]
pub const SDC_HCI_OPCODE_CMD_VS_ZEPHYR_WRITE_BD_ADDR: sdc_hci_opcode_vs = 64518;
#[doc = "See sdc_hci_cmd_vs_zephyr_read_static_addresses()."]
pub const SDC_HCI_OPCODE_CMD_VS_ZEPHYR_READ_STATIC_ADDRESSES: sdc_hci_opcode_vs = 64521;
#[doc = "See sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots()."]
pub const SDC_HCI_OPCODE_CMD_VS_ZEPHYR_READ_KEY_HIERARCHY_ROOTS: sdc_hci_opcode_vs = 64522;
#[doc = "See sdc_hci_cmd_vs_zephyr_read_chip_temp()."]
pub const SDC_HCI_OPCODE_CMD_VS_ZEPHYR_READ_CHIP_TEMP: sdc_hci_opcode_vs = 64523;
#[doc = "See sdc_hci_cmd_vs_zephyr_write_tx_power()."]
pub const SDC_HCI_OPCODE_CMD_VS_ZEPHYR_WRITE_TX_POWER: sdc_hci_opcode_vs = 64526;
#[doc = "See sdc_hci_cmd_vs_zephyr_read_tx_power()."]
pub const SDC_HCI_OPCODE_CMD_VS_ZEPHYR_READ_TX_POWER: sdc_hci_opcode_vs = 64527;
#[doc = "See sdc_hci_cmd_vs_llpm_mode_set()."]
pub const SDC_HCI_OPCODE_CMD_VS_LLPM_MODE_SET: sdc_hci_opcode_vs = 64769;
#[doc = "See sdc_hci_cmd_vs_conn_update()."]
pub const SDC_HCI_OPCODE_CMD_VS_CONN_UPDATE: sdc_hci_opcode_vs = 64770;
#[doc = "See sdc_hci_cmd_vs_conn_event_extend()."]
pub const SDC_HCI_OPCODE_CMD_VS_CONN_EVENT_EXTEND: sdc_hci_opcode_vs = 64771;
#[doc = "See sdc_hci_cmd_vs_qos_conn_event_report_enable()."]
pub const SDC_HCI_OPCODE_CMD_VS_QOS_CONN_EVENT_REPORT_ENABLE: sdc_hci_opcode_vs = 64772;
#[doc = "See sdc_hci_cmd_vs_event_length_set()."]
pub const SDC_HCI_OPCODE_CMD_VS_EVENT_LENGTH_SET: sdc_hci_opcode_vs = 64773;
#[doc = "See sdc_hci_cmd_vs_periodic_adv_event_length_set()."]
pub const SDC_HCI_OPCODE_CMD_VS_PERIODIC_ADV_EVENT_LENGTH_SET: sdc_hci_opcode_vs = 64774;
#[doc = "See sdc_hci_cmd_vs_peripheral_latency_mode_set()."]
pub const SDC_HCI_OPCODE_CMD_VS_PERIPHERAL_LATENCY_MODE_SET: sdc_hci_opcode_vs = 64777;
#[doc = "See sdc_hci_cmd_vs_write_remote_tx_power()."]
pub const SDC_HCI_OPCODE_CMD_VS_WRITE_REMOTE_TX_POWER: sdc_hci_opcode_vs = 64778;
#[doc = "See sdc_hci_cmd_vs_set_adv_randomness()."]
pub const SDC_HCI_OPCODE_CMD_VS_SET_ADV_RANDOMNESS: sdc_hci_opcode_vs = 64780;
#[doc = "See sdc_hci_cmd_vs_compat_mode_window_offset_set()."]
pub const SDC_HCI_OPCODE_CMD_VS_COMPAT_MODE_WINDOW_OFFSET_SET: sdc_hci_opcode_vs = 64781;
#[doc = "See sdc_hci_cmd_vs_qos_channel_survey_enable()."]
pub const SDC_HCI_OPCODE_CMD_VS_QOS_CHANNEL_SURVEY_ENABLE: sdc_hci_opcode_vs = 64782;
#[doc = "See sdc_hci_cmd_vs_set_power_control_request_params()."]
pub const SDC_HCI_OPCODE_CMD_VS_SET_POWER_CONTROL_REQUEST_PARAMS: sdc_hci_opcode_vs = 64784;
#[doc = "See sdc_hci_cmd_vs_read_average_rssi()."]
pub const SDC_HCI_OPCODE_CMD_VS_READ_AVERAGE_RSSI: sdc_hci_opcode_vs = 64785;
#[doc = "See sdc_hci_cmd_vs_central_acl_event_spacing_set()."]
pub const SDC_HCI_OPCODE_CMD_VS_CENTRAL_ACL_EVENT_SPACING_SET: sdc_hci_opcode_vs = 64786;
#[doc = "See sdc_hci_cmd_vs_get_next_conn_event_counter()."]
pub const SDC_HCI_OPCODE_CMD_VS_GET_NEXT_CONN_EVENT_COUNTER: sdc_hci_opcode_vs = 64788;
#[doc = "See sdc_hci_cmd_vs_allow_parallel_connection_establishments()."]
pub const SDC_HCI_OPCODE_CMD_VS_ALLOW_PARALLEL_CONNECTION_ESTABLISHMENTS: sdc_hci_opcode_vs = 64789;
#[doc = "See sdc_hci_cmd_vs_min_val_of_max_acl_tx_payload_set()."]
pub const SDC_HCI_OPCODE_CMD_VS_MIN_VAL_OF_MAX_ACL_TX_PAYLOAD_SET: sdc_hci_opcode_vs = 64790;
#[doc = "See sdc_hci_cmd_vs_iso_read_tx_timestamp()."]
pub const SDC_HCI_OPCODE_CMD_VS_ISO_READ_TX_TIMESTAMP: sdc_hci_opcode_vs = 64791;
#[doc = "See sdc_hci_cmd_vs_big_reserved_time_set()."]
pub const SDC_HCI_OPCODE_CMD_VS_BIG_RESERVED_TIME_SET: sdc_hci_opcode_vs = 64792;
#[doc = "See sdc_hci_cmd_vs_cig_reserved_time_set()."]
pub const SDC_HCI_OPCODE_CMD_VS_CIG_RESERVED_TIME_SET: sdc_hci_opcode_vs = 64793;
#[doc = "See sdc_hci_cmd_vs_cis_subevent_length_set()."]
pub const SDC_HCI_OPCODE_CMD_VS_CIS_SUBEVENT_LENGTH_SET: sdc_hci_opcode_vs = 64794;
#[doc = "See sdc_hci_cmd_vs_scan_channel_map_set()."]
pub const SDC_HCI_OPCODE_CMD_VS_SCAN_CHANNEL_MAP_SET: sdc_hci_opcode_vs = 64795;
#[doc = "See sdc_hci_cmd_vs_scan_accept_ext_adv_packets_set()."]
pub const SDC_HCI_OPCODE_CMD_VS_SCAN_ACCEPT_EXT_ADV_PACKETS_SET: sdc_hci_opcode_vs = 64796;
#[doc = "See sdc_hci_cmd_vs_set_role_priority()."]
pub const SDC_HCI_OPCODE_CMD_VS_SET_ROLE_PRIORITY: sdc_hci_opcode_vs = 64797;
#[doc = "See sdc_hci_cmd_vs_set_event_start_task()."]
pub const SDC_HCI_OPCODE_CMD_VS_SET_EVENT_START_TASK: sdc_hci_opcode_vs = 64798;
#[doc = "See sdc_hci_cmd_vs_conn_anchor_point_update_event_report_enable()."]
pub const SDC_HCI_OPCODE_CMD_VS_CONN_ANCHOR_POINT_UPDATE_EVENT_REPORT_ENABLE: sdc_hci_opcode_vs = 64799;
#[doc = "See sdc_hci_cmd_vs_enable_periodic_adv_event_counter_reports()."]
pub const SDC_HCI_OPCODE_CMD_VS_ENABLE_PERIODIC_ADV_EVENT_COUNTER_REPORTS: sdc_hci_opcode_vs = 64800;
#[doc = "See sdc_hci_cmd_vs_set_cs_event_length()."]
pub const SDC_HCI_OPCODE_CMD_VS_SET_CS_EVENT_LENGTH: sdc_hci_opcode_vs = 64801;
#[doc = "HCI VS OpCode Field values."]
pub type sdc_hci_opcode_vs = ::core::ffi::c_uint;
#[doc = "See sdc_hci_subevent_vs_qos_conn_event_report_t."]
pub const SDC_HCI_SUBEVENT_VS_QOS_CONN_EVENT_REPORT: sdc_hci_subevent_vs = 128;
#[doc = "See sdc_hci_subevent_vs_qos_channel_survey_report_t."]
pub const SDC_HCI_SUBEVENT_VS_QOS_CHANNEL_SURVEY_REPORT: sdc_hci_subevent_vs = 129;
#[doc = "See sdc_hci_subevent_vs_conn_anchor_point_update_report_t."]
pub const SDC_HCI_SUBEVENT_VS_CONN_ANCHOR_POINT_UPDATE_REPORT: sdc_hci_subevent_vs = 130;
#[doc = "See sdc_hci_subevent_vs_periodic_adv_event_counter_report_t."]
pub const SDC_HCI_SUBEVENT_VS_PERIODIC_ADV_EVENT_COUNTER_REPORT: sdc_hci_subevent_vs = 132;
#[doc = "VS subevent Code values."]
pub type sdc_hci_subevent_vs = ::core::ffi::c_uint;
#[doc = "Peripheral latency enable."]
pub const SDC_HCI_VS_PERIPHERAL_LATENCY_MODE_ENABLE: sdc_hci_vs_peripheral_latency_mode = 0;
#[doc = "Peripheral latency disable."]
pub const SDC_HCI_VS_PERIPHERAL_LATENCY_MODE_DISABLE: sdc_hci_vs_peripheral_latency_mode = 1;
#[doc = "Peripheral latency wait for ack."]
pub const SDC_HCI_VS_PERIPHERAL_LATENCY_MODE_WAIT_FOR_ACK: sdc_hci_vs_peripheral_latency_mode = 2;
#[doc = "Peripheral latency disable/enable modes."]
pub type sdc_hci_vs_peripheral_latency_mode = ::core::ffi::c_uint;
#[doc = "Scanner."]
pub const SDC_HCI_VS_SET_EVENT_START_TASK_HANDLE_TYPE_SCAN: sdc_hci_vs_set_event_start_task_handle_type = 1;
#[doc = "Initiator."]
pub const SDC_HCI_VS_SET_EVENT_START_TASK_HANDLE_TYPE_INITIATOR: sdc_hci_vs_set_event_start_task_handle_type = 2;
#[doc = "Connection."]
pub const SDC_HCI_VS_SET_EVENT_START_TASK_HANDLE_TYPE_CONN: sdc_hci_vs_set_event_start_task_handle_type = 3;
#[doc = "Advertiser."]
pub const SDC_HCI_VS_SET_EVENT_START_TASK_HANDLE_TYPE_ADV: sdc_hci_vs_set_event_start_task_handle_type = 4;
#[doc = "Set Event Start Task Handle Type."]
pub type sdc_hci_vs_set_event_start_task_handle_type = ::core::ffi::c_uint;
#[doc = "Handle of type initiator. Only affects secondary channel priority."]
pub const SDC_HCI_VS_SET_ROLE_PRIORITY_HANDLE_TYPE_INITIATOR_SECONDARY_CHANNEL:
    sdc_hci_vs_set_role_priority_handle_type = 4;
#[doc = "Handle type for priority update."]
pub type sdc_hci_vs_set_role_priority_handle_type = ::core::ffi::c_uint;
#[doc = "Handle of type Advertiser."]
pub const SDC_HCI_VS_TX_POWER_HANDLE_TYPE_ADV: sdc_hci_vs_tx_power_handle_type = 0;
#[doc = "Handle of type Scanner or Initiator."]
pub const SDC_HCI_VS_TX_POWER_HANDLE_TYPE_SCAN_INIT: sdc_hci_vs_tx_power_handle_type = 1;
#[doc = "Handle of type Connection."]
pub const SDC_HCI_VS_TX_POWER_HANDLE_TYPE_CONN: sdc_hci_vs_tx_power_handle_type = 2;
#[doc = "Handle of type Periodic Sync."]
pub const SDC_HCI_VS_TX_POWER_HANDLE_TYPE_SYNC: sdc_hci_vs_tx_power_handle_type = 3;
#[doc = "Handle of type ISO broadcaster."]
pub const SDC_HCI_VS_TX_POWER_HANDLE_TYPE_ISO_BROADCASTER: sdc_hci_vs_tx_power_handle_type = 4;
#[doc = "TX power handle type."]
pub type sdc_hci_vs_tx_power_handle_type = ::core::ffi::c_uint;
#[doc = "Zephyr Static Address type."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_vs_zephyr_static_address_t {
    #[doc = "Static device address."]
    pub address: [u8; 6usize],
    #[doc = "Identity root key (IR) for static device address. All zero parameter value indicates\n missing identity root key."]
    pub identity_root: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_vs_zephyr_static_address_t"]
        [::core::mem::size_of::<sdc_hci_vs_zephyr_static_address_t>() - 22usize];
    ["Alignment of sdc_hci_vs_zephyr_static_address_t"]
        [::core::mem::align_of::<sdc_hci_vs_zephyr_static_address_t>() - 1usize];
    ["Offset of field: sdc_hci_vs_zephyr_static_address_t::address"]
        [::core::mem::offset_of!(sdc_hci_vs_zephyr_static_address_t, address) - 0usize];
    ["Offset of field: sdc_hci_vs_zephyr_static_address_t::identity_root"]
        [::core::mem::offset_of!(sdc_hci_vs_zephyr_static_address_t, identity_root) - 6usize];
};
#[doc = "Zephyr supported commands.\n\n If the field is set to 1, it indicates that the underlying command and\n feature is supported by the controller."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_vs_zephyr_supported_commands_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_vs_zephyr_supported_commands_t"]
        [::core::mem::size_of::<sdc_hci_vs_zephyr_supported_commands_t>() - 2usize];
    ["Alignment of sdc_hci_vs_zephyr_supported_commands_t"]
        [::core::mem::align_of::<sdc_hci_vs_zephyr_supported_commands_t>() - 1usize];
};
impl sdc_hci_vs_zephyr_supported_commands_t {
    #[inline]
    pub fn read_version_info(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_read_version_info(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn read_version_info_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_read_version_info_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn read_supported_commands(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_read_supported_commands(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn read_supported_commands_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_read_supported_commands_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn read_supported_features(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_read_supported_features(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn read_supported_features_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_read_supported_features_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn set_event_mask(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_set_event_mask(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn set_event_mask_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_set_event_mask_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reset(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_reset(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reset_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_reset_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn write_bd_addr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_write_bd_addr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn write_bd_addr_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_write_bd_addr_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn set_trace_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_set_trace_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn set_trace_enable_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_set_trace_enable_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn read_build_info(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_read_build_info(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn read_build_info_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_read_build_info_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn read_static_addresses(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_read_static_addresses(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn read_static_addresses_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_read_static_addresses_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn read_key_hierarchy_roots(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_read_key_hierarchy_roots(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn read_key_hierarchy_roots_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_read_key_hierarchy_roots_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn read_chip_temperature(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_read_chip_temperature(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn read_chip_temperature_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_read_chip_temperature_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn read_host_stack_commands(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_read_host_stack_commands(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn read_host_stack_commands_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_read_host_stack_commands_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn set_scan_request_reports(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_set_scan_request_reports(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn set_scan_request_reports_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_set_scan_request_reports_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn write_tx_power_level(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_write_tx_power_level(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn write_tx_power_level_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_write_tx_power_level_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn read_tx_power_level(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_read_tx_power_level(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn read_tx_power_level_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_read_tx_power_level_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        read_version_info: u8,
        read_supported_commands: u8,
        read_supported_features: u8,
        set_event_mask: u8,
        reset: u8,
        write_bd_addr: u8,
        set_trace_enable: u8,
        read_build_info: u8,
        read_static_addresses: u8,
        read_key_hierarchy_roots: u8,
        read_chip_temperature: u8,
        read_host_stack_commands: u8,
        set_scan_request_reports: u8,
        write_tx_power_level: u8,
        read_tx_power_level: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let read_version_info: u8 = unsafe { ::core::mem::transmute(read_version_info) };
            read_version_info as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let read_supported_commands: u8 = unsafe { ::core::mem::transmute(read_supported_commands) };
            read_supported_commands as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let read_supported_features: u8 = unsafe { ::core::mem::transmute(read_supported_features) };
            read_supported_features as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let set_event_mask: u8 = unsafe { ::core::mem::transmute(set_event_mask) };
            set_event_mask as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let reset: u8 = unsafe { ::core::mem::transmute(reset) };
            reset as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let write_bd_addr: u8 = unsafe { ::core::mem::transmute(write_bd_addr) };
            write_bd_addr as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let set_trace_enable: u8 = unsafe { ::core::mem::transmute(set_trace_enable) };
            set_trace_enable as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let read_build_info: u8 = unsafe { ::core::mem::transmute(read_build_info) };
            read_build_info as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let read_static_addresses: u8 = unsafe { ::core::mem::transmute(read_static_addresses) };
            read_static_addresses as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let read_key_hierarchy_roots: u8 = unsafe { ::core::mem::transmute(read_key_hierarchy_roots) };
            read_key_hierarchy_roots as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let read_chip_temperature: u8 = unsafe { ::core::mem::transmute(read_chip_temperature) };
            read_chip_temperature as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let read_host_stack_commands: u8 = unsafe { ::core::mem::transmute(read_host_stack_commands) };
            read_host_stack_commands as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let set_scan_request_reports: u8 = unsafe { ::core::mem::transmute(set_scan_request_reports) };
            set_scan_request_reports as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let write_tx_power_level: u8 = unsafe { ::core::mem::transmute(write_tx_power_level) };
            write_tx_power_level as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let read_tx_power_level: u8 = unsafe { ::core::mem::transmute(read_tx_power_level) };
            read_tx_power_level as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "QoS Connection Event Report.\n\n A QoS Connection Event report gives information about the connection event."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_subevent_vs_qos_conn_event_report_t {
    #[doc = "Connection handle corresponding to the connection event report."]
    pub conn_handle: u16,
    #[doc = "Connection event counter corresponding to the connection event report."]
    pub event_counter: u16,
    #[doc = "Data Channel Index used during the connection event (0-36)."]
    pub channel_index: u8,
    #[doc = "Number of packets received with good CRC during the connection event."]
    pub crc_ok_count: u16,
    #[doc = "Number of packets received with bad CRC during the connection event."]
    pub crc_error_count: u16,
    #[doc = "Number of received Negative Acknowledges from the peer during the connection event."]
    pub nak_count: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_subevent_vs_qos_conn_event_report_t"]
        [::core::mem::size_of::<sdc_hci_subevent_vs_qos_conn_event_report_t>() - 12usize];
    ["Alignment of sdc_hci_subevent_vs_qos_conn_event_report_t"]
        [::core::mem::align_of::<sdc_hci_subevent_vs_qos_conn_event_report_t>() - 1usize];
    ["Offset of field: sdc_hci_subevent_vs_qos_conn_event_report_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_subevent_vs_qos_conn_event_report_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_subevent_vs_qos_conn_event_report_t::event_counter"]
        [::core::mem::offset_of!(sdc_hci_subevent_vs_qos_conn_event_report_t, event_counter) - 2usize];
    ["Offset of field: sdc_hci_subevent_vs_qos_conn_event_report_t::channel_index"]
        [::core::mem::offset_of!(sdc_hci_subevent_vs_qos_conn_event_report_t, channel_index) - 4usize];
    ["Offset of field: sdc_hci_subevent_vs_qos_conn_event_report_t::crc_ok_count"]
        [::core::mem::offset_of!(sdc_hci_subevent_vs_qos_conn_event_report_t, crc_ok_count) - 5usize];
    ["Offset of field: sdc_hci_subevent_vs_qos_conn_event_report_t::crc_error_count"]
        [::core::mem::offset_of!(sdc_hci_subevent_vs_qos_conn_event_report_t, crc_error_count) - 7usize];
    ["Offset of field: sdc_hci_subevent_vs_qos_conn_event_report_t::nak_count"]
        [::core::mem::offset_of!(sdc_hci_subevent_vs_qos_conn_event_report_t, nak_count) - 9usize];
};
impl sdc_hci_subevent_vs_qos_conn_event_report_t {
    #[inline]
    pub fn rx_timeout(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rx_timeout(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rx_timeout_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rx_timeout_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(rx_timeout: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rx_timeout: u8 = unsafe { ::core::mem::transmute(rx_timeout) };
            rx_timeout as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "QoS Channel Survey report event.\n\n QoS Channel Survey report event"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_subevent_vs_qos_channel_survey_report_t {
    #[doc = "The measured energy on the Bluetooth Low Energy channels, in dBm, indexed by Channel\n Index. If no measurement is available for the given channel, channel_energy is set to\n 127."]
    pub channel_energy: [i8; 40usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_subevent_vs_qos_channel_survey_report_t"]
        [::core::mem::size_of::<sdc_hci_subevent_vs_qos_channel_survey_report_t>() - 40usize];
    ["Alignment of sdc_hci_subevent_vs_qos_channel_survey_report_t"]
        [::core::mem::align_of::<sdc_hci_subevent_vs_qos_channel_survey_report_t>() - 1usize];
    ["Offset of field: sdc_hci_subevent_vs_qos_channel_survey_report_t::channel_energy"]
        [::core::mem::offset_of!(sdc_hci_subevent_vs_qos_channel_survey_report_t, channel_energy) - 0usize];
};
#[doc = "Connection Anchor Point Update Report Event.\n\n The HCI_VS_conn_anchor_point_update_report event indicates that the device\n updated the anchor point for an ACL connection.\n The anchor point represents the start of the first packet of a connection event.\n See Core_v5.4, Vol 6, Part B, Section 4.5.1.\n\n The controller only generates HCI_VS_conn_anchor_point_update_report events\n if instructed to do so using the\n sdc_hci_cmd_vs_conn_anchor_point_update_event_report_enable command.\n\n The anchor_point_us in this event is a timestamp on the controller's clock.\n\n On the central device, this event is generated every connection interval.\n On the peripheral device, this event is only generated for connection events in which\n a packet from the central device is received."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_subevent_vs_conn_anchor_point_update_report_t {
    #[doc = "Connection handle corresponding to the connection anchor point update report."]
    pub conn_handle: u16,
    #[doc = "Connection event counter corresponding to the anchor point."]
    pub event_counter: u16,
    #[doc = "Absolute time of the new anchor point in microseconds."]
    pub anchor_point_us: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_subevent_vs_conn_anchor_point_update_report_t"]
        [::core::mem::size_of::<sdc_hci_subevent_vs_conn_anchor_point_update_report_t>() - 12usize];
    ["Alignment of sdc_hci_subevent_vs_conn_anchor_point_update_report_t"]
        [::core::mem::align_of::<sdc_hci_subevent_vs_conn_anchor_point_update_report_t>() - 1usize];
    ["Offset of field: sdc_hci_subevent_vs_conn_anchor_point_update_report_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_subevent_vs_conn_anchor_point_update_report_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_subevent_vs_conn_anchor_point_update_report_t::event_counter"]
        [::core::mem::offset_of!(sdc_hci_subevent_vs_conn_anchor_point_update_report_t, event_counter) - 2usize];
    ["Offset of field: sdc_hci_subevent_vs_conn_anchor_point_update_report_t::anchor_point_us"]
        [::core::mem::offset_of!(sdc_hci_subevent_vs_conn_anchor_point_update_report_t, anchor_point_us) - 4usize];
};
#[doc = "Periodic Advertising Event Counter Report.\n\n This event indicates that the controller updated the event counter for a periodic advertisement.\n\n These will only be generated if enabled through the\n sdc_hci_cmd_vs_enable_periodic_adv_event_counter_reports command."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_subevent_vs_periodic_adv_event_counter_report_t {
    #[doc = "Advertising handle for the periodic advertisement whose event counter was updated."]
    pub adv_handle: u8,
    #[doc = "Event counter."]
    pub pa_event_counter: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_subevent_vs_periodic_adv_event_counter_report_t"]
        [::core::mem::size_of::<sdc_hci_subevent_vs_periodic_adv_event_counter_report_t>() - 3usize];
    ["Alignment of sdc_hci_subevent_vs_periodic_adv_event_counter_report_t"]
        [::core::mem::align_of::<sdc_hci_subevent_vs_periodic_adv_event_counter_report_t>() - 1usize];
    ["Offset of field: sdc_hci_subevent_vs_periodic_adv_event_counter_report_t::adv_handle"]
        [::core::mem::offset_of!(sdc_hci_subevent_vs_periodic_adv_event_counter_report_t, adv_handle) - 0usize];
    ["Offset of field: sdc_hci_subevent_vs_periodic_adv_event_counter_report_t::pa_event_counter"][::core::mem::offset_of!(
        sdc_hci_subevent_vs_periodic_adv_event_counter_report_t,
        pa_event_counter
    ) - 1usize];
};
#[doc = "Zephyr Read Version Information return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_zephyr_read_version_info_return_t {
    #[doc = "Assigned hardware manufacturer. Always 0x0002 indicating Nordic Semiconductor."]
    pub hw_platform: u16,
    #[doc = "Assigned platform specific value. Set to 0x2 for nRF52, 0x3 for nRF53, 0x4 for\n nRF54H, 0x5 for nRF54L."]
    pub hw_variant: u16,
    #[doc = "Firmware Variant. 0 indicates a standard Bluetooth controller."]
    pub fw_variant: u8,
    #[doc = "Firmware Version."]
    pub fw_version: u8,
    #[doc = "Firmware Revision."]
    pub fw_revision: u16,
    #[doc = "Firmware build revision."]
    pub fw_build: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_zephyr_read_version_info_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_zephyr_read_version_info_return_t>() - 12usize];
    ["Alignment of sdc_hci_cmd_vs_zephyr_read_version_info_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_zephyr_read_version_info_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_zephyr_read_version_info_return_t::hw_platform"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_zephyr_read_version_info_return_t, hw_platform) - 0usize];
    ["Offset of field: sdc_hci_cmd_vs_zephyr_read_version_info_return_t::hw_variant"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_zephyr_read_version_info_return_t, hw_variant) - 2usize];
    ["Offset of field: sdc_hci_cmd_vs_zephyr_read_version_info_return_t::fw_variant"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_zephyr_read_version_info_return_t, fw_variant) - 4usize];
    ["Offset of field: sdc_hci_cmd_vs_zephyr_read_version_info_return_t::fw_version"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_zephyr_read_version_info_return_t, fw_version) - 5usize];
    ["Offset of field: sdc_hci_cmd_vs_zephyr_read_version_info_return_t::fw_revision"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_zephyr_read_version_info_return_t, fw_revision) - 6usize];
    ["Offset of field: sdc_hci_cmd_vs_zephyr_read_version_info_return_t::fw_build"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_zephyr_read_version_info_return_t, fw_build) - 8usize];
};
#[doc = "Zephyr Read Supported Commands return parameter(s)."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union sdc_hci_cmd_vs_zephyr_read_supported_commands_return_t {
    #[doc = "Bit mask for each vendor command. If a bit is 1, the Controller supports the\n corresponding command and the features required for the command, unsupported or\n undefined commands shall be set to 0."]
    pub params: sdc_hci_vs_zephyr_supported_commands_t,
    pub raw: [u8; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_zephyr_read_supported_commands_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_zephyr_read_supported_commands_return_t>() - 64usize];
    ["Alignment of sdc_hci_cmd_vs_zephyr_read_supported_commands_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_zephyr_read_supported_commands_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_zephyr_read_supported_commands_return_t::params"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_zephyr_read_supported_commands_return_t, params) - 0usize];
    ["Offset of field: sdc_hci_cmd_vs_zephyr_read_supported_commands_return_t::raw"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_zephyr_read_supported_commands_return_t, raw) - 0usize];
};
#[doc = "Zephyr Write BD ADDR command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_zephyr_write_bd_addr_t {
    #[doc = "BD_ADDR of the Device."]
    pub bd_addr: [u8; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_zephyr_write_bd_addr_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_zephyr_write_bd_addr_t>() - 6usize];
    ["Alignment of sdc_hci_cmd_vs_zephyr_write_bd_addr_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_zephyr_write_bd_addr_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_zephyr_write_bd_addr_t::bd_addr"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_zephyr_write_bd_addr_t, bd_addr) - 0usize];
};
#[doc = "Zephyr Read Static Addresses return parameter(s)."]
#[repr(C, packed)]
pub struct sdc_hci_cmd_vs_zephyr_read_static_addresses_return_t {
    #[doc = "Number of static device addresses."]
    pub num_addresses: u8,
    #[doc = "Zephyr Static Addresses. The number of addresses is specified in num_addresses."]
    pub addresses: __IncompleteArrayField<sdc_hci_vs_zephyr_static_address_t>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_zephyr_read_static_addresses_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_zephyr_read_static_addresses_return_t>() - 1usize];
    ["Alignment of sdc_hci_cmd_vs_zephyr_read_static_addresses_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_zephyr_read_static_addresses_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_zephyr_read_static_addresses_return_t::num_addresses"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_zephyr_read_static_addresses_return_t, num_addresses) - 0usize];
    ["Offset of field: sdc_hci_cmd_vs_zephyr_read_static_addresses_return_t::addresses"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_zephyr_read_static_addresses_return_t, addresses) - 1usize];
};
#[doc = "Zephyr Read KEY Hierarchy Roots return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots_return_t {
    #[doc = "Zephyr Identity Root Key."]
    pub ir: [u8; 16usize],
    #[doc = "Zephyr Encryption Root Key."]
    pub er: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots_return_t>() - 32usize];
    ["Alignment of sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots_return_t::ir"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots_return_t, ir) - 0usize];
    ["Offset of field: sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots_return_t::er"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots_return_t, er) - 16usize];
};
#[doc = "Zephyr Read Chip Temperature return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_zephyr_read_chip_temp_return_t {
    #[doc = "The measured temperature in degrees Celsius."]
    pub temp: i8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_zephyr_read_chip_temp_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_zephyr_read_chip_temp_return_t>() - 1usize];
    ["Alignment of sdc_hci_cmd_vs_zephyr_read_chip_temp_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_zephyr_read_chip_temp_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_zephyr_read_chip_temp_return_t::temp"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_zephyr_read_chip_temp_return_t, temp) - 0usize];
};
#[doc = "Zephyr Write Tx Power Level (per Role/Connection) command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_zephyr_write_tx_power_t {
    #[doc = "Handle type. See sdc_hci_vs_tx_power_handle_type."]
    pub handle_type: u8,
    #[doc = "Handle of the selected handle_type that identifies the instance to set the power of.\n In case of Extended Advertising, the handle specifies the advertising set. In case of\n a connection, it specifies a Connection Handle. Otherwise this parameter is ignored."]
    pub handle: u16,
    #[doc = "The desired Tx_Power_Level at the antenna in dBm in signed 1 octet integer format. If\n set to 127, this indicates that the controller shall revert to using its default\n setting for Tx power. If the selected power level is not supported, an error is\n returned."]
    pub tx_power_level: i8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_zephyr_write_tx_power_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_zephyr_write_tx_power_t>() - 4usize];
    ["Alignment of sdc_hci_cmd_vs_zephyr_write_tx_power_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_zephyr_write_tx_power_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_zephyr_write_tx_power_t::handle_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_zephyr_write_tx_power_t, handle_type) - 0usize];
    ["Offset of field: sdc_hci_cmd_vs_zephyr_write_tx_power_t::handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_zephyr_write_tx_power_t, handle) - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_zephyr_write_tx_power_t::tx_power_level"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_zephyr_write_tx_power_t, tx_power_level) - 3usize];
};
#[doc = "Zephyr Write Tx Power Level (per Role/Connection) return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_zephyr_write_tx_power_return_t {
    #[doc = "Handle type. See sdc_hci_vs_tx_power_handle_type."]
    pub handle_type: u8,
    #[doc = "See sdc_hci_cmd_vs_zephyr_write_tx_power_t."]
    pub handle: u16,
    #[doc = "The selected Tx Power in dBm."]
    pub selected_tx_power: i8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_zephyr_write_tx_power_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_zephyr_write_tx_power_return_t>() - 4usize];
    ["Alignment of sdc_hci_cmd_vs_zephyr_write_tx_power_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_zephyr_write_tx_power_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_zephyr_write_tx_power_return_t::handle_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_zephyr_write_tx_power_return_t, handle_type) - 0usize];
    ["Offset of field: sdc_hci_cmd_vs_zephyr_write_tx_power_return_t::handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_zephyr_write_tx_power_return_t, handle) - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_zephyr_write_tx_power_return_t::selected_tx_power"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_zephyr_write_tx_power_return_t, selected_tx_power) - 3usize];
};
#[doc = "Zephyr Read Tx Power Level (per Role/Connection) Command command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_zephyr_read_tx_power_t {
    #[doc = "Handle type. See sdc_hci_vs_tx_power_handle_type."]
    pub handle_type: u8,
    #[doc = "Handle of the selected handle_type that identifies the instance to set the power of.\n In case of Extended Advertising, the handle specifies the advertising set. In case of\n a connection, it specifies a Connection Handle. Otherwise this parameter is ignored."]
    pub handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_zephyr_read_tx_power_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_zephyr_read_tx_power_t>() - 3usize];
    ["Alignment of sdc_hci_cmd_vs_zephyr_read_tx_power_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_zephyr_read_tx_power_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_zephyr_read_tx_power_t::handle_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_zephyr_read_tx_power_t, handle_type) - 0usize];
    ["Offset of field: sdc_hci_cmd_vs_zephyr_read_tx_power_t::handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_zephyr_read_tx_power_t, handle) - 1usize];
};
#[doc = "Zephyr Read Tx Power Level (per Role/Connection) Command return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_zephyr_read_tx_power_return_t {
    #[doc = "Handle type. See sdc_hci_vs_tx_power_handle_type."]
    pub handle_type: u8,
    #[doc = "See sdc_hci_cmd_vs_zephyr_read_tx_power_t."]
    pub handle: u16,
    #[doc = "The selected Tx Power in dBm."]
    pub selected_tx_power: i8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_zephyr_read_tx_power_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_zephyr_read_tx_power_return_t>() - 4usize];
    ["Alignment of sdc_hci_cmd_vs_zephyr_read_tx_power_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_zephyr_read_tx_power_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_zephyr_read_tx_power_return_t::handle_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_zephyr_read_tx_power_return_t, handle_type) - 0usize];
    ["Offset of field: sdc_hci_cmd_vs_zephyr_read_tx_power_return_t::handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_zephyr_read_tx_power_return_t, handle) - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_zephyr_read_tx_power_return_t::selected_tx_power"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_zephyr_read_tx_power_return_t, selected_tx_power) - 3usize];
};
#[doc = "Set Low Latency Packet Mode command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_llpm_mode_set_t {
    #[doc = "Set to 1 to enable LLPM."]
    pub enable: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_llpm_mode_set_t"][::core::mem::size_of::<sdc_hci_cmd_vs_llpm_mode_set_t>() - 1usize];
    ["Alignment of sdc_hci_cmd_vs_llpm_mode_set_t"][::core::mem::align_of::<sdc_hci_cmd_vs_llpm_mode_set_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_llpm_mode_set_t::enable"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_llpm_mode_set_t, enable) - 0usize];
};
#[doc = "Connection Update command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_conn_update_t {
    #[doc = "Connection Handle."]
    pub conn_handle: u16,
    #[doc = "Connection Interval in microseconds. Valid range is 7,500 us to 4,000,000 us in 1,250\n us steps. If LLPM mode is enabled, parameters in the range 1,000 us to 7,000 us in\n 1,000 us steps are also accepted."]
    pub conn_interval_us: u32,
    #[doc = "Slave latency for the connection in number of connection events."]
    pub conn_latency: u16,
    #[doc = "Supervision timeout for the LE Link in 10 ms units. Range 100 ms to 32 s."]
    pub supervision_timeout: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_conn_update_t"][::core::mem::size_of::<sdc_hci_cmd_vs_conn_update_t>() - 10usize];
    ["Alignment of sdc_hci_cmd_vs_conn_update_t"][::core::mem::align_of::<sdc_hci_cmd_vs_conn_update_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_conn_update_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_conn_update_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_vs_conn_update_t::conn_interval_us"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_conn_update_t, conn_interval_us) - 2usize];
    ["Offset of field: sdc_hci_cmd_vs_conn_update_t::conn_latency"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_conn_update_t, conn_latency) - 6usize];
    ["Offset of field: sdc_hci_cmd_vs_conn_update_t::supervision_timeout"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_conn_update_t, supervision_timeout) - 8usize];
};
#[doc = "Enable or Disable Extended Connection Events command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_conn_event_extend_t {
    #[doc = "Set to 0 for disabling, 1 for enabling, all other values are RFU."]
    pub enable: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_conn_event_extend_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_conn_event_extend_t>() - 1usize];
    ["Alignment of sdc_hci_cmd_vs_conn_event_extend_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_conn_event_extend_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_conn_event_extend_t::enable"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_conn_event_extend_t, enable) - 0usize];
};
#[doc = "QoS Connection Event Reports enable command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_qos_conn_event_report_enable_t {
    #[doc = "Set to 1 to enable, 0 to disable, all other values are RFU."]
    pub enable: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_qos_conn_event_report_enable_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_qos_conn_event_report_enable_t>() - 1usize];
    ["Alignment of sdc_hci_cmd_vs_qos_conn_event_report_enable_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_qos_conn_event_report_enable_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_qos_conn_event_report_enable_t::enable"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_qos_conn_event_report_enable_t, enable) - 0usize];
};
#[doc = "Set event length for ACL connections command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_event_length_set_t {
    #[doc = "Allocated event length in microseconds."]
    pub event_length_us: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_event_length_set_t"][::core::mem::size_of::<sdc_hci_cmd_vs_event_length_set_t>() - 4usize];
    ["Alignment of sdc_hci_cmd_vs_event_length_set_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_event_length_set_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_event_length_set_t::event_length_us"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_event_length_set_t, event_length_us) - 0usize];
};
#[doc = "Set event length for periodic advertisers command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_periodic_adv_event_length_set_t {
    #[doc = "Allocated periodic advertising event length in microseconds."]
    pub event_length_us: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_periodic_adv_event_length_set_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_periodic_adv_event_length_set_t>() - 4usize];
    ["Alignment of sdc_hci_cmd_vs_periodic_adv_event_length_set_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_periodic_adv_event_length_set_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_periodic_adv_event_length_set_t::event_length_us"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_periodic_adv_event_length_set_t, event_length_us) - 0usize];
};
#[doc = "Set peripheral latency mode command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_peripheral_latency_mode_set_t {
    #[doc = "Connection handle."]
    pub conn_handle: u16,
    #[doc = "Peripheral latency mode. See sdc_hci_vs_peripheral_latency_mode."]
    pub mode: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_peripheral_latency_mode_set_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_peripheral_latency_mode_set_t>() - 3usize];
    ["Alignment of sdc_hci_cmd_vs_peripheral_latency_mode_set_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_peripheral_latency_mode_set_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_peripheral_latency_mode_set_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_peripheral_latency_mode_set_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_vs_peripheral_latency_mode_set_t::mode"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_peripheral_latency_mode_set_t, mode) - 2usize];
};
#[doc = "Write remote transmit power level command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_write_remote_tx_power_t {
    pub conn_handle: u16,
    #[doc = "PHY bit number i.e. 2M, s8, s2] == 2, 3, 4]."]
    pub phy: u8,
    #[doc = "Requested adjustment (in dBm) for the remote to apply to its transmit power. The\n value can be 0 to utilize the response of the peer to update the information on the\n transmit power setting of the remote. Note that this is only a request to the peer,\n which is in control of how, if at all, to apply changes to its transmit power."]
    pub delta: i8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_write_remote_tx_power_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_write_remote_tx_power_t>() - 4usize];
    ["Alignment of sdc_hci_cmd_vs_write_remote_tx_power_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_write_remote_tx_power_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_write_remote_tx_power_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_write_remote_tx_power_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_vs_write_remote_tx_power_t::phy"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_write_remote_tx_power_t, phy) - 2usize];
    ["Offset of field: sdc_hci_cmd_vs_write_remote_tx_power_t::delta"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_write_remote_tx_power_t, delta) - 3usize];
};
#[doc = "Set advertising randomness command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_set_adv_randomness_t {
    #[doc = "Advertising Handle or 0xFF to set the behavior for the very first advertising event."]
    pub adv_handle: u8,
    #[doc = "Maximum random delay in microseconds, 0 to disable randomness."]
    pub rand_us: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_set_adv_randomness_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_set_adv_randomness_t>() - 3usize];
    ["Alignment of sdc_hci_cmd_vs_set_adv_randomness_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_set_adv_randomness_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_set_adv_randomness_t::adv_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_set_adv_randomness_t, adv_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_vs_set_adv_randomness_t::rand_us"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_set_adv_randomness_t, rand_us) - 1usize];
};
#[doc = "Set Compatibility mode for window offset command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_compat_mode_window_offset_set_t {
    #[doc = "Set to 1 to enable this compatibility mode."]
    pub enable: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_compat_mode_window_offset_set_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_compat_mode_window_offset_set_t>() - 1usize];
    ["Alignment of sdc_hci_cmd_vs_compat_mode_window_offset_set_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_compat_mode_window_offset_set_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_compat_mode_window_offset_set_t::enable"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_compat_mode_window_offset_set_t, enable) - 0usize];
};
#[doc = "Enable the Quality of Service (QoS) channel survey module. command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_qos_channel_survey_enable_t {
    #[doc = "Set to 0 to disable, 1 to enable, all other values are RFU."]
    pub enable: u8,
    #[doc = "Requested average interval for the measurements and reports. Valid range is from 7500\n to 4000000. If set to 0, the measurements will be scheduled at every available\n opportunity."]
    pub interval_us: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_qos_channel_survey_enable_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_qos_channel_survey_enable_t>() - 5usize];
    ["Alignment of sdc_hci_cmd_vs_qos_channel_survey_enable_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_qos_channel_survey_enable_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_qos_channel_survey_enable_t::enable"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_qos_channel_survey_enable_t, enable) - 0usize];
    ["Offset of field: sdc_hci_cmd_vs_qos_channel_survey_enable_t::interval_us"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_qos_channel_survey_enable_t, interval_us) - 1usize];
};
#[doc = "Set LE Power Control Request procedure parameters command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_set_power_control_request_params_t {
    #[doc = "Enable or Disable controller initiated autonomous LE Power Control Request procedure.\n Disabled by default."]
    pub auto_enable: u8,
    #[doc = "Enable or Disable received APR handling in controller during LE Power Control Request\n procedure. Disabled by default."]
    pub apr_enable: u8,
    #[doc = "The valid range is 4095]. Default value is 2048."]
    pub beta: u16,
    #[doc = "The lower limit of the RSSI golden range. The RSSI golden range is explained in\n Core_v5.4, Vol 6, Part B, Section 5.1.17.1. Default value is -70 dBm."]
    pub lower_limit: i8,
    #[doc = "The upper limit of the RSSI golden range. Default value is -30 dBm."]
    pub upper_limit: i8,
    #[doc = "Target RSSI level in dBm units when the average RSSI level is less than the lower\n limit of RSSI Golden range. Default value is -65 dBm."]
    pub lower_target_rssi: i8,
    #[doc = "Target RSSI level in dBm units when the average RSSI level is greater than the upper\n limit of RSSI Golden range. Default value is -35 dBm."]
    pub upper_target_rssi: i8,
    #[doc = "Duration in milliseconds to wait before initiating a new LE Power Control Request\n procedure by the controller. Default value is 5000 milliseconds. 0 milliseconds value\n is an invalid value."]
    pub wait_period_ms: u16,
    #[doc = "Margin between APR value received from peer in LL_POWER_CONTROL_RSP PDU and actual\n reduction in Transmit power that is applied locally. The applied decrease in local\n Transmit power will be (received_apr - apr_margin) if received_apr > apr_margin,\n otherwise no change. Default value is 5 dB."]
    pub apr_margin: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_set_power_control_request_params_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_set_power_control_request_params_t>() - 11usize];
    ["Alignment of sdc_hci_cmd_vs_set_power_control_request_params_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_set_power_control_request_params_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_set_power_control_request_params_t::auto_enable"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_set_power_control_request_params_t, auto_enable) - 0usize];
    ["Offset of field: sdc_hci_cmd_vs_set_power_control_request_params_t::apr_enable"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_set_power_control_request_params_t, apr_enable) - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_set_power_control_request_params_t::beta"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_set_power_control_request_params_t, beta) - 2usize];
    ["Offset of field: sdc_hci_cmd_vs_set_power_control_request_params_t::lower_limit"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_set_power_control_request_params_t, lower_limit) - 4usize];
    ["Offset of field: sdc_hci_cmd_vs_set_power_control_request_params_t::upper_limit"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_set_power_control_request_params_t, upper_limit) - 5usize];
    ["Offset of field: sdc_hci_cmd_vs_set_power_control_request_params_t::lower_target_rssi"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_set_power_control_request_params_t, lower_target_rssi) - 6usize];
    ["Offset of field: sdc_hci_cmd_vs_set_power_control_request_params_t::upper_target_rssi"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_set_power_control_request_params_t, upper_target_rssi) - 7usize];
    ["Offset of field: sdc_hci_cmd_vs_set_power_control_request_params_t::wait_period_ms"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_set_power_control_request_params_t, wait_period_ms) - 8usize];
    ["Offset of field: sdc_hci_cmd_vs_set_power_control_request_params_t::apr_margin"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_set_power_control_request_params_t, apr_margin) - 10usize];
};
#[doc = "Read average RSSI command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_read_average_rssi_t {
    #[doc = "Connection Handle to read the average RSSI for."]
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_read_average_rssi_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_read_average_rssi_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_vs_read_average_rssi_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_read_average_rssi_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_read_average_rssi_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_read_average_rssi_t, conn_handle) - 0usize];
};
#[doc = "Read average RSSI return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_read_average_rssi_return_t {
    pub conn_handle: u16,
    #[doc = "Average RSSI in dBm."]
    pub avg_rssi: i8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_read_average_rssi_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_read_average_rssi_return_t>() - 3usize];
    ["Alignment of sdc_hci_cmd_vs_read_average_rssi_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_read_average_rssi_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_read_average_rssi_return_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_read_average_rssi_return_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_vs_read_average_rssi_return_t::avg_rssi"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_read_average_rssi_return_t, avg_rssi) - 2usize];
};
#[doc = "Set Central ACL event spacing command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_central_acl_event_spacing_set_t {
    #[doc = "Central ACL event spacing in microseconds."]
    pub central_acl_event_spacing_us: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_central_acl_event_spacing_set_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_central_acl_event_spacing_set_t>() - 4usize];
    ["Alignment of sdc_hci_cmd_vs_central_acl_event_spacing_set_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_central_acl_event_spacing_set_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_central_acl_event_spacing_set_t::central_acl_event_spacing_us"][::core::mem::offset_of!(
        sdc_hci_cmd_vs_central_acl_event_spacing_set_t,
        central_acl_event_spacing_us
    ) - 0usize];
};
#[doc = "Get Next Connection Event Counter command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_get_next_conn_event_counter_t {
    #[doc = "Connection handle to get the connection event counter value for."]
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_get_next_conn_event_counter_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_get_next_conn_event_counter_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_vs_get_next_conn_event_counter_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_get_next_conn_event_counter_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_get_next_conn_event_counter_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_get_next_conn_event_counter_t, conn_handle) - 0usize];
};
#[doc = "Get Next Connection Event Counter return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_get_next_conn_event_counter_return_t {
    pub conn_handle: u16,
    pub next_conn_event_counter: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_get_next_conn_event_counter_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_get_next_conn_event_counter_return_t>() - 4usize];
    ["Alignment of sdc_hci_cmd_vs_get_next_conn_event_counter_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_get_next_conn_event_counter_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_get_next_conn_event_counter_return_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_get_next_conn_event_counter_return_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_vs_get_next_conn_event_counter_return_t::next_conn_event_counter"][::core::mem::offset_of!(
        sdc_hci_cmd_vs_get_next_conn_event_counter_return_t,
        next_conn_event_counter
    ) - 2usize];
};
#[doc = "Allow Parallel Connection Establishment command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_allow_parallel_connection_establishments_t {
    pub enable: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_allow_parallel_connection_establishments_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_allow_parallel_connection_establishments_t>() - 1usize];
    ["Alignment of sdc_hci_cmd_vs_allow_parallel_connection_establishments_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_allow_parallel_connection_establishments_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_allow_parallel_connection_establishments_t::enable"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_allow_parallel_connection_establishments_t, enable) - 0usize];
};
#[doc = "Set the minimum value that will be used as maximum Tx octets for ACL connections command\n parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_min_val_of_max_acl_tx_payload_set_t {
    #[doc = "Minimum value of maximum ACL TX payload."]
    pub min_val_of_max_acl_tx_payload: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_min_val_of_max_acl_tx_payload_set_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_min_val_of_max_acl_tx_payload_set_t>() - 1usize];
    ["Alignment of sdc_hci_cmd_vs_min_val_of_max_acl_tx_payload_set_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_min_val_of_max_acl_tx_payload_set_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_min_val_of_max_acl_tx_payload_set_t::min_val_of_max_acl_tx_payload"][::core::mem::offset_of!(
        sdc_hci_cmd_vs_min_val_of_max_acl_tx_payload_set_t,
        min_val_of_max_acl_tx_payload
    ) - 0usize];
};
#[doc = "Iso Read Tx Timestamp command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_iso_read_tx_timestamp_t {
    pub conn_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_iso_read_tx_timestamp_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_iso_read_tx_timestamp_t>() - 2usize];
    ["Alignment of sdc_hci_cmd_vs_iso_read_tx_timestamp_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_iso_read_tx_timestamp_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_iso_read_tx_timestamp_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_iso_read_tx_timestamp_t, conn_handle) - 0usize];
};
#[doc = "Iso Read Tx Timestamp return parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_iso_read_tx_timestamp_return_t {
    pub conn_handle: u16,
    pub packet_sequence_number: u16,
    #[doc = "Synchronization reference of the sent SDU."]
    pub tx_time_stamp: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_iso_read_tx_timestamp_return_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_iso_read_tx_timestamp_return_t>() - 8usize];
    ["Alignment of sdc_hci_cmd_vs_iso_read_tx_timestamp_return_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_iso_read_tx_timestamp_return_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_iso_read_tx_timestamp_return_t::conn_handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_iso_read_tx_timestamp_return_t, conn_handle) - 0usize];
    ["Offset of field: sdc_hci_cmd_vs_iso_read_tx_timestamp_return_t::packet_sequence_number"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_iso_read_tx_timestamp_return_t, packet_sequence_number) - 2usize];
    ["Offset of field: sdc_hci_cmd_vs_iso_read_tx_timestamp_return_t::tx_time_stamp"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_iso_read_tx_timestamp_return_t, tx_time_stamp) - 4usize];
};
#[doc = "Set the default BIG reserved time command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_big_reserved_time_set_t {
    pub reserved_time_us: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_big_reserved_time_set_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_big_reserved_time_set_t>() - 4usize];
    ["Alignment of sdc_hci_cmd_vs_big_reserved_time_set_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_big_reserved_time_set_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_big_reserved_time_set_t::reserved_time_us"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_big_reserved_time_set_t, reserved_time_us) - 0usize];
};
#[doc = "Set the default CIG reserved time command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_cig_reserved_time_set_t {
    pub reserved_time_us: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_cig_reserved_time_set_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_cig_reserved_time_set_t>() - 4usize];
    ["Alignment of sdc_hci_cmd_vs_cig_reserved_time_set_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_cig_reserved_time_set_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_cig_reserved_time_set_t::reserved_time_us"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_cig_reserved_time_set_t, reserved_time_us) - 0usize];
};
#[doc = "Set the CIS subevent length in microseconds command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_cis_subevent_length_set_t {
    #[doc = "The requested CIS subevent length in microseconds."]
    pub cis_subevent_length_us: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_cis_subevent_length_set_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_cis_subevent_length_set_t>() - 4usize];
    ["Alignment of sdc_hci_cmd_vs_cis_subevent_length_set_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_cis_subevent_length_set_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_cis_subevent_length_set_t::cis_subevent_length_us"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_cis_subevent_length_set_t, cis_subevent_length_us) - 0usize];
};
#[doc = "Set the channel map for scanning and initiating. command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_scan_channel_map_set_t {
    #[doc = "This parameter contains 40 1-bit fields. The nth such field (in the range 0 to 39)\n contains the value for the Link Layer channel index n. Set the bit to 1 to enable the\n channel. Only channel index 37, 38 and 39 are supported. The remaining bits shall be\n set to 1."]
    pub channel_map: [u8; 5usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_scan_channel_map_set_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_scan_channel_map_set_t>() - 5usize];
    ["Alignment of sdc_hci_cmd_vs_scan_channel_map_set_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_scan_channel_map_set_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_scan_channel_map_set_t::channel_map"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_scan_channel_map_set_t, channel_map) - 0usize];
};
#[doc = "Scan accept extended advertising packets set command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_scan_accept_ext_adv_packets_set_t {
    #[doc = "Set to 1 to accept or 0 to ignore extended advertising packets."]
    pub accept_ext_adv_packets: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_scan_accept_ext_adv_packets_set_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_scan_accept_ext_adv_packets_set_t>() - 1usize];
    ["Alignment of sdc_hci_cmd_vs_scan_accept_ext_adv_packets_set_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_scan_accept_ext_adv_packets_set_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_scan_accept_ext_adv_packets_set_t::accept_ext_adv_packets"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_scan_accept_ext_adv_packets_set_t, accept_ext_adv_packets) - 0usize];
};
#[doc = "Set priority of a BT role command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_set_role_priority_t {
    #[doc = "Handle type for which to change the priority. See sdc_hci_vs_set_role_priority_handle_type for valid values."]
    pub handle_type: u8,
    #[doc = "Handle of the selected handle_type that identifies the instance to set the priority\n of. This parameter is ignored for scanner and initiator roles."]
    pub handle: u16,
    #[doc = "The new priority for the role. Values from 1 to 5 set the new priority for the role,\n see https://docs.nordicsemi.com/bundle/ncs-\n latest/page/nrfxlib/softdevice_controller/doc/scheduling.html A value of 0xFF resets\n the priority to the default selected by the controller."]
    pub priority: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_set_role_priority_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_set_role_priority_t>() - 4usize];
    ["Alignment of sdc_hci_cmd_vs_set_role_priority_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_set_role_priority_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_set_role_priority_t::handle_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_set_role_priority_t, handle_type) - 0usize];
    ["Offset of field: sdc_hci_cmd_vs_set_role_priority_t::handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_set_role_priority_t, handle) - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_set_role_priority_t::priority"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_set_role_priority_t, priority) - 3usize];
};
#[doc = "Set Event Start Task command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_set_event_start_task_t {
    #[doc = "Selected handle type to set trigger for. See sdc_hci_vs_set_event_start_task_handle_type."]
    pub handle_type: u8,
    #[doc = "The handle to configure the task for. In case sdc_hci_vs_set_event_start_task_handle_type specifies the Scanner or Initiator, this\n parameter is ignored. If the handle_type specifies the Advertiser and legacy\n advertising is used, this parameter is ignored."]
    pub handle: u16,
    #[doc = "Task to trigger. Set this to 0 to disable this feature."]
    pub task_address: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_set_event_start_task_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_set_event_start_task_t>() - 7usize];
    ["Alignment of sdc_hci_cmd_vs_set_event_start_task_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_set_event_start_task_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_set_event_start_task_t::handle_type"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_set_event_start_task_t, handle_type) - 0usize];
    ["Offset of field: sdc_hci_cmd_vs_set_event_start_task_t::handle"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_set_event_start_task_t, handle) - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_set_event_start_task_t::task_address"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_set_event_start_task_t, task_address) - 3usize];
};
#[doc = "Connection Anchor Point Update Event Reports enable command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_conn_anchor_point_update_event_report_enable_t {
    #[doc = "Set to 1 to enable, 0 to disable, all other values are RFU."]
    pub enable: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_conn_anchor_point_update_event_report_enable_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_conn_anchor_point_update_event_report_enable_t>() - 1usize];
    ["Alignment of sdc_hci_cmd_vs_conn_anchor_point_update_event_report_enable_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_conn_anchor_point_update_event_report_enable_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_conn_anchor_point_update_event_report_enable_t::enable"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_conn_anchor_point_update_event_report_enable_t, enable) - 0usize];
};
#[doc = "Enable Periodic Advertising Event Counter Reports command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_enable_periodic_adv_event_counter_reports_t {
    #[doc = "Set to 1 to enable, 0 to disable."]
    pub enable: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_enable_periodic_adv_event_counter_reports_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_enable_periodic_adv_event_counter_reports_t>() - 1usize];
    ["Alignment of sdc_hci_cmd_vs_enable_periodic_adv_event_counter_reports_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_enable_periodic_adv_event_counter_reports_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_enable_periodic_adv_event_counter_reports_t::enable"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_enable_periodic_adv_event_counter_reports_t, enable) - 0usize];
};
#[doc = "Set event length for CS events command parameter(s)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_set_cs_event_length_t {
    #[doc = "Allocated CS event length in microseconds."]
    pub cs_event_length_us: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_hci_cmd_vs_set_cs_event_length_t"]
        [::core::mem::size_of::<sdc_hci_cmd_vs_set_cs_event_length_t>() - 4usize];
    ["Alignment of sdc_hci_cmd_vs_set_cs_event_length_t"]
        [::core::mem::align_of::<sdc_hci_cmd_vs_set_cs_event_length_t>() - 1usize];
    ["Offset of field: sdc_hci_cmd_vs_set_cs_event_length_t::cs_event_length_us"]
        [::core::mem::offset_of!(sdc_hci_cmd_vs_set_cs_event_length_t, cs_event_length_us) - 0usize];
};
unsafe extern "C" {
    #[doc = "HCI_VS_API API\n # /\n/* Zephyr Read Version Information.\n\n Reads the values for the vendor version information for the local Controller.\n\n The Hardware_Platform information defines the hardware manufacturer\n information. The Hardware_Variant is manufacturer specific and defines the\n hardware platform from that manufacturer.\n\n The Firmware_Variant defines the type of firmware. It is possible to provide\n HCI firmware with limited functionality for example for bootloader operation.\n The Firmware_Version and Firmware_Revision define version information of the\n Firmware_Variant that is currently active. The Firmware_Build defines an\n additional counter for incremental builds.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_zephyr_read_version_info(
        p_return: *mut sdc_hci_cmd_vs_zephyr_read_version_info_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "Zephyr Read Supported Commands.\n\n This command reads the list of vendor commands supported for the local Controller.\n\n This command shall return the Supported_Commands configuration parameter. It is\n implied that if a command is listed as supported, the feature underlying that\n command is also supported.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_zephyr_read_supported_commands(
        p_return: *mut sdc_hci_cmd_vs_zephyr_read_supported_commands_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "Zephyr Write BD ADDR.\n\n This command writes the BD_ADDR (Bluetooth public device address) value\n to the volatile memory. The address does not change during an HCI Reset but is\n reset during a System Reset.\n The address can be read out using the Read_BD_ADDR command.\n\n When the Write_BD_ADDR command has completed, a Command Complete event shall\n be generated.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_zephyr_write_bd_addr(p_params: *const sdc_hci_cmd_vs_zephyr_write_bd_addr_t) -> u8;
}
unsafe extern "C" {
    #[doc = "Zephyr Read Static Addresses.\n\n This commands reads the controller specific static addresses.\n\n This command shall return the static addresses programmed by the vendor at\n manufacturing time.\n\n Each returned static address shall confirm to the Static Device Address\n definition. The two most significant bits of the address shall be equal to 1.\n At least one bit of the random part of the address shall be 0. At least one bit\n of the random part of the address shall be 1.\n\n The Identity_Root parameter may be all zeros to indicate no identity root key\n being available for a given static address. The identity root key returned from\n Read_Key_Hierarchy_Roots command shall not be returned from this command.\n\n Note: If no public address is provided and a static address is available, then\n it is recommended to return an identity root key (if available) from this\n command. In case a public address is provided, then it is recommended to use\n the Read_Key_Hierarchy_Roots command to return the identity root key (if only\n one is available).\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_zephyr_read_static_addresses(
        p_return: *mut sdc_hci_cmd_vs_zephyr_read_static_addresses_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "Zephyr Read KEY Hierarchy Roots.\n\n This commands reads the controller specific identify and encryption root keys.\n\n This command shall return the identity root key and encryption root key\n programmed by the vendor at manufacturing time. If a key is set to all zeros,\n then the associated key is not available and it should not be used in the key\n hierarchy.\n\n The identity root key and encryption root key may be used for the controllers\n public device address or a static random address generated by the host. It\n shall not be used for static addresses returned by Read_Static_Addresses\n command that have its dedicated identity root key assigned.\n\n Note: For addresses returned by Read_Static_Addresses with an all zeros\n identity root key, the returned Identity_Root value may be used. It is however\n important that it only gets assigned to a single address (either public or\n static random).\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots(
        p_return: *mut sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "Zephyr Read Chip Temperature.\n\n This commands reads the controller chip temperature.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_zephyr_read_chip_temp(p_return: *mut sdc_hci_cmd_vs_zephyr_read_chip_temp_return_t) -> u8;
}
unsafe extern "C" {
    #[doc = "Zephyr Write Tx Power Level (per Role/Connection).\n\n This command dynamically modifies Bluetooth LE Tx power level at the antenna given a handle and a\n handle type.\n\n The Tx power of the Bluetooth LE radio interface is modified for any low-level link by\n the controller with a high degree of flexibility. The Bluetooth LE link whose power is\n set is identified based on a handle type and handle pair.\n\n The role/state defining input parameter is the Handle_Type, whereas its\n corresponding handle is provided by the Handle input parameter. Note that\n for Advertisements, the Handle input parameter is ignored in the case that\n Advertising Extensions are not configured, whereas Advertising Sets are to be\n identified by their corresponding Handle in case Advertising Extensions are\n enabled.\n\n The desired transmitter power level for the selected link instance is inputted\n as Tx_Power_Level. This value represents the actual power level fed to the antenna.\n When a Front-End Module is used, gain values for the SoC and FEM are calculated\n automatically to guarantee closest possible match to the value requested by the user\n at the RF output. The power setup and control can be performed dynamically\n without the need of restarting the advertiser and scanner role/states. In case\n of connections, the Tx power changes take effect only if the connections are\n in a connected state.\n\n The inputs Handle_Type and Handle are passed through as outputs to aid the\n asynchronous service of the command as well. In addition, the command returns\n also with the Selected_Tx_Power by the controller which addresses and corrects\n the possible mismatches between the desired Tx_Power_Level and the achievable\n Tx powers given each individual controller capabilities.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_zephyr_write_tx_power(
        p_params: *const sdc_hci_cmd_vs_zephyr_write_tx_power_t,
        p_return: *mut sdc_hci_cmd_vs_zephyr_write_tx_power_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "Zephyr Read Tx Power Level (per Role/Connection) Command.\n\n This command reads the BLE Tx power level.\n\n In contrast to the standardized HCI command, i.e. Read_Transmit_Power_Level,\n which returns the transmitted power level only for a specified connection handle,\n this command operates for both connected and unconnected states.\n It gets the BLE Tx power level for any given handle type and handle.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_zephyr_read_tx_power(
        p_params: *const sdc_hci_cmd_vs_zephyr_read_tx_power_t,
        p_return: *mut sdc_hci_cmd_vs_zephyr_read_tx_power_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "Set Low Latency Packet Mode.\n\n This command enables or disables Low Latency Packet Mode support.\n When Low Latency Packet Mode is enabled, it is possible to switch to connection intervals in the\n range 1-7 ms. Switch to short connection intervals by calling sdc_hci_cmd_vs_conn_update().\n\n After HCI Reset, this feature is disabled.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_llpm_mode_set(p_params: *const sdc_hci_cmd_vs_llpm_mode_set_t) -> u8;
}
unsafe extern "C" {
    #[doc = "Connection Update.\n\n This vendor specific command is used instead of HCI_LE_Connection_Update when\n it is desirable to provide Connection Interval in microseconds instead of units.\n See sdc_hci_cmd_le_conn_update for description of behavior.\n\n Event(s) generated (unless masked away):\n When the Controller receives the command, the Controller sends the\n HCI_Command_Status event to the Host. The HCI_VS_Connection_Update_Complete\n event shall be generated after the connection parameters have been applied\n by the Controller or if the command subsequently fails.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_conn_update(p_params: *const sdc_hci_cmd_vs_conn_update_t) -> u8;
}
unsafe extern "C" {
    #[doc = "Enable or Disable Extended Connection Events.\n\n When Extended Connection Events are disabled, the maximum connection event length is set\n by sdc_hci_cmd_vs_event_length_set(). When Extended Connection Events are enabled, the\n controller\n will extend the connection event as much as possible, if:\n - Either of the peers has more data to send.\n See also: Core v5.1, Vol 6, Part B, Section 4.5.6\n - There are no conflicts with other concurrent links.\n\n A connection event can not be extended beyond the connection interval.\n\n The configured value is retained after issuing an HCI Reset command.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_conn_event_extend(p_params: *const sdc_hci_cmd_vs_conn_event_extend_t) -> u8;
}
unsafe extern "C" {
    #[doc = "QoS Connection Event Reports enable.\n\n This vendor specific command is used to enable or disable generation of QoS Connection event\n reports.\n See sdc_hci_subevent_vs_qos_conn_event_report_t. When enabled, one report will be generated\n every connection event.\n\n > **Note:** If the application does not pull a report in time, it will be overwritten.\n\n After HCI Reset, this feature is disabled.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_qos_conn_event_report_enable(
        p_params: *const sdc_hci_cmd_vs_qos_conn_event_report_enable_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "Set event length for ACL connections.\n\n Set the event length for new ACL connections. The event length is the time available for\n transmission and reception in a single connection event.\n\n The maximum data length capabilities will be set based upon this value.\n\n This API must be called before issuing a command to create a connection,\n or before starting a connectable advertiser.\n\n The default event length is 7500 us.\n\n The event length may be set to a value that is shorter than the time needed\n for a single packet pair on a given PHY.\n In that case the controller will reserve time for receiving 27 bytes and transmitting\n the number of bytes configured with sdc_hci_cmd_vs_min_val_of_max_acl_tx_payload_set().\n\n See also sdc_hci_cmd_vs_conn_event_extend().\n See also sdc_hci_cmd_vs_central_acl_event_spacing_set().\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_event_length_set(p_params: *const sdc_hci_cmd_vs_event_length_set_t) -> u8;
}
unsafe extern "C" {
    #[doc = "Set event length for periodic advertisers.\n\n Set the allocated event length for new periodic advertisers.\n The SoftDevice Controller will ensure that the anchor points of periodic advertising events are\n spaced\n event_length_us apart. If the advertiser requires less time to transmit all the data, the\n distance to\n the next scheduling activity will still be equal to the configured event length. If the\n advertiser\n requires more time to transmit all the data, scheduling conflicts may occur.\n\n This API must be called before configuring a periodic advertiser for the event length to be\n applied.\n\n The default event length is 7500 us.\n\n The configured value is retained after issuing an HCI Reset command.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_periodic_adv_event_length_set(
        p_params: *const sdc_hci_cmd_vs_periodic_adv_event_length_set_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "Set peripheral latency mode.\n\n This vendor specific command is used to disable/enable peripheral latency.\n Three modes of disable/enable are supported.\n\n In enable mode, the peripheral will wake up every time it has data to send,\n and/or every peripheral latency number of connection events.\n\n In disable mode, the peripheral will wake up on every connection event\n regardless of the requested peripheral latency. This option consumes the most power.\n\n In wait_for_ack mode, the peripheral will wake up on every connection event if\n it has not received an ACK from the master for at least peripheral latency events.\n This configuration may increase the power consumption in environments with a lot of radio\n activity.\n\n > **Note:** Shall only be called on peripheral links.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_peripheral_latency_mode_set(
        p_params: *const sdc_hci_cmd_vs_peripheral_latency_mode_set_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "Write remote transmit power level.\n\n This command requests adjustment of radio transmit power level for a connected peer device.\n\n When this command is issued, the controller initiates Power Control Request procedure\n (Core_v5.3, Vol 6, Part B, Section 5.1.17) to request the change from the peer. The\n peer responds with the actual transmit power level change and the controller reports\n the change to the host with an event.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Status event shall be generated.\n When the controller has completed the power control request and if the request has resulted\n in a change in the peer's transmit power level, an HCI_LE_Transmit_Power_Reporting event shall\n be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_write_remote_tx_power(p_params: *const sdc_hci_cmd_vs_write_remote_tx_power_t) -> u8;
}
unsafe extern "C" {
    #[doc = "Set advertising randomness.\n\n This vendor specific command is used to change the randomness of advertisers.\n The setting applies to all subsequent advertising events of a given set.\n\n The configured randomness for the very first advertising event is retained after issuing an HCI\n Reset command.\n\n Event(s) generated (unless masked away):\n When the Controller receives the command, the Controller sends the HCI_Command_Complete\n event to the Host.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_set_adv_randomness(p_params: *const sdc_hci_cmd_vs_set_adv_randomness_t) -> u8;
}
unsafe extern "C" {
    #[doc = "Set Compatibility mode for window offset.\n\n This compatibility mode enables interoperability with devices that do not support a value of 0\n for the WinOffset parameter in the Link Layer CONNECT_IND packet.\n This applies to a limited set of legacy peripheral devices from a limited set of vendors.\n Enabling this compatibility mode will only have an effect if the local device will act as a\n central device and initiate a connection to a peripheral device.\n In that case it may lead to the connection creation taking up to one\n connection interval longer to complete for all connections.\n\n The configured value is retained after issuing an HCI Reset command.\n\n By default this mode is disabled.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_compat_mode_window_offset_set(
        p_params: *const sdc_hci_cmd_vs_compat_mode_window_offset_set_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "Enable the Quality of Service (QoS) channel survey module.\n\n This vendor specific command is used to enable or disable the QoS channel survey module.\n\n The QoS channel survey module provides measurements of the energy levels on\n the Bluetooth Low Energy channels. When the module is enabled, sdc_hci_subevent_vs_qos_channel_survey_report_t\n events will periodically report the measured energy levels for each channel.\n\n The measurements are scheduled with low priority.\n\n The QoS channel survey module will attempt to do measurements so that the average interval\n between measurements will be interval_us. However due to low scheduling priority, this may\n not be possible. In that case fewer than expected reports may be given.\n\n In order to use the QoS channel survey module, funcref:sdc_support_qos_channel_survey\n must be called.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_qos_channel_survey_enable(p_params: *const sdc_hci_cmd_vs_qos_channel_survey_enable_t) -> u8;
}
unsafe extern "C" {
    #[doc = "Set LE Power Control Request procedure parameters.\n\n This command sets the parameters used in LE Power Control Request\n procedure by the Link Layer.\n\n beta parameter is used to determine the weight of the previous average of RSSI values.\n A higher value lowers how much the current RSSI weighs into the average, flattening peaks,\n which also means the controller reacts slower on RSSI changes.\n The average RSSI is calculated using an exponential weighted averaging in a\n 12-bit fixed point fraction.\n avg= gamma * avg- 1] + (1 - gamma) * rssiHere, gamma equals beta/4096, and rssiequals the current RSSI.\n For example, for gamma to be 0.25, set the beta parameter in the command to 1024.\n\n Average RSSI and lower_limit parameter are used to calculate APR value the controller sends\n in LL_POWER_CONTROL_RSP.\n\n When auto_enable parameter is set, the controller will keep average RSSI within\n upper_limit] bounds. When the average RSSI goes out of these bounds, the\n controller will autonomously send LL_POWER_CONTROL_REQ requesting to adjust the\n peer's TX power so average RSSI becomes either lower_target_rssi or upper_target_rssi.\n The controller will not send such requests more often than specified by wait_period_ms parameter.\n The wait_period_ms parameter is needed to not repeat send requests for transmit power change\n without the remote having had the chance to react, as well as to avoid a busy controller.\n This value should be set depending on needs.\n\n When apr_enable parameter is set, the controller will adjust local TX power according to\n APR value received from the peer in LL_POWER_CONTROL_RSP and the apr_margin parameter.\n\n When this command is issued, the controller stores the parameters and\n uses them for the subsequent LE Power Control Request procedures across all the connections.\n\n After HCI Reset, all parameters are set to the default values.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_set_power_control_request_params(
        p_params: *const sdc_hci_cmd_vs_set_power_control_request_params_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "Read average RSSI.\n\n This command reads the average Received Signal Strength Indication (RSSI) value\n calculated by LE Power Control.\n\n The average RSSI is calculated as an exponential weighted average according to\n the formula given in sdc_hci_cmd_vs_set_power_control_request_params().\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_read_average_rssi(
        p_params: *const sdc_hci_cmd_vs_read_average_rssi_t,
        p_return: *mut sdc_hci_cmd_vs_read_average_rssi_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "Set Central ACL event spacing.\n\n On the central, sets the time ACL connections are spaced apart, assuming they are\n using the same connection interval.\n\n This API must be called before issuing a command to create a connection.\n\n The default event spacing is 7500 us.\n The configured value is retained after issuing an HCI Reset command.\n\n Note: The time available for transmission and reception is not configured using this API\n\n See also sdc_hci_cmd_vs_event_length_set().\n See also sdc_hci_cmd_vs_conn_event_extend().\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_central_acl_event_spacing_set(
        p_params: *const sdc_hci_cmd_vs_central_acl_event_spacing_set_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "Get Next Connection Event Counter.\n\n This command can be used to fetch the upcoming connection event counter value for Centrals or\n Peripherals.\n\n If conn_handle doesn't match an existing connection, the Unknown Connection Identifier (0x02)\n error code will be returned.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_get_next_conn_event_counter(
        p_params: *const sdc_hci_cmd_vs_get_next_conn_event_counter_t,
        p_return: *mut sdc_hci_cmd_vs_get_next_conn_event_counter_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "Allow Parallel Connection Establishment.\n\n This command enables the controller to accept establishing connections through\n the initiator and a periodic advertiser with responses simultaneously.\n\n When enabled, HCI commands to create connections may then be used to\n connect to a synchronized peer while the initiator is running, or to start\n initiating before a connection establishment to a synchronized device\n has been completed.\n\n After HCI Reset, this feature is disabled.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_allow_parallel_connection_establishments(
        p_params: *const sdc_hci_cmd_vs_allow_parallel_connection_establishments_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "Set the minimum value that will be used as maximum Tx octets for ACL connections.\n\n This command sets the minimum value of maximum ACL payload length that can be sent\n in each packet. If the configured event length is shorter than what is required to\n send a packet pair of 27 bytes in each direction, the controller will use this value to\n determine how much it can reduce the payload size to satisfy the event length requirements.\n LL Control PDUs are not affected by this API.\n\n Together with sdc_hci_cmd_vs_event_length_set(), this API allows the controller to schedule\n ACLs events closer together with other activities.\n\n This API must be called before issuing a command to create a connection,\n or before starting a connectable advertiser.\n\n The default and maximum value of this parameter is 27. The minimum supported value\n of this parameter is 10.\n\n Setting this parameter to a lower value will result in more link layer fragmentation,\n reducing the maximum throughput.\n\n Setting this parameter to a value lower than 27 bytes may result in interoperability\n issues with older Bluetooth products. It is therefore not recommended to use this API\n for applications interacting with devices qualified for Bluetooth Specification 5.1 or\n older.\n\n The configured value is retained after issuing an HCI Reset command.\n\n See also sdc_hci_cmd_vs_event_length_set().\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_min_val_of_max_acl_tx_payload_set(
        p_params: *const sdc_hci_cmd_vs_min_val_of_max_acl_tx_payload_set_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "Iso Read Tx Timestamp.\n\n The controller operates on a timeline that determines when an SDU provided\n by the host is scheduled for transmission. This command is used to return the\n tx_time_stamp and packet_sequence_number that determines where on this timeline\n the previously provided SDU was scheduled. The packet_sequence_number is a\n quantization of the tx_time_stamp. The SDU is provided for transmission on a\n CIS or BIS as identified by the conn_handle parameter on the\n Central or Peripheral.\n\n This command is made to simplify sending SDUs on different ISO streams\n in the same ISO event.\n\n The returned timestamp is set to start of the CIG or BIG event in which\n the first PDU containing the SDU is scheduled for transmission.\n The returned timestamp may be set to a value in the past or into the future\n depending on how the application has previously provided SDUs to the controller.\n\n The returned timestamp can be used to make the application provide SDUs to the\n controller right before they are sent on air. The returned value\n can also be used to synchronize the transmitter and receiver.\n\n The following equations can be used to find the relation between timestamps on\n the transmitter and receiver:\n CIS_reference_anchor_point = tx_time_stamp + CIG_Sync_Delay - CIS_Sync_Delay\n BIG_reference_anchor_point = tx_time_stamp + PTO * ISO_Interval\n See also Core_v6.0, Vol 6, Part G, Section 3.\n\n If the Host issues this command with a connection handle that does not exist,\n or the connection handle is not associated with a CIS or BIS, the Controller\n shall return the error code Unknown Connection Identifier (0x02).\n\n If the Host issues this command on an existing connection handle for a CIS or\n BIS where a ISO data path is not enabled, the Controller shall return the\n error code Command Disallowed (0x0C).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_ISO_TX_Sync command has completed, an\n HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n * `[out]` -p_return Extra return parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_iso_read_tx_timestamp(
        p_params: *const sdc_hci_cmd_vs_iso_read_tx_timestamp_t,
        p_return: *mut sdc_hci_cmd_vs_iso_read_tx_timestamp_return_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "Set the default BIG reserved time.\n\n This vendor specific command changes the time reserved at the end of a BIG event for other roles.\n This applies to all BIGs created after calling this command.\n\n The default value is 1600 us, but can be set to between 0 us and 4,000,000 us.\n The configured value is retained after issuing an HCI Reset command.\n\n If the value is set such that it cannot be satisfied for a given set of BIG parameters, BIG\n creation will fail with error code UNSUPPORTED_FEATURE_OR_PARAMETER_VALUE (0x11).\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_big_reserved_time_set(p_params: *const sdc_hci_cmd_vs_big_reserved_time_set_t) -> u8;
}
unsafe extern "C" {
    #[doc = "Set the default CIG reserved time.\n\n This vendor specific command changes the time reserved each ISO interval for other roles.\n This applies to all CIGs created after calling this command.\n For example, if the reserved time is set to 2.5 ms and the ISO interval is 10 ms,\n the controller may select CIG parameters such that 2.5 ms is reserved for an ACL connection\n and the remaining 7.5 ms is used for the CIG.\n Note, when multiple CIGs are used the user needs to ensure that the initial CIG reserves time\n for the remaining CIGs.\n\n The default value is 1300 us, but can be set to between 0 us and 4,000,000 us.\n The configured value is retained after issuing an HCI Reset command.\n\n If the value is set such that it cannot be satisfied for a given set of CIG parameters, the\n actual\n reserved time may be smaller than the requested value.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_cig_reserved_time_set(p_params: *const sdc_hci_cmd_vs_cig_reserved_time_set_t) -> u8;
}
unsafe extern "C" {
    #[doc = "Set the CIS subevent length in microseconds.\n\n This command sets the subevent length to be used for CISes\n in microseconds.\n If the configured subevent length is too small, the\n HCI command used to configure the CIG will fail.\n If this parameter is set to zero, the subevent length\n is chosen by the controller.\n\n The default value is 0. That is, the minimum required subevent length\n will be used.\n\n This API must be called before creating a CIG.\n\n The configured value is retained after issuing an HCI Reset command.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_cis_subevent_length_set(p_params: *const sdc_hci_cmd_vs_cis_subevent_length_set_t) -> u8;
}
unsafe extern "C" {
    #[doc = "Set the channel map for scanning and initiating.\n\n This command sets the RF channels that should be used for scanning and initiating\n on the primary advertising channels. The channel map will be used for subsequent\n commands to start scanning or to create connections. Scanning and initiating\n that was started before issuing this command is not affected.\n\n The default behavior is to listen on all primary advertising channels.\n The default behavior is restored when issuing the HCI Reset command.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_scan_channel_map_set(p_params: *const sdc_hci_cmd_vs_scan_channel_map_set_t) -> u8;
}
unsafe extern "C" {
    #[doc = "Scan accept extended advertising packets set.\n\n This command enables or disables reception of extended advertising packets\n when extended scanner or extended initiator HCI commands are used.\n\n When reception of extended advertising packets is disabled,\n the scanner may be able to receive more legacy advertising packets.\n Reception of extended advertising packets should only be disabled\n when the application knows it is not interested in reports from extended advertisers.\n\n After HCI Reset, reception of extended advertising packets is enabled.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_scan_accept_ext_adv_packets_set(
        p_params: *const sdc_hci_cmd_vs_scan_accept_ext_adv_packets_set_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "Set priority of a BT role.\n\n This vendor specific command changes the scheduling priority of a role running in the controller.\n\n Note that unless documented otherwise, any non-default priorities are not tested.\n This means that there is no guarantee that the controller works as intended when non-tested\n priorities are used.\n The default values for the priorities of the different roles are listed in\n https://docs.nordicsemi.com/bundle/ncs-\n latest/page/nrfxlib/softdevice_controller/doc/scheduling.html\n\n After HCI Reset, priority is set to the default value.\n\n If the handle is not associated with an instance of the role_id type,\n the error code Unknown Connection Identifier (0x02) is returned.\n\n If the role_id is set to an invalid or unsupported role,\n the error code Invalid HCI Command Parameters (0x12) is returned.\n\n If the priority is set to an invalid or unsupported value,\n the error code Invalid HCI Command Parameters (0x12) is returned.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_set_role_priority(p_params: *const sdc_hci_cmd_vs_set_role_priority_t) -> u8;
}
unsafe extern "C" {
    #[doc = "Set Event Start Task.\n\n When enabled, this feature will trigger the specified peripheral task register right before\n the first radio activity of a timing-event.\n\n For activities with a handle, the task configuration is automatically reset when the\n controller deletes the handle.\n\n If enabling the task and it is already enabled for the given handle and\n handle_type, the controller will return the error code Command Disallowed (0x0C).\n\n If the advertising handle is not currently active, the controller will return the error code\n Unknown Advertising Identifier (0x42).\n\n If the connection handle is not currently active, the controller will return the error code\n Unknown Connection Identifier (0x2).\n\n If the selected handle_type is not supported by this SDC variant, the controller will\n return the error code Unsupported Feature or Parameter Value (0x11).\n\n After HCI Reset, this feature is disabled.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_set_event_start_task(p_params: *const sdc_hci_cmd_vs_set_event_start_task_t) -> u8;
}
unsafe extern "C" {
    #[doc = "Connection Anchor Point Update Event Reports enable.\n\n This vendor specific command is used to enable or disable generation of\n VS_Conn_Anchor_Point_Update_Report events. See sdc_hci_subevent_vs_conn_anchor_point_update_report_t.\n\n When enabled, the controller will start producing reports for all ACL connections whenever\n a connection anchor point is updated. See Core_v5.4, Vol 6, Part B, Section 4.5.1.\n\n This event is generated every connection interval.\n For peripheral connections, the generation of this event is skipped if no packet from the\n central is received.\n\n If the application does not pull a report in time, it will be overwritten.\n\n After HCI Reset, this feature is disabled.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_conn_anchor_point_update_event_report_enable(
        p_params: *const sdc_hci_cmd_vs_conn_anchor_point_update_event_report_enable_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "Enable Periodic Advertising Event Counter Reports.\n\n This command can be used to enable generation\n of sdc_hci_subevent_vs_periodic_adv_event_counter_report_t events.\n\n The event will be generated whenever the controller sends\n the first sync packet in a periodic advertising event.\n\n If the application does not pull a report in time, it will be overwritten.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_enable_periodic_adv_event_counter_reports(
        p_params: *const sdc_hci_cmd_vs_enable_periodic_adv_event_counter_reports_t,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "Set event length for CS events.\n\n Set the event length for CS events.\n\n In case the number of subevents per event is one, the event length the same as\n the subevent length.\n\n In case the number of subevents per event is greater than one, the event length is\n the total expected time occupied by all subevents and the spacing between them, given\n by the formula:\n\n event length = T_SUBEVENT_INTERVAL x (N_SUBEVENTS_PER_EVENT - 1) + T_SUBEVENT_LEN\n\n Some additional margin may also be needed.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n # Arguments\n\n* `[in]` -p_params Input parameters.\n\n # Returns\n\n* `0` - if success.\n Returns value between 0x01-0xFF in case of error.\n See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_set_cs_event_length(p_params: *const sdc_hci_cmd_vs_set_cs_event_length_t) -> u8;
}
#[doc = "Functions used by the SoftDevice Controller to obtain random numbers.\n\n These functions are used for security-related purposes, so they must conform to:\n BLUETOOTH CORE SPECIFICATION Version 5.2 | Vol 2, Part H, Section 2."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_rand_source_t {
    #[doc = "Function used by the controller to obtain random numbers.\n This function must block until length bytes of random numbers were written to p_buff.\n The function will be executed in the same context as mpsl_low_priority_process.\n\n # Arguments\n\n* `[out]` -p_buff The destination buffer for the random numbers\n * `[in]` -length The requested number of random bytes and the maximum length of the destination buffer"]
    pub rand_poll: ::core::option::Option<unsafe extern "C" fn(p_buff: *mut u8, length: u8)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sdc_rand_source_t"][::core::mem::size_of::<sdc_rand_source_t>() - 4usize];
    ["Alignment of sdc_rand_source_t"][::core::mem::align_of::<sdc_rand_source_t>() - 4usize];
    ["Offset of field: sdc_rand_source_t::rand_poll"][::core::mem::offset_of!(sdc_rand_source_t, rand_poll) - 0usize];
};
unsafe extern "C" {
    #[doc = "Pass a source of randomness to the SoftDevice Controller\n\n The SoftDevice Controller will use the function pointers provided in this function call to get random numbers.\n\n # Arguments\n\n* `[in]` -rand_source A table of function pointers to obtain random numbers\n\n # Returns\n\n* `0` - Success"]
    pub fn sdc_rand_source_register(rand_source: *const sdc_rand_source_t) -> i32;
}
#[allow(clippy::identity_op)]
const fn __MEM_ADDITIONAL_LINK_SIZE(tx_size: u32, rx_size: u32, tx_count: u32, rx_count: u32) -> u32 {
  ((tx_count)*((tx_size)+__MEM_TX_BUFFER_OVERHEAD_SIZE)-(SDC_DEFAULT_TX_PACKET_SIZE+__MEM_TX_BUFFER_OVERHEAD_SIZE)+(rx_count)*((rx_size)+__MEM_RX_BUFFER_OVERHEAD_SIZE)-(SDC_DEFAULT_RX_PACKET_SIZE+__MEM_RX_BUFFER_OVERHEAD_SIZE))
}
#[allow(clippy::identity_op)]
const fn SDC_MEM_PER_CENTRAL_LINK(tx_size: u32, rx_size: u32, tx_count: u32, rx_count: u32) -> u32 {
  (__MEM_MINIMAL_CENTRAL_LINK_SIZE+__MEM_ADDITIONAL_LINK_SIZE(tx_size,rx_size,tx_count,rx_count))
}
#[allow(clippy::identity_op)]
const fn SDC_MEM_PER_PERIPHERAL_LINK(tx_size: u32, rx_size: u32, tx_count: u32, rx_count: u32) -> u32 {
  (__MEM_MINIMAL_PERIPHERAL_LINK_SIZE+__MEM_ADDITIONAL_LINK_SIZE(tx_size,rx_size,tx_count,rx_count))
}
#[allow(clippy::identity_op)]
const fn SDC_MEM_LE_POWER_CONTROL(num_links: u32) -> u32 {
  (if (num_links)>0 { (13+(num_links)*115) } else { 0 })
}
#[allow(clippy::identity_op)]
const fn SDC_MEM_SUBRATING(num_links: u32) -> u32 {
  (if (num_links)>0 { (11+(num_links)*63) } else { 0 })
}
#[allow(clippy::identity_op)]
const fn SDC_MEM_SYNC_TRANSFER(num_links: u32) -> u32 {
  (if (num_links)>0 { (13+(num_links)*139) } else { 0 })
}
#[allow(clippy::identity_op)]
const fn SDC_MEM_SCAN(buffer_count: u32) -> u32 {
  (320+(buffer_count)*104)
}
#[allow(clippy::identity_op)]
const fn SDC_MEM_SCAN_EXT(buffer_count: u32) -> u32 {
  (320+(buffer_count)*320)
}
#[allow(clippy::identity_op)]
const fn SDC_MEM_FAL(max_num_entries: u32) -> u32 {
  (if (max_num_entries)>0 { (4+(max_num_entries)*8) } else { 0 })
}
#[allow(clippy::identity_op)]
const fn __MEM_PER_ADV_SET_LOW(max_adv_data: u32) -> u32 {
  ((4864+(max_adv_data)*18)/10)
}
#[allow(clippy::identity_op)]
const fn __MEM_PER_ADV_SET_HIGH(max_adv_data: u32) -> u32 {
  (674+(max_adv_data))
}
#[allow(clippy::identity_op)]
const fn __MEM_PER_PERIODIC_ADV_SET_LOW(max_adv_data: u32) -> u32 {
  ((2704+(max_adv_data)*18)/10)
}
#[allow(clippy::identity_op)]
const fn __MEM_PER_PERIODIC_ADV_SET_HIGH(max_adv_data: u32) -> u32 {
  (458+(max_adv_data))
}
#[allow(clippy::identity_op)]
const fn SDC_MEM_PER_ADV_SET(max_adv_data: u32) -> u32 {
  (if (max_adv_data<255) { (__MEM_PER_ADV_SET_LOW(max_adv_data)) } else { (__MEM_PER_ADV_SET_HIGH(max_adv_data)) })
}
#[allow(clippy::identity_op)]
const fn SDC_MEM_PER_PERIODIC_ADV_SET(max_adv_data: u32) -> u32 {
  (if (max_adv_data<255) { (__MEM_PER_PERIODIC_ADV_SET_LOW(max_adv_data)) } else { (__MEM_PER_PERIODIC_ADV_SET_HIGH(max_adv_data)) })
}
#[allow(clippy::identity_op)]
const fn SDC_MEM_PER_PERIODIC_SYNC(buffer_count: u32) -> u32 {
  (220+(buffer_count)*279)
}
#[allow(clippy::identity_op)]
const fn SDC_MEM_PER_PERIODIC_SYNC_RSP(tx_buffer_count: u32, rx_buffer_count: u32) -> u32 {
  (644+(tx_buffer_count-1)*254+(rx_buffer_count)*278)
}
#[allow(clippy::identity_op)]
const fn SDC_MEM_PERIODIC_ADV_LIST(list_size: u32) -> u32 {
  ((list_size)*8)
}
#[allow(clippy::identity_op)]
const fn __MEM_PER_PERIODIC_ADV_RSP_TX_BUFFER(max_tx_data_size: u32) -> u32 {
  ((max_tx_data_size)+5)
}
#[allow(clippy::identity_op)]
const fn __MEM_PER_ISO_PDU_POOL(count: u32) -> u32 {
  (if (count)>0 { (16+(count)*288) } else { 0 })
}
#[allow(clippy::identity_op)]
const fn SDC_MEM_PER_PERIODIC_ADV_RSP_SET(max_adv_data: u32, tx_buffer_count: u32, rx_buffer_count: u32, max_tx_data_size: u32, failure_reporting_enabled: bool) -> u32 {
  (SDC_MEM_PER_PERIODIC_ADV_SET(max_adv_data)+(if (rx_buffer_count)>0 { __MEM_MINIMAL_PERIODIC_ADV_RSP_SET_SIZE_WITH_RX } else { __MEM_MINIMAL_PERIODIC_ADV_RSP_SET_SIZE_WITHOUT_RX })+(tx_buffer_count)*__MEM_PER_PERIODIC_ADV_RSP_TX_BUFFER(max_tx_data_size)+(rx_buffer_count)*__MEM_PER_PERIODIC_ADV_RSP_RX_BUFFER+(if (failure_reporting_enabled) { __MEM_FOR_PERIODIC_ADV_RSP_FAILURE_REPORTING } else { 0 }))
}
#[allow(clippy::identity_op)]
const fn SDC_MEM_PER_CIG(count: u32) -> u32 {
  (if (count)>0 { (13+(count)*123) } else { 0 })
}
#[allow(clippy::identity_op)]
const fn SDC_MEM_PER_CIS(count: u32) -> u32 {
  (if (count)>0 { (13+(count)*547) } else { 0 })
}
#[allow(clippy::identity_op)]
const fn SDC_MEM_PER_BIG(count: u32) -> u32 {
  (if (count)>0 { (13+(count)*291) } else { 0 })
}
#[allow(clippy::identity_op)]
const fn SDC_MEM_PER_BIS(count: u32) -> u32 {
  (if (count)>0 { (13+(count)*259) } else { 0 })
}
#[allow(clippy::identity_op)]
const fn SDC_MEM_ISO_RX_PDU_POOL_PER_STREAM_SIZE(rx_pdu_buffer_per_stream_count: u32, cis_count: u32, bis_sink_count: u32) -> u32 {
  (__MEM_PER_ISO_PDU_POOL(rx_pdu_buffer_per_stream_count)*((cis_count)+(bis_sink_count)))
}
#[allow(clippy::identity_op)]
const fn SDC_MEM_ISO_RX_SDU_POOL_SIZE(count: u32, size: u32) -> u32 {
  (if (count)>0 { (8+(count)*((size)+13)) } else { 0 })
}
#[allow(clippy::identity_op)]
const fn SDC_MEM_ISO_TX_PDU_POOL_SIZE(tx_pdu_buffer_per_stream_count: u32, cis_count: u32, bis_source_count: u32) -> u32 {
  (if (tx_pdu_buffer_per_stream_count)>0 { __MEM_PER_ISO_PDU_POOL(tx_pdu_buffer_per_stream_count)*((cis_count)+(bis_source_count)) } else { 0 })
}
#[allow(clippy::identity_op)]
const fn SDC_MEM_ISO_TX_SDU_POOL_SIZE(count: u32, size: u32) -> u32 {
  (if (count)>0 { (12+(count)*((size)+49)) } else { 0 })
}
#[allow(clippy::identity_op)]
const fn __MEM_CS_ANTENNA_PATHS(max_antenna_paths_supported: u32) -> u32 {
  (((max_antenna_paths_supported)-1)*1024)
}
#[allow(clippy::identity_op)]
const fn __MEM_CS_STEP_MODE3(step_mode3_supported: bool) -> u32 {
  (if (step_mode3_supported) { 1536 } else { 0 })
}
#[allow(clippy::identity_op)]
const fn SDC_MEM_CS(count: u32, max_antenna_paths_supported: u32, step_mode3_supported: bool) -> u32 {
  (if (count)>0 { (13+(count)*(4203+__MEM_CS_ANTENNA_PATHS(max_antenna_paths_supported)+__MEM_CS_STEP_MODE3(step_mode3_supported))) } else { 0 })
}
#[allow(clippy::identity_op)]
const fn SDC_MEM_CS_SETUP_PHASE_LINKS(count: u32) -> u32 {
  (if (count)>0 { (11+(count)*363) } else { 0 })
}
