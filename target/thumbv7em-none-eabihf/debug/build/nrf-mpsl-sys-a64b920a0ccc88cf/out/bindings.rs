/* automatically generated by rust-bindgen 0.72.1 */

pub const UINT8_MAX: u32 = 255;
pub const NRF_EPERM: u32 = 1;
pub const NRF_ENOENT: u32 = 2;
pub const NRF_EIO: u32 = 5;
pub const NRF_ENOMEM: u32 = 12;
pub const NRF_EACCES: u32 = 13;
pub const NRF_EFAULT: u32 = 14;
pub const NRF_EINVAL: u32 = 22;
pub const NRF_EAGAIN: u32 = 35;
pub const NRF_EPROTOTYPE: u32 = 41;
pub const NRF_ENOPROTOOPT: u32 = 42;
pub const NRF_EPROTONOSUPPORT: u32 = 43;
pub const NRF_ESOCKTNOSUPPORT: u32 = 44;
pub const NRF_EOPNOTSUPP: u32 = 45;
pub const NRF_EAFNOSUPPORT: u32 = 47;
pub const NRF_EADDRINUSE: u32 = 48;
pub const NRF_ENETDOWN: u32 = 50;
pub const NRF_ENETUNREACH: u32 = 51;
pub const NRF_ECONNRESET: u32 = 54;
pub const NRF_EISCONN: u32 = 56;
pub const NRF_ENOTCONN: u32 = 57;
pub const NRF_ETIMEDOUT: u32 = 60;
pub const NRF_ENOBUFS: u32 = 105;
pub const NRF_EHOSTDOWN: u32 = 112;
pub const NRF_EINPROGRESS: u32 = 115;
pub const NRF_ECANCELED: u32 = 125;
pub const NRF_ENOKEY: u32 = 126;
pub const NRF_EKEYEXPIRED: u32 = 127;
pub const NRF_EKEYREVOKED: u32 = 128;
pub const NRF_EKEYREJECTED: u32 = 129;
pub const MPSL_RECOMMENDED_RC_CTIV: u32 = 16;
pub const MPSL_RECOMMENDED_RC_TEMP_CTIV: u32 = 2;
pub const MPSL_DEFAULT_CLOCK_ACCURACY_PPM: u32 = 250;
pub const MPSL_WORST_CLOCK_ACCURACY_PPM: u32 = 500;
pub const MPSL_DEFAULT_SKIP_WAIT_LFCLK_STARTED: u32 = 0;
pub const MPSL_RESERVED_PPI_CHANNELS: u32 = 3221749760;
pub const MPSL_PPI_CHANNELS_USED_MASK: u32 = 3221749760;
pub const MPSL_HIGH_IRQ_PRIORITY: u32 = 0;
pub const MPSL_BUILD_REVISION_SIZE: u32 = 20;
pub const MPSL_ECB_KEY_LENGTH: u32 = 16;
pub const MPSL_ECB_CLEARTEXT_LENGTH: u32 = 16;
pub const MPSL_ECB_CIPHERTEXT_LENGTH: u32 = 16;
pub const MPSL_ECB_NO_FLAGS: u32 = 0;
pub const MPSL_ECB_INPUT_LE: u32 = 1;
pub const MPSL_ECB_OUTPUT_LE: u32 = 2;
pub const MPSL_ECB_CLEARTEXT_IN_LOCAL_RAM: u32 = 4;
pub const MPSL_TIMESLOT_LENGTH_MIN_US: u32 = 100;
pub const MPSL_TIMESLOT_LENGTH_MAX_US: u32 = 100000;
pub const MPSL_TIMESLOT_DISTANCE_MAX_US: u32 = 255999999;
pub const MPSL_TIMESLOT_EARLIEST_TIMEOUT_MAX_US: u32 = 255999999;
pub const MPSL_TIMESLOT_START_JITTER_US: u32 = 1;
pub const MPSL_TIMESLOT_EXTENSION_TIME_MIN_US: u32 = 200;
pub const MPSL_TIMESLOT_EXTENSION_PROCESSING_TIME_MAX_US: u32 = 25;
pub const MPSL_TIMESLOT_EXTENSION_MARGIN_MIN_US: u32 = 87;
pub const MPSL_TIMESLOT_CONTEXT_SIZE: u32 = 48;
pub const MPSL_TIMESLOT_CONTEXT_COUNT_MAX: u32 = 8;
pub const MPSL_TOTAL_NUM_OF_BLE_CHANNELS: u32 = 40;
pub const MPSL_TOTAL_NUM_OF_802154_CHANNELS: u32 = 16;
#[doc = "Configuration_of_CMSIS\n # "]
pub type IRQn_Type = ::core::ffi::c_int;
#[doc = "< LFCLK RC oscillator."]
pub const MPSL_CLOCK_LF_SRC_RC: MPSL_CLOCK_LF_SRC = 0;
#[doc = "< LFCLK crystal oscillator."]
pub const MPSL_CLOCK_LF_SRC_XTAL: MPSL_CLOCK_LF_SRC = 1;
#[doc = "< LFCLK Synthesized from HFCLK."]
pub const MPSL_CLOCK_LF_SRC_SYNTH: MPSL_CLOCK_LF_SRC = 2;
#[doc = "< Apply external low swing signal to XL1, ground XL2.\nThis option is not available on nRF53."]
pub const MPSL_CLOCK_LF_SRC_EXT_LOW_SWING: MPSL_CLOCK_LF_SRC = 3;
#[doc = "< Apply external full swing signal to XL1,\nleave XL2 grounded or unconnected.\nThis option is not available on nRF53."]
pub const MPSL_CLOCK_LF_SRC_EXT_FULL_SWING: MPSL_CLOCK_LF_SRC = 4;
#[doc = "Low frequency clock source."]
pub type MPSL_CLOCK_LF_SRC = ::core::ffi::c_uint;
#[doc = "Type representing LFCLK oscillator source."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpsl_clock_lfclk_cfg_t {
    #[doc = "LF oscillator clock source, see MPSL_CLOCK_LF_SRC."]
    pub source: u8,
    #[doc = "Only for ::MPSL_CLOCK_LF_SRC_RC.\n Calibration timer interval in 1/4 second units.\n\n > **Note:** To avoid excessive clock drift, 0.5 degrees Celsius is\n the maximum temperature change allowed in one calibration timer interval.\n The interval should be selected to ensure this.\n\n > **Note:** Must be 0 if source is not ::MPSL_CLOCK_LF_SRC_RC."]
    pub rc_ctiv: u8,
    #[doc = "Only for ::MPSL_CLOCK_LF_SRC_RC.\n How often (in number of calibration intervals) the RC oscillator shall be\n calibrated if the temperature hasn't changed.\n * 0: Always calibrate even if the temperature hasn't changed.\n * 1-33: Check the temperature and only calibrate if it has changed,\n however calibration will take place every rc_temp_ctiv intervals in any case.\n\n > **Note:** Must be 0 if source is not ::MPSL_CLOCK_LF_SRC_RC.\n\n > **Note:** The application must ensure calibration at least\n once every 8 seconds to ensure +/-500 ppm clock stability.\n The recommended configuration for ::MPSL_CLOCK_LF_SRC_RC\n is given by MPSL_RECOMMENDED_RC_CTIV and\n MPSL_RECOMMENDED_RC_TEMP_CTIV.\n This sets the calibration interval to 4 seconds\n and guarantees clock calibration every second calibration interval.\n That is, the clock will be calibrated every 8 seconds.\n If the temperature changes more than 0.5 every 4 seconds,\n the clock will be calibrated every 4 seconds.\n See the Product Specification for more information."]
    pub rc_temp_ctiv: u8,
    #[doc = "Accuracy of the low frequency clock in parts per million (ppm).\n Default value is MPSL_DEFAULT_CLOCK_ACCURACY_PPM."]
    pub accuracy_ppm: u16,
    #[doc = "Determines whether MPSL waits for the low frequency clock to start\n during initialization or not.\n If it is set to true, MPSL will wait for the low frequency clock later,\n before the low frequency clock is used for the first time.\n Default value is MPSL_DEFAULT_SKIP_WAIT_LFCLK_STARTED.\n\n > **Note:** If this option is set to true and the application writes to\n NRF_CLOCK->TASKS_LFCLKSTART before mpsl_init() is called,\n the application shall either:\n - Write to NRF_CLOCK->TASKS_LFCLKSTOP.\n - Keep NRF_CLOCK->EVENTS_LFCLKSTARTED untouched."]
    pub skip_wait_lfclk_started: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mpsl_clock_lfclk_cfg_t"][::core::mem::size_of::<mpsl_clock_lfclk_cfg_t>() - 8usize];
    ["Alignment of mpsl_clock_lfclk_cfg_t"][::core::mem::align_of::<mpsl_clock_lfclk_cfg_t>() - 2usize];
    ["Offset of field: mpsl_clock_lfclk_cfg_t::source"]
        [::core::mem::offset_of!(mpsl_clock_lfclk_cfg_t, source) - 0usize];
    ["Offset of field: mpsl_clock_lfclk_cfg_t::rc_ctiv"]
        [::core::mem::offset_of!(mpsl_clock_lfclk_cfg_t, rc_ctiv) - 1usize];
    ["Offset of field: mpsl_clock_lfclk_cfg_t::rc_temp_ctiv"]
        [::core::mem::offset_of!(mpsl_clock_lfclk_cfg_t, rc_temp_ctiv) - 2usize];
    ["Offset of field: mpsl_clock_lfclk_cfg_t::accuracy_ppm"]
        [::core::mem::offset_of!(mpsl_clock_lfclk_cfg_t, accuracy_ppm) - 4usize];
    ["Offset of field: mpsl_clock_lfclk_cfg_t::skip_wait_lfclk_started"]
        [::core::mem::offset_of!(mpsl_clock_lfclk_cfg_t, skip_wait_lfclk_started) - 6usize];
};
pub const MPSL_CLOCK_HF_LATENCY_BEST: mpsl_clock_hfclk_latency_config_t = 396;
pub const MPSL_CLOCK_HF_LATENCY_TYPICAL: mpsl_clock_hfclk_latency_config_t = 854;
pub const MPSL_CLOCK_HF_LATENCY_WORST_CASE: mpsl_clock_hfclk_latency_config_t = 1400;
pub type mpsl_clock_hfclk_latency_config_t = ::core::ffi::c_uint;
pub const MPSL_CLOCK_HF_SRC_XO: mpsl_clock_hfclk_src_t = 0;
pub const MPSL_CLOCK_HF_SRC_MAX: mpsl_clock_hfclk_src_t = 2;
#[doc = "Supported high frequency clock sources."]
pub type mpsl_clock_hfclk_src_t = ::core::ffi::c_uint;
#[doc = "HFCLK has been started.\n\n > **Note:** On nRF54L series SoCs the event is returned when the clock\n has started and is stable (EVENT_XOTUNED has occurred)."]
pub const MPSL_CLOCK_EVT_HFCLK_STARTED: mpsl_clock_evt_type_t = 0;
pub const MPSL_CLOCK_EVT_MAX: mpsl_clock_evt_type_t = 3;
#[doc = "Event types returned by the hfclk callback handler."]
pub type mpsl_clock_evt_type_t = ::core::ffi::c_uint;
#[doc = "High frequency clock callback.\n\n This callback will be called when the high frequency clock is started.\n It will be executed in the same execution priority as mpsl_low_priority_process."]
pub type mpsl_clock_hfclk_callback_t = ::core::option::Option<unsafe extern "C" fn()>;
unsafe extern "C" {
    #[doc = "Request the high frequency crystal oscillator.\n\n > **Deprecated** Use ::mpsl_clock_hfclk_src_request instead. This function will be removed in a future release.\n\n Will start the high frequency crystal oscillator, the startup time of the crystal varies\n and the ::mpsl_clock_hfclk_is_running function can be polled to check if it has started.\n\n [`mpsl_clock_hfclk_is_running`]\n [`mpsl_clock_hfclk_release`]\n\n > **Note:** Don't use this API if the integration layer of MPSL provides a driver that uses this function.\n This is the case for applications in the nRF Connect SDK where there is a clock control driver\n with a corresponding on/off manager.\n\n > **Note:** This API is not supported when an external clock driver has been registered.\n See also mpsl_clock_ctrl_source_register().\n\n # Arguments\n\n* `[in]` -hfclk_started_callback Function to be called when the high frequency clock is started.\n On nRF54L series SoCs the callback is called when the clock\n has started and is stable (EVENT_XOTUNED has occurred).\n The callback will be executed in the context as\n mpsl_low_priority_process.\n # Returns\n\n* `0` - Success"]
    pub fn mpsl_clock_hfclk_request(hfclk_started_callback: mpsl_clock_hfclk_callback_t) -> i32;
}
unsafe extern "C" {
    #[doc = "Releases the high frequency crystal oscillator.\n\n > **Deprecated** Use ::mpsl_clock_hfclk_src_release instead. This function will be removed in a future release.\n\n Indicates that the high frequency crystal oscillator is not needed by the application.\n MPSL may continue to use the high frequency clock if it is requested by protocol stacks.\n MPSL will automatically turn it off when it is no longer needed.\n\n [`mpsl_clock_hfclk_is_running`]\n [`mpsl_clock_hfclk_request`]\n\n > **Note:** Don't use this API if the integration layer of MPSL provides a driver that uses this function.\n This is the case for applications in the nRF Connect SDK where there is a clock control driver\n with a corresponding on/off manager.\n\n > **Note:** This API is not supported when an external clock driver has been registered.\n See also mpsl_clock_ctrl_source_register().\n\n # Returns\n\n* `0` - Success"]
    pub fn mpsl_clock_hfclk_release() -> i32;
}
unsafe extern "C" {
    #[doc = "Checks if the high frequency crystal oscillator is running.\n\n > **Deprecated** Use ::mpsl_clock_hfclk_src_is_running instead. This function will be removed in a future release.\n\n [`mpsl_clock_hfclk_request`]\n [`mpsl_clock_hfclk_release`]\n\n > **Note:** This API is not supported when an external clock driver has been registered.\n See also mpsl_clock_ctrl_source_register().\n\n # Arguments\n\n* `[out]` -p_is_running 1 if the external crystal oscillator is running, 0 if not.\n\n # Returns\n\n* `0` - Success"]
    pub fn mpsl_clock_hfclk_is_running(p_is_running: *mut u32) -> i32;
}
unsafe extern "C" {
    #[doc = "Informs MPSL about the actual ramp-up time of the high-frequency crystal oscillator.\n\n > **Note:** Using a value smaller than the actual ramp-up time needed will cause asserts.\n\n > **Note:** This API is not supported when an external clock driver has been registered.\n See also mpsl_clock_ctrl_source_register().\n\n # Arguments\n\n* `[in]` -hfclk_rampup_time_us Ramp-up time of the high-frequency oscillator, in microseconds. See mpsl_clock_hfclk_latency_config_t for recommended values.\n\n # Returns\n\n* `0` - Success"]
    pub fn mpsl_clock_hfclk_latency_set(hfclk_rampup_time_us: u16) -> i32;
}
unsafe extern "C" {
    #[doc = "Trigger a task upon start of the RTC.\n\n MPSL will trigger the task at the same time as the RTC is started.\n\n The function is supported only for nRF52 and nRF53 series.\n\n > **Note:** This API is not supported when an external clock driver has been registered.\n See also mpsl_clock_ctrl_source_register().\n\n # Arguments\n\n* `[in]` -task_address The task address to be triggered"]
    pub fn mpsl_clock_task_trigger_on_rtc_start_set(task_address: u32);
}
#[doc = "High frequency clock callback.\n\n This callback will be called when the high frequency clock is started.\n It will be executed in the same execution priority as mpsl_low_priority_process.\n\n For list of event types that can be provided to this callback, see mpsl_clock_evt_type_t.\n\n # Arguments\n\n* `[in]` -evt_type The event type that occurred."]
pub type mpsl_clock_hfclk_request_callback_t =
    ::core::option::Option<unsafe extern "C" fn(evt_type: mpsl_clock_evt_type_t)>;
unsafe extern "C" {
    #[doc = "Request a high frequency clock with a given source.\n\n Will start the high frequency clock with a given source, the startup time of the clock varies\n and the ::mpsl_clock_hfclk_src_is_running function can be polled to check if it has started.\n\n > **Note:** Don't use this API if the integration layer of MPSL provides a driver that uses this function.\n This is the case for applications in the nRF Connect SDK where there is a clock control driver\n with a corresponding on/off manager.\n\n > **Note:** This API is not supported when an external clock driver has been registered.\n See also mpsl_clock_ctrl_source_register().\n\n [`mpsl_clock_hfclk_src_is_running`]\n [`mpsl_clock_hfclk_src_release`]\n\n # Arguments\n\n* `[in]` -src The high frequency clock source requested.\n * `[in]` -hfclk_started_callback The callback to be called when the high frequency clock is started.\n If the function is called multiple times before the clock is started,\n the callback will be superseded by the last callback.\n # Returns\n\n* `0` - Success, negative value in case of failure.\n\n > **Note:** On nRF54L series SoCs the callback is called when the clock\n has started and is stable (EVENT_XOTUNED has occurred).\n The callback will be executed in the context as\n mpsl_low_priority_process."]
    pub fn mpsl_clock_hfclk_src_request(
        src: mpsl_clock_hfclk_src_t,
        hfclk_started_callback: mpsl_clock_hfclk_request_callback_t,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = "Releases a high frequency clock for a given source.\n\n Indicates that the high frequency clock for a given source is not needed by the application.\n MPSL may continue to use the high frequency clock if it is a source requested by protocol stacks.\n MPSL will automatically turn it off when it is no longer needed.\n\n [`mpsl_clock_hfclk_src_is_running`]\n [`mpsl_clock_hfclk_src_request`]\n\n > **Note:** Don't use this API if the integration layer of MPSL provides a driver that uses this function.\n This is the case for applications in the nRF Connect SDK where there is a clock control driver\n with a corresponding on/off manager.\n\n > **Note:** This API is not supported when an external clock driver has been registered.\n\n # Arguments\n\n* `[in]` -src The high frequency clock source to release.\n # Returns\n\n* `0` - Success"]
    pub fn mpsl_clock_hfclk_src_release(src: mpsl_clock_hfclk_src_t) -> i32;
}
unsafe extern "C" {
    #[doc = "Checks if the high frequency clock for a given source is running.\n\n [`mpsl_clock_hfclk_src_request`]\n [`mpsl_clock_hfclk_src_release`]\n\n > **Note:** This API is not supported when an external clock driver has been registered.\n See also mpsl_clock_ctrl_source_register().\n\n # Arguments\n\n* `[in]` -src The high frequency clock source to check.\n * `[out]` -p_is_running 1 if the high frequency clock is running, 0 if not.\n\n # Returns\n\n* `0` - Success"]
    pub fn mpsl_clock_hfclk_src_is_running(src: mpsl_clock_hfclk_src_t, p_is_running: *mut u32) -> i32;
}
#[doc = "Type representing LFCLK clock handling external API that is expected by MPSL to be\n delivered on init."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpsl_clock_lfclk_ctrl_source_t {
    #[doc = "Pointer to function that waits for LFCLK to be started\n\n This API will be called from the same execution context as mpsl_low_priority_process.\n\n The pointer is mandatory for all supported platforms.\n\n # Returns\n\nNon-negative value in case of success. Negative value in case of failure."]
    pub lfclk_wait: ::core::option::Option<unsafe extern "C" fn() -> i32>,
    #[doc = "Pointer to function that triggers LFCLK callibration start\n\n The function may used from high priority or low priority execution context.\n\n The pointer is mandatory for nRF52, nRF53 series."]
    pub lfclk_calibration_start: ::core::option::Option<unsafe extern "C" fn()>,
    #[doc = "Pointer to function that checks if LFCLK callibration is enabled\n\n The function may used from high priority or low priority execution context.\n\n The pointer is mandatory for nRF52 series.\n\n # Returns\n\ntrue if calibration is enabled, false otherwise."]
    pub lfclk_calibration_is_enabled: ::core::option::Option<unsafe extern "C" fn() -> bool>,
    #[doc = "Pointer to function that requests LFCLK\n\n This API will be called from the same execution context as mpsl_init()\n\n The pointer is mandatory for all supported platforms.\n\n # Returns\n\nNon-negative value in case of success. Negative value in case of failure."]
    pub lfclk_request: ::core::option::Option<unsafe extern "C" fn() -> i32>,
    #[doc = "Pointer to function that releases LFCLK\n\n This API will be called from the same execution context as mpsl_uninit()\n\n The pointer is mandatory for all supported platforms.\n\n # Returns\n\nNon-negative value in case of success. Negative value in case of failure."]
    pub lfclk_release: ::core::option::Option<unsafe extern "C" fn() -> i32>,
    #[doc = "Value of available LFCLK accuracy\n\n The value is mandatory for all supported platforms."]
    pub accuracy_ppm: u16,
    #[doc = "Determines whether MPSL waits for the low frequency clock to start during initialization or not.\n If it is set to true, MPSL will wait for the low frequency clock later, before the low frequency\n clock is used for the first time.\n\n > **Note:** For nRF54h SoC series the MPSL always waits for LFCLK in mpsl_init(). Blocking wait at\n later stage may prevent Radio core to get notification from system controller about LFCLK\n being ready."]
    pub skip_wait_lfclk_started: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mpsl_clock_lfclk_ctrl_source_t"][::core::mem::size_of::<mpsl_clock_lfclk_ctrl_source_t>() - 24usize];
    ["Alignment of mpsl_clock_lfclk_ctrl_source_t"][::core::mem::align_of::<mpsl_clock_lfclk_ctrl_source_t>() - 4usize];
    ["Offset of field: mpsl_clock_lfclk_ctrl_source_t::lfclk_wait"]
        [::core::mem::offset_of!(mpsl_clock_lfclk_ctrl_source_t, lfclk_wait) - 0usize];
    ["Offset of field: mpsl_clock_lfclk_ctrl_source_t::lfclk_calibration_start"]
        [::core::mem::offset_of!(mpsl_clock_lfclk_ctrl_source_t, lfclk_calibration_start) - 4usize];
    ["Offset of field: mpsl_clock_lfclk_ctrl_source_t::lfclk_calibration_is_enabled"]
        [::core::mem::offset_of!(mpsl_clock_lfclk_ctrl_source_t, lfclk_calibration_is_enabled) - 8usize];
    ["Offset of field: mpsl_clock_lfclk_ctrl_source_t::lfclk_request"]
        [::core::mem::offset_of!(mpsl_clock_lfclk_ctrl_source_t, lfclk_request) - 12usize];
    ["Offset of field: mpsl_clock_lfclk_ctrl_source_t::lfclk_release"]
        [::core::mem::offset_of!(mpsl_clock_lfclk_ctrl_source_t, lfclk_release) - 16usize];
    ["Offset of field: mpsl_clock_lfclk_ctrl_source_t::accuracy_ppm"]
        [::core::mem::offset_of!(mpsl_clock_lfclk_ctrl_source_t, accuracy_ppm) - 20usize];
    ["Offset of field: mpsl_clock_lfclk_ctrl_source_t::skip_wait_lfclk_started"]
        [::core::mem::offset_of!(mpsl_clock_lfclk_ctrl_source_t, skip_wait_lfclk_started) - 22usize];
};
#[doc = "Type representing HFCLK clock handling external API that is expected by MPSL to be\n delivered on init."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpsl_clock_hfclk_ctrl_source_t {
    #[doc = "Pointer to function that puts HFCLK request\n\n The function is used from high priority context.\n\n The pointer is mandatory for all supported platforms."]
    pub hfclk_request: ::core::option::Option<unsafe extern "C" fn()>,
    #[doc = "Pointer to function that releases HFCLK request\n\n The function is used from high priority context.\n\n The pointer is mandatory for all supported platforms."]
    pub hfclk_release: ::core::option::Option<unsafe extern "C" fn()>,
    #[doc = "Pointer to function that checks if HFCLK is running\n\n The function is used from high priority context.\n\n The pointer is mandatory for all supported platforms.\n\n # Returns\n\ntrue if HFCLK is running, false otherwise"]
    pub hfclk_is_running: ::core::option::Option<unsafe extern "C" fn() -> bool>,
    #[doc = "Value of a HFXO startup time.\n\n The value is mandatory for all supported platforms."]
    pub startup_time_us: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mpsl_clock_hfclk_ctrl_source_t"][::core::mem::size_of::<mpsl_clock_hfclk_ctrl_source_t>() - 16usize];
    ["Alignment of mpsl_clock_hfclk_ctrl_source_t"][::core::mem::align_of::<mpsl_clock_hfclk_ctrl_source_t>() - 4usize];
    ["Offset of field: mpsl_clock_hfclk_ctrl_source_t::hfclk_request"]
        [::core::mem::offset_of!(mpsl_clock_hfclk_ctrl_source_t, hfclk_request) - 0usize];
    ["Offset of field: mpsl_clock_hfclk_ctrl_source_t::hfclk_release"]
        [::core::mem::offset_of!(mpsl_clock_hfclk_ctrl_source_t, hfclk_release) - 4usize];
    ["Offset of field: mpsl_clock_hfclk_ctrl_source_t::hfclk_is_running"]
        [::core::mem::offset_of!(mpsl_clock_hfclk_ctrl_source_t, hfclk_is_running) - 8usize];
    ["Offset of field: mpsl_clock_hfclk_ctrl_source_t::startup_time_us"]
        [::core::mem::offset_of!(mpsl_clock_hfclk_ctrl_source_t, startup_time_us) - 12usize];
};
unsafe extern "C" {
    #[doc = "Register an external clock driver.\n\n When this API is called, MPSL will use an external clock driver instead of the\n built-in clock driver.\n\n > **Note:** The API must be called before mpsl_init() to enable MPSL use external clock driver.\n\n The API is supported for nRF54h series. It is experimental for nRF52, nRF53 series.\n\n # Arguments\n\n* `[in]` -p_lfclk_ctrl_source A pointer to struct holding the API to LFCLK control.\n * `[in]` -p_hfclk_ctrl_source A pointer to struct holding the API to HFCLK control.\n\n > **Note:** Any of the clock control pointers can't be NULL. In such case the function\n return -NRF_EINVAL.\n\n # Returns\n\n* `0` - Clock control API is successfully registered.\n * `-NRF_EPERM` - Clock control API is already initialized.\n * `-NRF_EINVAL` - Invalid parameters supplied."]
    pub fn mpsl_clock_ctrl_source_register(
        p_lfclk_ctrl_source: *const mpsl_clock_lfclk_ctrl_source_t,
        p_hfclk_ctrl_source: *const mpsl_clock_hfclk_ctrl_source_t,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = "Unregisters external clock driver from MPSL.\n\n The function shall not be called when MPSL is initialized.\n\n > **Note:** The API must be called after the mpsl_uninit() to disable MPSL use external clock driver.\n\n The API is supported for nRF54h series. It is experimental for nRF52, nRF53 series.\n\n # Returns\n\n* `0` - Clock control API is successfully unregistered.\n * `-NRF_EPERM` - Clock control module is still initialized."]
    pub fn mpsl_clock_ctrl_source_unregister() -> i32;
}
#[doc = "Function prototype for the assert handler.\n\n > **Note:** If an internal assert occurs this function is called. It is supposed to log the assert and stop execution.\n\n # Arguments\n\n* `[in]` -file The filename where the assertion occurred.\n * `[in]` -line The line number where the assertion occurred."]
pub type mpsl_assert_handler_t =
    ::core::option::Option<unsafe extern "C" fn(file: *const ::core::ffi::c_char, line: u32)>;
unsafe extern "C" {
    #[doc = "MPSL initialization\n\n # Arguments\n\n* `[in]` -p_clock_config Clock configuration.\nIf NULL the LF clock will be configured as an RC source with rc_ctiv =\nMPSL_RECOMMENDED_RC_CTIV, .rc_temp_ctiv =\nMPSL_RECOMMENDED_RC_TEMP_CTIV, and .accuracy_ppm = MPSL_DEFAULT_CLOCK_ACCURACY_PPM.\nThe parameter is not used when external clock driver is registered mpsl_clock_ctrl_source_register().\n * `[in]` -low_prio_irq IRQ to pend when low priority processing should be executed. The application\n shall call mpsl_low_priority_process after this IRQ has occurred.\n * `[in]` -p_assert_handler Pointer to MPSL assert handler.\n\n > **Note:** If `CONFIG_SYSTEM_CLOCK_NO_WAIT` is set to 0,\n never modify the SEVONPEND flag in the SCR register,\n while this function is executing.\n Doing so might lead to a deadlock.\n\n > **Note:** For nRF54h SoC series the function always waits for LFCLK to be ready. The LFCLK is handled by system controller\n so response must arrive from other domain. That shall be done in non-blocking context. To do not change\n requirements for other MPSL APIs delayed wait for LFCLK is not allowed for the nRF54h SoC series.\n\n > **Note:** If only Front End Module functionality is needed, mpsl_fem_init can be called instead.\n\n # Returns\n\n* `0` - MPSL is successfully initialized.\n * `-NRF_EPERM` - MPSL is already initialized.\n * `-NRF_EINVAL` - Invalid parameters supplied."]
    pub fn mpsl_init(
        p_clock_config: *const mpsl_clock_lfclk_cfg_t,
        low_prio_irq: IRQn_Type,
        p_assert_handler: mpsl_assert_handler_t,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = "Uninitialize MPSL. Stops clocks and scheduler. This will release all peripherals and\n reduce power usage.\n\n > **Note:** This function assumes no protocol stacks are running, and no timeslots are requested.\n All initialized protocol stacks need to be stopped before calling this function.\n Failing to do so will lead to undefined behavior."]
    pub fn mpsl_uninit();
}
unsafe extern "C" {
    #[doc = "Returns true if MPSL is already initialized, false otherwise.\n\n # Returns\n\nTrue if initialized, false if not."]
    pub fn mpsl_is_initialized() -> bool;
}
unsafe extern "C" {
    #[doc = "Obtain build revision\n\n The application must provide a buffer that is at least MPSL_BUILD_REVISION_SIZE\n bytes long. MPSL will copy the build revision to the provided buffer.\n\n # Arguments\n\n* `[in,out]` -p_build_revision Build revision.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EINVAL` - Invalid argument provided"]
    pub fn mpsl_build_revision_get(p_build_revision: *mut u8) -> i32;
}
unsafe extern "C" {
    #[doc = "RADIO interrupt handler\n\n > **Note:** This handler should be placed in the interrupt vector table.\n The interrupt priority level should be priority 0."]
    pub fn MPSL_IRQ_RADIO_Handler();
}
unsafe extern "C" {
    #[doc = "RTC0 interrupt handler\n\n For nRF52 and nRF53 series the RTC timer is NRF_RTC0.\n For nRF54 series devices, the RTC timer corresponds to NRF_GRTC.\n\n > **Note:** This handler should be placed in the interrupt vector table.\n The interrupt priority level should be priority 0"]
    pub fn MPSL_IRQ_RTC0_Handler();
}
unsafe extern "C" {
    #[doc = "TIMER0 interrupt handler.\n\n The timer being used is defined by MPSL_TIMER0.\n\n > **Note:** This handler should be placed in the interrupt vector table.\n The interrupt priority level should be priority 0"]
    pub fn MPSL_IRQ_TIMER0_Handler();
}
unsafe extern "C" {
    #[doc = "POWER_CLOCK interrupt handler\n\n > **Note:** This handler should be placed in the interrupt vector table.\n The interrupt priority level should be lower than priority 0."]
    pub fn MPSL_IRQ_CLOCK_Handler();
}
unsafe extern "C" {
    #[doc = "MPSL low priority processing handler.\n\n > **Note:** This handler should be called when MPSL signals low priority processing should be executed\n (via low_prio_irq provided to mpsl_init) within reasonable time (a at least a few\n 100 ms). The caller is responsible to ensure this function is not called concurrently with\n any other low priority MPSL API functions, for more information see thread safety in the\n MPSL documentation."]
    pub fn mpsl_low_priority_process();
}
unsafe extern "C" {
    #[doc = "Application needs to call this when calibration shall occur.\n\n In the nRF Connect SDK, it is designed to be called with a period of CONFIG_CLOCK_CONTROL_NRF_CALIBRATION_PERIOD"]
    pub fn mpsl_calibration_timer_handle();
}
unsafe extern "C" {
    #[doc = "RFU\n\n RFU"]
    pub fn mpsl_pan_rfu();
}
unsafe extern "C" {
    #[doc = "MPSL requesting CONSTLAT to be on.\n\n The application needs to implement this function.\n MPSL will call the function when it needs CONSTLAT to be on.\n It only calls the function on nRF54L Series devices."]
    pub fn mpsl_constlat_request_callback();
}
unsafe extern "C" {
    #[doc = "De-request CONSTLAT to be on.\n\n The application needs to implement this function.\n MPSL will call the function when it no longer needs CONSTLAT to be on.\n It only only calls the function on nRF54L Series devices."]
    pub fn mpsl_lowpower_request_callback();
}
#[doc = "AES ECB data structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpsl_ecb_hal_data_t {
    #[doc = "< Encryption key."]
    pub key: [u32; 4usize],
    #[doc = "< Cleartext data."]
    pub cleartext: [u8; 16usize],
    #[doc = "< Ciphertext data."]
    pub ciphertext: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mpsl_ecb_hal_data_t"][::core::mem::size_of::<mpsl_ecb_hal_data_t>() - 48usize];
    ["Alignment of mpsl_ecb_hal_data_t"][::core::mem::align_of::<mpsl_ecb_hal_data_t>() - 4usize];
    ["Offset of field: mpsl_ecb_hal_data_t::key"][::core::mem::offset_of!(mpsl_ecb_hal_data_t, key) - 0usize];
    ["Offset of field: mpsl_ecb_hal_data_t::cleartext"]
        [::core::mem::offset_of!(mpsl_ecb_hal_data_t, cleartext) - 16usize];
    ["Offset of field: mpsl_ecb_hal_data_t::ciphertext"]
        [::core::mem::offset_of!(mpsl_ecb_hal_data_t, ciphertext) - 32usize];
};
unsafe extern "C" {
    #[doc = "Encrypts a block according to the specified parameters.\n\n > **Note:** This function will only return once the ciphertext has been generated.\n > **Note:** This function may only be used on nRF52 and nRF53 series devices.\n > **Note:** This function is deprecated. Do not use.\n\n # Arguments\n\n* `p_ecb_data` - Pointer to ECB data structure. Its elements are assumed to be big-endian."]
    pub fn mpsl_ecb_block_encrypt(p_ecb_data: *mut mpsl_ecb_hal_data_t);
}
unsafe extern "C" {
    #[doc = "Encrypts a block according to the specified parameters.\n\n > **Note:** This function will only return once the ciphertext has been generated.\n\n # Arguments\n\n* `[in]` -key Encryption key\n * `[in]` -cleartext Plaintext to be encrypted\n * `[out]` -ciphertext Encrypted text\n * `[in]` -flags Any combination of the following flags:\n - MPSL_ECB_INPUT_LE The key and cleartext are in little-endian format.\n - MPSL_ECB_OUTPUT_LE The ciphertext will be returned in little-endian format.\n - MPSL_ECB_CLEARTEXT_IN_LOCAL_RAM Unless this is set, the `cleartext` will be copied to RAM\n since the ECB hardware cannot access other memory locations."]
    pub fn mpsl_ecb_block_encrypt_extended(key: *const u8, cleartext: *const u8, ciphertext: *mut u8, flags: u32);
}
#[doc = "Listening for asynchronous transmissions"]
pub const MPSL_CX_OP_IDLE_LISTEN: mpsl_cx_op_t = 1;
#[doc = "Active reception\n\n This value may be used to indicate:\n * RX window:\n * in BLE connection event\n * 802.15.4 CSL\n * ...\n * Detected a frame transmitted asynchronously:\n * during BLE scanning\n * during 802.15.4 idle listening\n * ..."]
pub const MPSL_CX_OP_RX: mpsl_cx_op_t = 2;
#[doc = "Active transmission"]
pub const MPSL_CX_OP_TX: mpsl_cx_op_t = 4;
#[doc = "Radio operations which may be requested from or granted by PTA."]
pub type mpsl_cx_op_t = ::core::ffi::c_uint;
#[doc = "Bitmap representing a list of radio operations.\n\n Logical OR of radio operations defined in mpsl_cx_op_t."]
pub type mpsl_cx_op_map_t = u8;
#[doc = "Priority of given radio operation.\n\n This numerical value is translated by given PTA interface driver to appropriate signal.\n The straightforward translation would be <= UINT8_MAX/2 is low priority, while > UINT8_MAX/2\n is high priority. More complicated PTAs support more than 2 priority levels and valid matching\n must be implemented for such devices.\n\n Priority values must be aligned between all users of this API in given system. When multiple\n radio protocols are enabled (like Bluetooth LE and IEEE 802.15.4), all protocols must use\n aligned values (Bluetooth low priority operations must use numerically lower value than\n IEEE 802.15.4 high priority operations)."]
pub type mpsl_cx_prio_t = u8;
#[doc = "< Request is triggered instantly, during mpsl_cx_request call"]
pub const MPSL_CX_REQ_TRIG_INSTANT: mpsl_cx_req_trig_t = 0;
#[doc = "Coexistence request signal triggers."]
pub type mpsl_cx_req_trig_t = ::core::ffi::c_uint;
#[doc = "Structure with parameters describing next coexistence request."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpsl_cx_request_t {
    #[doc = "< List of requested radio operations"]
    pub ops: mpsl_cx_op_map_t,
    #[doc = "< Priority of requested radio operation"]
    pub prio: mpsl_cx_prio_t,
    #[doc = "< When request is to be triggered"]
    pub trigger: mpsl_cx_req_trig_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mpsl_cx_request_t"][::core::mem::size_of::<mpsl_cx_request_t>() - 8usize];
    ["Alignment of mpsl_cx_request_t"][::core::mem::align_of::<mpsl_cx_request_t>() - 4usize];
    ["Offset of field: mpsl_cx_request_t::ops"][::core::mem::offset_of!(mpsl_cx_request_t, ops) - 0usize];
    ["Offset of field: mpsl_cx_request_t::prio"][::core::mem::offset_of!(mpsl_cx_request_t, prio) - 1usize];
    ["Offset of field: mpsl_cx_request_t::trigger"][::core::mem::offset_of!(mpsl_cx_request_t, trigger) - 4usize];
};
#[doc = "Callback used to notify radio protocol about changes of granted radio operations.\n\n # Arguments\n\n* `[in]` -granted_ops List of all operations currently allowed by PTA."]
pub type mpsl_cx_cb_t = ::core::option::Option<unsafe extern "C" fn(granted_ops: mpsl_cx_op_map_t)>;
unsafe extern "C" {
    #[doc = "Request radio operation from PTA\n\n This function is to be called before transceiver is enabled to inform PTA about planned radio\n operation which is about to start and about the priority of this operation.\n\n Each call of this function overrides the last request.\n\n This function is usually called shortly before scheduled radio operations, or just after\n detection of asynchronous events indicating radio operations.\n\n Call to this function cannot preempt a call to mpsl_cx_release. It is responsibility of\n user of this interface to prevent such preemption.\n\n # Arguments\n\n* `[in]` -p_req_params Pointer to a structure containing parameters of given request.\n\n # Returns\n\n* `0` - Requested radio operation from PTA\n * `-EINVAL` - Incorrect value of any field in `p_req_params` or `p_req_params` is NULL."]
    pub fn mpsl_cx_request(p_req_params: *const mpsl_cx_request_t) -> i32;
}
unsafe extern "C" {
    #[doc = "Release last radio operation requested from PTA\n\n This function is to be called after transceiver is disabled to inform PTA that any previously\n requested operations by mpsl_cx_request are not requested anymore.\n\n This function releases requested radio operations immediately.\n\n Call to this function cannot preempt a call to mpsl_cx_request. It is responsibility of\n user of this interface to prevent such preemption.\n\n # Returns\n\n* `0` - Last request is released.\n * `-EALREADY` - There was no request to release."]
    pub fn mpsl_cx_release() -> i32;
}
unsafe extern "C" {
    #[doc = "Get list of radio operations currently granted by PTA.\n\n > **Note:** PTA may change granted radio operations list at any time. It is possible that value\n returned by this function is outdated before the function ends its execution.\n\n # Arguments\n\n* `[out]` -p_granted_ops Map of granted radio operations.\n\n # Returns\n\n* `0` - List of granted radio operations is stored in the passed memory address.\n * `-EINVAL` - `granted_ops` is NULL pointer."]
    pub fn mpsl_cx_granted_ops_get(p_granted_ops: *mut mpsl_cx_op_map_t) -> i32;
}
unsafe extern "C" {
    #[doc = "Get time PTA needs to respond with grant signal to request signal.\n\n There are three ways to manage the grant signal by PTA:\n 1. Keep grant signal in denied state by default and provide grant only after request.\n The maximum delay between request and grant signal is known.\n 2. Keep grant signal in approved state by default and deny only if given request cannot be\n accepted. Radio is not allowed to start any operation for known time after the request signal\n is set. After this delay the grant signal can indicate denial anytime to prevent or to abort\n radio operation.\n 3. Manage the granted signal constantly, even if there is no request from given radio.\n\n This function is to be used to verify how long the user of this interface should wait from\n calling mpsl_cx_request (return from function) to mpsl_cx_granted_ops_get (call\n to function) to prevent getting false results while PTA is responding to the last request.\n\n # Returns\n\n* `>0` - Minimal delay from setting the request signal to the time grant signal gets\n meaningful value. In microseconds, rounded up\n * `0` - Grant signal has always meaningful value. Can be checked before, during, or after\n setting the request signal."]
    pub fn mpsl_cx_req_grant_delay_get() -> u32;
}
unsafe extern "C" {
    #[doc = "Register callback function called when radio operations granted by PTA change.\n\n This function is used by radio protocols that require CPU processing when list of granted\n operations changes. One example is a protocol waiting with asynchronous transmission until TX\n operation is granted.\n\n When radio protocol stops using Coexistence interface to hand it over to another protocol,\n it shall reset callback by calling this function with NULL value passed in `cb.`\n\n # Arguments\n\n* `[in]` -cb Pointer to a callback function called when radio operations granted by PTA\n change. If NULL, callback function is reset and nothing is called when\n granted radio operations change.\n\n # Returns\n\n* `0` - Successfully set or reset callback function."]
    pub fn mpsl_cx_register_callback(cb: mpsl_cx_cb_t) -> i32;
}
#[doc = "Set of pointers to functions in MPSL Coexistence interface.\n\n This structure defines a set of pointers to functions which correspond the Public Protocol API defined in the\n mpsl_cx_protocol_api.h file."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpsl_cx_interface_t {
    #[doc = "Pointer to a function called when mpsl_cx_request is called"]
    pub p_request: ::core::option::Option<unsafe extern "C" fn(p_req_params: *const mpsl_cx_request_t) -> i32>,
    #[doc = "Pointer to a function called when mpsl_cx_release is called"]
    pub p_release: ::core::option::Option<unsafe extern "C" fn() -> i32>,
    #[doc = "Pointer to a function called when mpsl_cx_granted_ops_get is called"]
    pub p_granted_ops_get: ::core::option::Option<unsafe extern "C" fn(p_granted_ops: *mut mpsl_cx_op_map_t) -> i32>,
    #[doc = "Pointer to a function called when mpsl_cx_req_grant_delay_get is called"]
    pub p_req_grant_delay_get: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    #[doc = "Pointer to a function called when mpsl_cx_register_callback is called"]
    pub p_register_callback: ::core::option::Option<unsafe extern "C" fn(cb: mpsl_cx_cb_t) -> i32>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mpsl_cx_interface_t"][::core::mem::size_of::<mpsl_cx_interface_t>() - 20usize];
    ["Alignment of mpsl_cx_interface_t"][::core::mem::align_of::<mpsl_cx_interface_t>() - 4usize];
    ["Offset of field: mpsl_cx_interface_t::p_request"]
        [::core::mem::offset_of!(mpsl_cx_interface_t, p_request) - 0usize];
    ["Offset of field: mpsl_cx_interface_t::p_release"]
        [::core::mem::offset_of!(mpsl_cx_interface_t, p_release) - 4usize];
    ["Offset of field: mpsl_cx_interface_t::p_granted_ops_get"]
        [::core::mem::offset_of!(mpsl_cx_interface_t, p_granted_ops_get) - 8usize];
    ["Offset of field: mpsl_cx_interface_t::p_req_grant_delay_get"]
        [::core::mem::offset_of!(mpsl_cx_interface_t, p_req_grant_delay_get) - 12usize];
    ["Offset of field: mpsl_cx_interface_t::p_register_callback"]
        [::core::mem::offset_of!(mpsl_cx_interface_t, p_register_callback) - 16usize];
};
unsafe extern "C" {
    #[doc = "Connects to one of Coexistence PTA client implementation\n\n # Arguments\n\n* `[in]` -p_methods Pointer to structure of pointers.\n this must be valid for the lifetime of the application.\n\n > **Note:** This must be used by Coexistence implementation \"constructor\" and this is the only case\n in which it can be used.\n\n # Returns\n\n* `0` - The \"link\" was successfuly created.\n * `-NRF_EPERM` - Some error occured (e.g. null pointer was passed)."]
    pub fn mpsl_cx_interface_set(p_methods: *const mpsl_cx_interface_t) -> i32;
}
pub const MPSL_PM_EVENT_STATE_BEFORE_EVENT: mpsl_pm_event_state_t = 0;
pub const MPSL_PM_EVENT_STATE_NO_EVENTS_LEFT: mpsl_pm_event_state_t = 1;
#[doc = "MPSL Power Management state in regards to next event."]
pub type mpsl_pm_event_state_t = ::core::ffi::c_uint;
#[doc = "MPSL Power Management parameters.\n\n These parameters should be used in a low-priority context out of MPSL.\n They are used to inform an external power management system about next expected event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpsl_pm_params_t {
    #[doc = "< Absolute time of next event. Only valid during MPSL_PM_EVENT_STATE_BEFORE_EVENT."]
    pub event_time_abs_us: u64,
    #[doc = "< State of event mpsl_pm_event_state_t."]
    pub event_state: mpsl_pm_event_state_t,
    #[doc = "< Event time update request counter."]
    pub cnt_flag: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mpsl_pm_params_t"][::core::mem::size_of::<mpsl_pm_params_t>() - 16usize];
    ["Alignment of mpsl_pm_params_t"][::core::mem::align_of::<mpsl_pm_params_t>() - 8usize];
    ["Offset of field: mpsl_pm_params_t::event_time_abs_us"]
        [::core::mem::offset_of!(mpsl_pm_params_t, event_time_abs_us) - 0usize];
    ["Offset of field: mpsl_pm_params_t::event_state"][::core::mem::offset_of!(mpsl_pm_params_t, event_state) - 8usize];
    ["Offset of field: mpsl_pm_params_t::cnt_flag"][::core::mem::offset_of!(mpsl_pm_params_t, cnt_flag) - 12usize];
};
unsafe extern "C" {
    #[doc = "Get next expected event time.\n\n # Arguments\n\n* `[out]` -p_params Pointer to event parameters\n\n # Returns\n\n* `true` - if high-prio didn't update the parameters while we read them"]
    pub fn mpsl_pm_params_get(p_params: *mut mpsl_pm_params_t) -> bool;
}
pub const MPSL_PM_LOW_LATENCY_STATE_OFF: mpsl_pm_low_latency_state_t = 0;
pub const MPSL_PM_LOW_LATENCY_STATE_REQUESTING: mpsl_pm_low_latency_state_t = 1;
pub const MPSL_PM_LOW_LATENCY_STATE_ON: mpsl_pm_low_latency_state_t = 2;
pub const MPSL_PM_LOW_LATENCY_STATE_RELEASING: mpsl_pm_low_latency_state_t = 3;
#[doc = "MPSL Power Management low latency state.\n\n The different states of low latency requests. The external power management system shall use\n mpsl_pm_low_latency_state_set to tell MPSL whether or not low latency mode is active.\n For transitions that are not instant, the corresponding\n REQUESTING and RELEASING states shall be used.\n\n When low latency state is either OFF, REQUESTING or ON, the external power management system shall call\n mpsl_pm_low_latency_requested and initiate transition to the appropriate state. MPSL\n will only request low latency in the OFF state, and only release low latency in the REQUESTING or ON states."]
pub type mpsl_pm_low_latency_state_t = ::core::ffi::c_uint;
unsafe extern "C" {
    #[doc = "Get low latency request status.\n\n # Returns\n\n* `true` - if low latency requested by MPSL, false otherwise."]
    pub fn mpsl_pm_low_latency_requested() -> bool;
}
unsafe extern "C" {
    #[doc = "Set low latency state.\n\n When the external power management system initiates transitioning to and from low\n latency state, it shall call this function to notify MPSL about the state changes.\n\n # Arguments\n\n* `[in]` -state The current low latency state."]
    pub fn mpsl_pm_low_latency_state_set(state: mpsl_pm_low_latency_state_t);
}
unsafe extern "C" {
    #[doc = "Get low latency state.\n\n # Returns\n\n* `The` - current state of low latency mode."]
    pub fn mpsl_pm_low_latency_state_get() -> mpsl_pm_low_latency_state_t;
}
unsafe extern "C" {
    #[doc = "Initialize MPSL external Power Management integration.\n\n Enables integration with external power management system. After calling\n this function, the external power management system must service requests\n for low latency and event registration according to the API defined\n in mpsl_pm.h file."]
    pub fn mpsl_pm_init();
}
unsafe extern "C" {
    #[doc = "Uninitialize MPSL external Power Management integration.\n\n Disables integration with external power management system."]
    pub fn mpsl_pm_uninit();
}
unsafe extern "C" {
    #[doc = "Get the temperature measured on the chip\n\n This function will block until the temperature measurement is done.\n It takes around 50 us from call to return.\n\n > **Note:** This function must be executed in the same execution priority as mpsl_low_priority_process.\n\n # Returns\n\nResult of temperature measurement. Die temperature in 0.25 degrees Celsius."]
    pub fn mpsl_temperature_get() -> i32;
}
#[doc = "The timeslot session id type"]
pub type mpsl_timeslot_session_id_t = u8;
#[doc = "< This signal indicates the start of the timeslot.\nThe signal will be executed in the same context as\nMPSL_IRQ_TIMER0_Handler."]
pub const MPSL_TIMESLOT_SIGNAL_START: MPSL_TIMESLOT_SIGNAL = 0;
#[doc = "< This signal indicates the TIMER0 interrupt.\nThe signal will be executed in the same context as\nMPSL_IRQ_TIMER0_Handler.\nThe timer being used is defined by\nMPSL_TIMER0."]
pub const MPSL_TIMESLOT_SIGNAL_TIMER0: MPSL_TIMESLOT_SIGNAL = 1;
#[doc = "< This signal indicates the RADIO interrupt.\nThe signal will be executed in the same context as\nMPSL_IRQ_RADIO_Handler."]
pub const MPSL_TIMESLOT_SIGNAL_RADIO: MPSL_TIMESLOT_SIGNAL = 2;
#[doc = "< This signal indicates extend action failed.\nThe signal will be executed in the same context as\nthe previous signal."]
pub const MPSL_TIMESLOT_SIGNAL_EXTEND_FAILED: MPSL_TIMESLOT_SIGNAL = 3;
#[doc = "< This signal indicates extend action succeeded.\nThe signal will be executed in the same context as\nthe previous signal."]
pub const MPSL_TIMESLOT_SIGNAL_EXTEND_SUCCEEDED: MPSL_TIMESLOT_SIGNAL = 4;
#[doc = "< The previous request was blocked. The signal will\nbe executed in the same context as\nmpsl_low_priority_process."]
pub const MPSL_TIMESLOT_SIGNAL_BLOCKED: MPSL_TIMESLOT_SIGNAL = 5;
#[doc = "< The previous request was cancelled. The signal will\nbe executed in the same context as\nmpsl_low_priority_process."]
pub const MPSL_TIMESLOT_SIGNAL_CANCELLED: MPSL_TIMESLOT_SIGNAL = 6;
#[doc = "< The timeslot session has no more pending requests.\nThe signal will be executed in the same context as\nmpsl_low_priority_process."]
pub const MPSL_TIMESLOT_SIGNAL_SESSION_IDLE: MPSL_TIMESLOT_SIGNAL = 7;
#[doc = "< The previous timeslot callback return value was invalid.\nThe signal will be executed in the same context as\nthe previous signal which had an invalid return value.\nThe application should avoid to continuously provide\ninvalid return values. Doing so, will lead to an\ninfinite loop."]
pub const MPSL_TIMESLOT_SIGNAL_INVALID_RETURN: MPSL_TIMESLOT_SIGNAL = 8;
#[doc = "< The session has been closed."]
pub const MPSL_TIMESLOT_SIGNAL_SESSION_CLOSED: MPSL_TIMESLOT_SIGNAL = 9;
#[doc = "< The timeslot event was closed too late.\nAn assert will be triggered after the processing\nof this signal completes."]
pub const MPSL_TIMESLOT_SIGNAL_OVERSTAYED: MPSL_TIMESLOT_SIGNAL = 10;
#[doc = "The timeslot signal types."]
pub type MPSL_TIMESLOT_SIGNAL = ::core::ffi::c_uint;
#[doc = "< Return without action."]
pub const MPSL_TIMESLOT_SIGNAL_ACTION_NONE: MPSL_TIMESLOT_SIGNAL_ACTION = 0;
#[doc = "< Request an extension of the current\ntimeslot event.\nMaximum execution time for this action:\nMPSL_TIMESLOT_EXTENSION_PROCESSING_TIME_MAX_US.\nThis action must be started at least\nMPSL_TIMESLOT_EXTENSION_MARGIN_MIN_US before\nthe end of a timeslot event.\n> **Note:** This signal action may only be used from\nwithin a timeslot event."]
pub const MPSL_TIMESLOT_SIGNAL_ACTION_EXTEND: MPSL_TIMESLOT_SIGNAL_ACTION = 1;
#[doc = "< End the current timeslot event.\n> **Note:** This signal action may only be called\nfrom within a timeslot event."]
pub const MPSL_TIMESLOT_SIGNAL_ACTION_END: MPSL_TIMESLOT_SIGNAL_ACTION = 2;
#[doc = "< Request a new timeslot event.\n> **Note:** If this signal action is used from within\na timeslot, the current timeslot event is closed."]
pub const MPSL_TIMESLOT_SIGNAL_ACTION_REQUEST: MPSL_TIMESLOT_SIGNAL_ACTION = 3;
#[doc = "The actions requested by the signal callback.\n\n This code gives instructions about what action to take when the signal callback has\n returned.\n\n > **Note:** For signals executed in low priority returning any action other than\n MPSL_TIMESLOT_SIGNAL_ACTION_NONE will result in an assert."]
pub type MPSL_TIMESLOT_SIGNAL_ACTION = ::core::ffi::c_uint;
#[doc = "< The high frequency clock source is the external crystal\nfor the whole duration of the timeslot. This should be the\npreferred option for events that use the radio or\nrequire high timing accuracy.\n> **Note:** The external crystal will automatically be\nturned on and off at the beginning and end of the\ntimeslot."]
pub const MPSL_TIMESLOT_HFCLK_CFG_XTAL_GUARANTEED: MPSL_TIMESLOT_HFCLK_CFG = 0;
#[doc = "< This configuration allows for earlier and tighter\nscheduling of timeslots. The RC oscillator may be\nthe clock source in part or for the whole duration\nof the timeslot. The RC oscillator's accuracy must\ntherefore be taken into consideration.\n> **Note:** If the application will use the radio peripheral\nin timeslots with this configuration, it must ensure\nthat the crystal is running and stable before\nstarting the radio. On nRF54H series chips the crystal\nis also needed to use any peripheral in RADIO_PD,\nincluding timers."]
pub const MPSL_TIMESLOT_HFCLK_CFG_NO_GUARANTEE: MPSL_TIMESLOT_HFCLK_CFG = 1;
#[doc = "Timeslot high frequency clock source configuration."]
pub type MPSL_TIMESLOT_HFCLK_CFG = ::core::ffi::c_uint;
#[doc = "< High priority."]
pub const MPSL_TIMESLOT_PRIORITY_HIGH: MPSL_TIMESLOT_PRIORITY = 0;
#[doc = "< Low priority."]
pub const MPSL_TIMESLOT_PRIORITY_NORMAL: MPSL_TIMESLOT_PRIORITY = 1;
#[doc = "Timeslot event priorities."]
pub type MPSL_TIMESLOT_PRIORITY = ::core::ffi::c_uint;
#[doc = "< Request timeslot as early as possible.\nThis should always be used for the first request\nin a session.\n> **Note:** It is not permitted to request an earliest\ntimeslot from within a timeslot."]
pub const MPSL_TIMESLOT_REQ_TYPE_EARLIEST: MPSL_TIMESLOT_REQUEST_TYPE = 0;
#[doc = "< Normal timeslot request."]
pub const MPSL_TIMESLOT_REQ_TYPE_NORMAL: MPSL_TIMESLOT_REQUEST_TYPE = 1;
#[doc = "Timeslot request type."]
pub type MPSL_TIMESLOT_REQUEST_TYPE = ::core::ffi::c_uint;
#[doc = "Parameters for a request for a timeslot as early as possible."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpsl_timeslot_request_earliest_t {
    #[doc = "< High frequency clock source, see MPSL_TIMESLOT_HFCLK_CFG."]
    pub hfclk: u8,
    #[doc = "< The timeslot priority, see MPSL_TIMESLOT_PRIORITY."]
    pub priority: u8,
    #[doc = "< The timeslot length, MPSL_TIMESLOT_LENGTH_MIN_US,\nMPSL_TIMESLOT_LENGTH_MAX_US."]
    pub length_us: u32,
    #[doc = "< Longest acceptable delay until the start of the requested\ntimeslot, up to MPSL_TIMESLOT_EARLIEST_TIMEOUT_MAX_US\nmicroseconds."]
    pub timeout_us: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mpsl_timeslot_request_earliest_t"][::core::mem::size_of::<mpsl_timeslot_request_earliest_t>() - 12usize];
    ["Alignment of mpsl_timeslot_request_earliest_t"]
        [::core::mem::align_of::<mpsl_timeslot_request_earliest_t>() - 4usize];
    ["Offset of field: mpsl_timeslot_request_earliest_t::hfclk"]
        [::core::mem::offset_of!(mpsl_timeslot_request_earliest_t, hfclk) - 0usize];
    ["Offset of field: mpsl_timeslot_request_earliest_t::priority"]
        [::core::mem::offset_of!(mpsl_timeslot_request_earliest_t, priority) - 1usize];
    ["Offset of field: mpsl_timeslot_request_earliest_t::length_us"]
        [::core::mem::offset_of!(mpsl_timeslot_request_earliest_t, length_us) - 4usize];
    ["Offset of field: mpsl_timeslot_request_earliest_t::timeout_us"]
        [::core::mem::offset_of!(mpsl_timeslot_request_earliest_t, timeout_us) - 8usize];
};
#[doc = "Parameters for a normal timeslot request."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpsl_timeslot_request_normal_t {
    #[doc = "< High frequency clock source, see MPSL_TIMESLOT_HFCLK_CFG."]
    pub hfclk: u8,
    #[doc = "< The timeslot priority, see MPSL_TIMESLOT_PRIORITY."]
    pub priority: u8,
    #[doc = "< Distance from the start of the previous timeslot\nup to MPSL_TIMESLOT_DISTANCE_MAX_US microseconds."]
    pub distance_us: u32,
    #[doc = "< The timeslot length, MPSL_TIMESLOT_LENGTH_MIN_US,\nMPSL_TIMESLOT_LENGTH_MAX_US."]
    pub length_us: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mpsl_timeslot_request_normal_t"][::core::mem::size_of::<mpsl_timeslot_request_normal_t>() - 12usize];
    ["Alignment of mpsl_timeslot_request_normal_t"][::core::mem::align_of::<mpsl_timeslot_request_normal_t>() - 4usize];
    ["Offset of field: mpsl_timeslot_request_normal_t::hfclk"]
        [::core::mem::offset_of!(mpsl_timeslot_request_normal_t, hfclk) - 0usize];
    ["Offset of field: mpsl_timeslot_request_normal_t::priority"]
        [::core::mem::offset_of!(mpsl_timeslot_request_normal_t, priority) - 1usize];
    ["Offset of field: mpsl_timeslot_request_normal_t::distance_us"]
        [::core::mem::offset_of!(mpsl_timeslot_request_normal_t, distance_us) - 4usize];
    ["Offset of field: mpsl_timeslot_request_normal_t::length_us"]
        [::core::mem::offset_of!(mpsl_timeslot_request_normal_t, length_us) - 8usize];
};
#[doc = "Timeslot request parameters."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mpsl_timeslot_request_t {
    #[doc = "< Type of request, see MPSL_TIMESLOT_REQUEST_TYPE."]
    pub request_type: u8,
    #[doc = "< Union containing parameters for the request specified."]
    pub params: mpsl_timeslot_request_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mpsl_timeslot_request_t__bindgen_ty_1 {
    #[doc = "< Parameters for requesting a timeslot as\nearly as possible."]
    pub earliest: mpsl_timeslot_request_earliest_t,
    #[doc = "< Parameters for requesting a normal timeslot."]
    pub normal: mpsl_timeslot_request_normal_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mpsl_timeslot_request_t__bindgen_ty_1"]
        [::core::mem::size_of::<mpsl_timeslot_request_t__bindgen_ty_1>() - 12usize];
    ["Alignment of mpsl_timeslot_request_t__bindgen_ty_1"]
        [::core::mem::align_of::<mpsl_timeslot_request_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: mpsl_timeslot_request_t__bindgen_ty_1::earliest"]
        [::core::mem::offset_of!(mpsl_timeslot_request_t__bindgen_ty_1, earliest) - 0usize];
    ["Offset of field: mpsl_timeslot_request_t__bindgen_ty_1::normal"]
        [::core::mem::offset_of!(mpsl_timeslot_request_t__bindgen_ty_1, normal) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mpsl_timeslot_request_t"][::core::mem::size_of::<mpsl_timeslot_request_t>() - 16usize];
    ["Alignment of mpsl_timeslot_request_t"][::core::mem::align_of::<mpsl_timeslot_request_t>() - 4usize];
    ["Offset of field: mpsl_timeslot_request_t::request_type"]
        [::core::mem::offset_of!(mpsl_timeslot_request_t, request_type) - 0usize];
    ["Offset of field: mpsl_timeslot_request_t::params"]
        [::core::mem::offset_of!(mpsl_timeslot_request_t, params) - 4usize];
};
#[doc = "Return parameters of the timeslot signal callback."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mpsl_timeslot_signal_return_param_t {
    #[doc = "< The action requested by the application when\nreturning from the signal callback, see\nMPSL_TIMESLOT_SIGNAL_ACTION."]
    pub callback_action: u8,
    #[doc = "< Parameter union."]
    pub params: mpsl_timeslot_signal_return_param_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mpsl_timeslot_signal_return_param_t__bindgen_ty_1 {
    #[doc = "< Additional parameters for return_code\nMPSL_TIMESLOT_SIGNAL_ACTION_REQUEST."]
    pub request: mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_1,
    #[doc = "< Additional parameters for return_code\nMPSL_TIMESLOT_SIGNAL_ACTION_EXTEND."]
    pub extend: mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< The request parameters for the next timeslot."]
    pub p_next: *mut mpsl_timeslot_request_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::size_of::<mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Alignment of mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::align_of::<mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Offset of field: mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_1::p_next"]
        [::core::mem::offset_of!(mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_1, p_next) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< Requested extension of the timeslot duration.\nThe minimum time is\nMPSL_TIMESLOT_EXTENSION_TIME_MIN_US)."]
    pub length_us: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_2"]
        [::core::mem::size_of::<mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_2>() - 4usize];
    ["Alignment of mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_2"]
        [::core::mem::align_of::<mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_2>() - 4usize];
    ["Offset of field: mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_2::length_us"][::core::mem::offset_of!(
        mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_2,
        length_us
    ) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mpsl_timeslot_signal_return_param_t__bindgen_ty_1"]
        [::core::mem::size_of::<mpsl_timeslot_signal_return_param_t__bindgen_ty_1>() - 4usize];
    ["Alignment of mpsl_timeslot_signal_return_param_t__bindgen_ty_1"]
        [::core::mem::align_of::<mpsl_timeslot_signal_return_param_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: mpsl_timeslot_signal_return_param_t__bindgen_ty_1::request"]
        [::core::mem::offset_of!(mpsl_timeslot_signal_return_param_t__bindgen_ty_1, request) - 0usize];
    ["Offset of field: mpsl_timeslot_signal_return_param_t__bindgen_ty_1::extend"]
        [::core::mem::offset_of!(mpsl_timeslot_signal_return_param_t__bindgen_ty_1, extend) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mpsl_timeslot_signal_return_param_t"]
        [::core::mem::size_of::<mpsl_timeslot_signal_return_param_t>() - 8usize];
    ["Alignment of mpsl_timeslot_signal_return_param_t"]
        [::core::mem::align_of::<mpsl_timeslot_signal_return_param_t>() - 4usize];
    ["Offset of field: mpsl_timeslot_signal_return_param_t::callback_action"]
        [::core::mem::offset_of!(mpsl_timeslot_signal_return_param_t, callback_action) - 0usize];
    ["Offset of field: mpsl_timeslot_signal_return_param_t::params"]
        [::core::mem::offset_of!(mpsl_timeslot_signal_return_param_t, params) - 4usize];
};
#[doc = "The timeslot signal callback type.\n\n > **Note:** In case of invalid return parameters, the timeslot will automatically end\n immediately after returning from the signal callback and the\n MPSL_TIMESLOT_SIGNAL_INVALID_RETURN event will be sent.\n > **Note:** The returned struct pointer must remain valid after the signal callback\n function returns. For instance, this means that it must not point to a stack variable.\n > **Note:** The signal callback is executed from high priority context. It is not advised to use\n blocking operations in it. Use of kernel APIs may be also disallowed. Please check your\n operating system documentation.\n\n # Arguments\n\n* `[in]` -session_id Session id as returned by mpsl_timeslot_session_open.\n * `[in]` -signal Type of signal, see MPSL_TIMESLOT_SIGNAL.\n\n # Returns\n\nPointer to structure containing action requested by the application."]
pub type mpsl_timeslot_callback_t = ::core::option::Option<
    unsafe extern "C" fn(
        session_id: mpsl_timeslot_session_id_t,
        signal: u32,
    ) -> *mut mpsl_timeslot_signal_return_param_t,
>;
unsafe extern "C" {
    #[doc = "Set or update the MPSL timeslot configuration.\n\n > **Note:** Resource configuration can only be performed when all timeslots are closed.\n\n # Arguments\n\n* `[in]` -p_mem Pointer to a memory location for timeslot sessions.\n The size of the memory block needs to be at least\n n_sessions * MPSL_TIMESLOT_CONTEXT_SIZE bytes.\n The memory needs to reside in RAM.\n The pointer needs to be aligned to a 4-byte boundary.\n * `[in]` -n_sessions Number of timeslot sessions.\n Maximum number of supported timeslot sessions is MPSL_TIMESLOT_CONTEXT_COUNT_MAX.\n\n # Returns\n\n* `0` - The configuration was applied successfully.\n * `-NRF_EPERM` - Timeslots need to be configured when no timeslots are open.\n * `-NRF_EINVAL` - Invalid argument provided.\n * `-NRF_EFAULT` - The memory is not aligned to a 4-byte boundary."]
    pub fn mpsl_timeslot_session_count_set(p_mem: *mut ::core::ffi::c_void, n_sessions: u8) -> i32;
}
unsafe extern "C" {
    #[doc = "Opens a session for timeslot requests.\n\n > **Note:** Only one session can be open at a time.\n > **Note:** mpsl_timeslot_signal_callback(MPSL_TIMESLOT_SIGNAL_START) will be called when the timeslot\n starts. From this point the RADIO, TIMER0, AAR, and CCM peripherals can be freely accessed\n by the application.\n > **Note:** mpsl_timeslot_signal_callback(MPSL_TIMESLOT_SIGNAL_TIMER0) is called whenever\n the TIMER0 interrupt occurs.\n > **Note:** mpsl_timeslot_signal_callback(MPSL_TIMESLOT_SIGNAL_RADIO) is called whenever the RADIO\n interrupt occurs.\n > **Note:** If the low frequency clock is not running when this function is called,\n the function will wait until the low frequency clock has started.\n See mpsl_clock_lfclk_cfg_t::skip_wait_lfclk_started.\n\n # Arguments\n\n* `[in]` -mpsl_timeslot_signal_callback The signal callback.\n * `[out]` -p_session_id Pointer to the id of the session that was opened.\n\n # Returns\n\n* `0` - Request was successful.\n * `-NRF_ENOMEM` - All sessions are already open."]
    pub fn mpsl_timeslot_session_open(
        mpsl_timeslot_signal_callback: mpsl_timeslot_callback_t,
        p_session_id: *mut mpsl_timeslot_session_id_t,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = "Closes a session for timeslot requests.\n\n > **Note:** Any current timeslot will be finished before the session is closed.\n > **Note:** If a timeslot is scheduled when the session is closed, it will be canceled.\n\n # Arguments\n\n* `[in]` -session_id The session identifier as returned by mpsl_timeslot_session_open.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EAGAIN` - Session already closed"]
    pub fn mpsl_timeslot_session_close(session_id: mpsl_timeslot_session_id_t) -> i32;
}
unsafe extern "C" {
    #[doc = "Requests a timeslot.\n\n Successful requests will result in mpsl_timeslot_signal_callback_t(MPSL_TIMESLOT_SIGNAL_START).\n Unsuccessful requests will result in a MPSL_TIMESLOT_SIGNAL_BLOCKED event.\n\n Once the timeslot has started, the application is responsible for keeping track of timing within\n the timeslot and for ensuring that the applications use of the peripherals does not last for longer\n than the granted timeslot length.\n The recommended practice is to set up a timer interrupt that expires before the timeslot expires,\n with enough time left for the timeslot to do any clean-up actions before the timeslot ends.\n Such a timer interrupt can also be used to request an extension of the timeslot,\n but there must still be enough time to clean up if the extension is not granted.\n\n > **Note:** The first request in a session must always be of type MPSL_TIMESLOT_REQ_TYPE_EARLIEST.\n > **Note:** The jitter in the start time of the timeslots is +/- MPSL_TIMESLOT_START_JITTER_US us.\n > **Note:** The mpsl_timeslot_signal_callback_t(MPSL_TIMESLOT_SIGNAL_START) call has a latency relative to the\n specified timeslot start, but this does not affect the actual start time of the timeslot.\n > **Note:** TIMER0 is reset when MPSL_TIMESLOT_SIGNAL_START triggers.\n and is clocked at 1MHz from the high frequency (16 MHz) clock source.\n The scheduler uses the LFCLK source for time calculations when scheduling events.\n If the application uses a TIMER (sourced from the current HFCLK source) to calculate and\n signal the end of a timeslot, it must account for the possible clock drift between the\n HFCLK source and the LFCLK source.\n > **Note:** No stack will neither access the RADIO peripheral nor the TIMER0 peripheral\n during the timeslot.\n\n # Arguments\n\n* `[in]` -session_id The session identifier as returned by mpsl_timeslot_session_open.\n * `[in]` -p_request Pointer to the request parameters.\n\n # Returns\n\n* `0` - Success\n * `-NRF_EINVAL` - The parameters of p_request are not valid\n * `-NRF_ENOENT` - The session is not open.\n * `-NRF_EAGAIN` - The session is not IDLE."]
    pub fn mpsl_timeslot_request(
        session_id: mpsl_timeslot_session_id_t,
        p_request: *const mpsl_timeslot_request_t,
    ) -> i32;
}
pub const MPSL_PHY_BLE_1M: mpsl_phy_t = 0;
pub const MPSL_PHY_BLE_2M: mpsl_phy_t = 1;
pub const MPSL_PHY_BLE_LR125Kbit: mpsl_phy_t = 2;
pub const MPSL_PHY_BLE_LR500Kbit: mpsl_phy_t = 3;
pub const MPSL_PHY_Ieee802154_250Kbit: mpsl_phy_t = 4;
pub const MPSL_PHY_NRF_1Mbit: mpsl_phy_t = 5;
pub const MPSL_PHY_NRF_2Mbit: mpsl_phy_t = 6;
pub const MPSL_PHY_NRF_250Kbit: mpsl_phy_t = 7;
pub const MPSL_PHY_NRF_4Mbit0_5: mpsl_phy_t = 8;
pub const MPSL_PHY_NRF_4Mbit0_25: mpsl_phy_t = 9;
pub const MPSL_PHY_NRF_4Mbit_0BT6: mpsl_phy_t = 10;
pub const MPSL_PHY_NRF_4Mbit_0BT4: mpsl_phy_t = 11;
#[doc = "Type enumerating PHYs."]
pub type mpsl_phy_t = ::core::ffi::c_uint;
#[doc = "TX power, dBm."]
pub type mpsl_tx_power_t = i8;
#[doc = "Max TX power envelope. It is up to the application to allocate memory for an envelope."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mpsl_tx_power_envelope_t {
    #[doc = "The PHY that this envelope applies to.\n\n The function mpsl_tx_power_channel_map_set supports only the following `phy` values:\n `MPSL_PHY_BLE_1M,` `MPSL_PHY_BLE_2M,` `MPSL_PHY_BLE_LR125Kbit,` `MPSL_PHY_BLE_LR500Kbit,`\n `MPSL_PHY_Ieee802154_250Kbit` ."]
    pub phy: mpsl_phy_t,
    #[doc = "< Array of maximum TX power value per channel. From 11 to 26 for 802.15.4 protocol.\nFrom 0 to 40 for Bluetooth LE protocol."]
    pub envelope: mpsl_tx_power_envelope_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mpsl_tx_power_envelope_t__bindgen_ty_1 {
    #[doc = "Tx power per channel when mpsl_tx_power_envelope_t::phy is a Bluetooth LE PHY."]
    pub tx_power_ble: [mpsl_tx_power_t; 40usize],
    #[doc = "Tx power per channel when mpsl_tx_power_envelope_t::phy is a 802.15.4 PHY."]
    pub tx_power_802154: [mpsl_tx_power_t; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mpsl_tx_power_envelope_t__bindgen_ty_1"]
        [::core::mem::size_of::<mpsl_tx_power_envelope_t__bindgen_ty_1>() - 40usize];
    ["Alignment of mpsl_tx_power_envelope_t__bindgen_ty_1"]
        [::core::mem::align_of::<mpsl_tx_power_envelope_t__bindgen_ty_1>() - 1usize];
    ["Offset of field: mpsl_tx_power_envelope_t__bindgen_ty_1::tx_power_ble"]
        [::core::mem::offset_of!(mpsl_tx_power_envelope_t__bindgen_ty_1, tx_power_ble) - 0usize];
    ["Offset of field: mpsl_tx_power_envelope_t__bindgen_ty_1::tx_power_802154"]
        [::core::mem::offset_of!(mpsl_tx_power_envelope_t__bindgen_ty_1, tx_power_802154) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mpsl_tx_power_envelope_t"][::core::mem::size_of::<mpsl_tx_power_envelope_t>() - 44usize];
    ["Alignment of mpsl_tx_power_envelope_t"][::core::mem::align_of::<mpsl_tx_power_envelope_t>() - 4usize];
    ["Offset of field: mpsl_tx_power_envelope_t::phy"][::core::mem::offset_of!(mpsl_tx_power_envelope_t, phy) - 0usize];
    ["Offset of field: mpsl_tx_power_envelope_t::envelope"]
        [::core::mem::offset_of!(mpsl_tx_power_envelope_t, envelope) - 4usize];
};
unsafe extern "C" {
    #[doc = "Sets maximum TX power envelope. If the PHY already has an envelope configured, it will be over-written.\n\n > **Note:** Calling this function while an envelope is being used to limit current TX Power\n may lead to undefined behavior.\n\n > **Note:** The memory for the provided envelope is not copied and must be valid until it is replaced\n with another envelope for the same PHY.\n\n # Arguments\n\n* `[in]` -p_envelope The pointer to an envelope, if NULL the envelopes for all PHYs are reset to\n maximum power possible.\n\n # Returns\n\n* `0` - TX power channel successfully set.\n * `-NRF_EINVAL` - Invalid parameter provided."]
    pub fn mpsl_tx_power_channel_map_set(p_envelope: *const mpsl_tx_power_envelope_t) -> i32;
}
unsafe extern "C" {
    #[doc = "Adjusts TX power to a value supported by the RADIO peripheral.\n\n # Arguments\n\n* `[in]` -req_radio_power Requested TX power desired for RADIO peripheral.\n * `[in]` -tx_power_ceiling Flag to get ceiling or floor of requested RADIO TX power level.\n\n # Returns\n\nRADIO TX power that is supported by the RADIO peripheral.\n If `req_radio_power` is less than the minimum TX power supported, the minimum\n supported TX power is returned. If `req_radio_power` is more than the maximum\n TX power supported, the maximum supported TX power is returned.\n Otherwise the closest supported value that is, depending on `tx_power_ceiling,`\n less or more, or equal to `req_radio_power` is returned."]
    pub fn mpsl_tx_power_radio_supported_power_adjust(
        req_radio_power: mpsl_tx_power_t,
        tx_power_ceiling: i8,
    ) -> mpsl_tx_power_t;
}
unsafe extern "C" {
    #[doc = "Converts radio power in dBm to RADIO.TXPOWER register code.\n\n # Arguments\n\n* `[in]` -req_radio_power Requested TX power desired for RADIO peripheral.\n The power value in dBm must be supported by the RADIO peripheral.\n\n # Returns\n\nRADIO.TXPOWER register code corresponding to radio power in dBm."]
    pub fn mpsl_tx_power_dbm_to_radio_register_convert(req_radio_power: mpsl_tx_power_t) -> u32;
}
